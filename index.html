
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Writer App — Slots UI Improved (fixed v2)</title>
  <style>
    :root{ --bg:#f9fafb;--accent:#4f46e5;--muted:#6b7280; --shadow:0 4px 14px rgba(0,0,0,0.08);--border:#e5e7eb; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, -apple-system, Arial,sans-serif;background:var(--bg);color:#111827;font-size:16px;line-height:1.45;}
    h1,h2{margin:16px 0;text-align:center}
    button,input,select,textarea{font-family:inherit;font-size:14px}
    .btn{padding:14px 20px;border:none;border-radius:14px;cursor:pointer;font-weight:700;transition:0.18s;box-shadow:0 8px 24px rgba(79,70,229,0.12)}
    .btn-primary{background:var(--accent);color:#fff}
    .btn-secondary{background:#e5e7eb;color:#111;border:1px solid #d1d5db}
    .btn:hover{opacity:0.95;transform:translateY(-1px)}
    .hidden{display:none!important}

.story-analytics-modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.45);
  z-index: 9999;
  padding: 20px;
  box-sizing: border-box;
}
.story-analytics-card {
  width: min(980px, 96%);
  max-height: 90vh;
  overflow: auto;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.25);
  padding: 18px;
  box-sizing: border-box;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}
.analytics-header {
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:space-between;
  margin-bottom:12px;
  flex-wrap:wrap;
}
.analytics-title { font-size:20px; font-weight:700; }
.analytics-summary {
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.summary-pill {
  padding:8px 12px;
  border-radius:10px;
  background:#f3f4f6;
  font-weight:600;
}
.status-pill {
  padding:8px 12px;
  border-radius:10px;
  font-weight:700;
  display:inline-block;
}
.analytics-body { margin-top:8px; }
.canvas-wrap { width:100%; height:360px; background:#fff; border-radius:8px; padding:10px; box-sizing:border-box; }
.legend { margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
.legend-item { display:flex; gap:6px; align-items:center; font-size:13px; }
.legend-swatch { width:14px; height:6px; border-radius:2px; display:inline-block; }
.close-analytics {
  background:transparent;
  border:0;
  font-size:18px;
  cursor:pointer;
}
.small-note { color:#6b7280; font-size:13px; margin-top:8px; }

    /* Header */
    header{position:fixed;top:12px;left:12px;z-index:60}
    .profile-btn{width:56px;height:56px;border-radius:50%;background:white; box-shadow:0 10px 30px rgba(0,0,0,0.12); display:flex;align-items:center;justify-content:center; border:none;cursor:pointer;overflow:hidden;font-size:16px}
    .profile-initials{font-weight:700;color:var(--accent);font-size:16px}
    .dropdown{position:absolute;background:white;border:1px solid var(--border);border-radius:10px; box-shadow:0 4px 14px rgba(0,0,0,0.08);padding:8px;display:none;flex-direction:column; min-width:220px;z-index:55}
    .dropdown button{background:transparent;border:none;padding:10px;border-radius:8px;text-align:left;cursor:pointer;font-size:15px}
    .dropdown button:hover{background:#f3f4f6}

    /* Main */
    main{display:flex;flex-direction:column;align-items:center;justify-content:center; height:100vh;text-align:center;padding:20px}
    .buttons{display:flex;flex-direction:column;gap:12px;align-items:center}
    .btn-small{padding:10px 16px;font-size:16px;border-radius:12px}

.jelly-btn {
  background-color: white;
  color: #333; /* dark text */
  font-weight: bold;
  padding: 10px 25px;
  border: 2px solid #ccc;
  border-radius: 50px;
  cursor: pointer;
  font-size: 16px;
  position: relative;
  overflow: hidden;
  outline: none;
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
}

.jelly-btn:hover {
  transform: scale(1.1);
  box-shadow: 0 8px 15px rgba(0,0,0,0.2);
  border-color: #888;
}

.jelly-btn:active {
  animation: jelly 0.6s;
}

/* Wobble animation */
@keyframes jelly {
  0% { transform: scale(1, 1); }
  25% { transform: scale(1.2, 0.8); }
  50% { transform: scale(0.8, 1.2); }
  75% { transform: scale(1.1, 0.9); }
  100% { transform: scale(1, 1); }
}

    /* Form */
    .form-container{max-width:680px;margin:40px auto;padding:24px;background:#fff;border-radius:12px;box-shadow:var(--shadow)}
    label{display:block;margin:8px 0 4px;font-weight:600;color:var(--muted)}
    input,select,textarea{width:100%;padding:10px;border:1px solid var(--border);border-radius:8px;margin-bottom:12px}
    .genres-container{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;margin-bottom:16px}
    .genre-option{padding:8px 14px;border:1px solid var(--border);border-radius:20px;cursor:pointer; background:#f9fafb;transition:0.2s}
    .genre-option.active{background:var(--accent);color:#fff;border-color:var(--accent)}

    /* Dashboard */
    #dashboardPage{padding:24px;min-height:100vh}
    .dashboard-header{display:flex;flex-direction:column;align-items:center;margin-bottom:20px;gap:12px;text-align:center}
    .dashboard-card{padding:16px;background:#fff;margin-bottom:12px;border-radius:12px;box-shadow:var(--shadow);display:flex;justify-content:space-between;gap:8px;align-items:center}
    .dashboard-card .meta{color:var(--muted);font-size:13px;margin-top:6px}
    .dashboard-card h3{margin:0;font-size:18px}
    .dashboard-card p{margin:6px 0;color:#111827}
    .dashboard-card .desc{color:#374151}
    .status-public{color:green;font-weight:700}
    .status-draft{color:#b45309;font-weight:700}
    .card-actions{display:flex;gap:8px;align-items:center}
    .small-btn{padding:6px 10px;border-radius:8px;font-weight:600}

    /* Editor Page */
    #editorPage{position:fixed;inset:0;background:var(--bg);z-index:100;display:flex;flex-direction:column;padding:18px;gap:12px}
    .sheets-bar{display:flex;gap:8px;overflow-x:auto;padding-bottom:8px}
    .sheet-thumb{position:relative;min-width:180px;min-height:80px;background:#fff;border:1px solid var(--border);border-radius:12px;padding:12px;font-size:14px;box-shadow:0 6px 18px rgba(0,0,0,0.08);cursor:pointer;white-space:pre-wrap;overflow:hidden;text-overflow:ellipsis}
    .sheet-thumb.active{border:2px solid var(--accent)}
    .sheet-thumb .del{position:absolute;top:6px;right:6px;background:transparent;border:none;font-size:12px;cursor:pointer;padding:4px;border-radius:4px}
    .add-sheet-btn{min-width:40px;min-height:60px;border:1px dashed var(--accent);border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:bold;color:var(--accent);cursor:pointer;flex-shrink:0}
    .sheet-textarea{flex:1;padding:18px;border:1px solid var(--border);border-radius:12px;font-size:16px;resize:none;min-height:320px}
    .editor-actions{display:flex;gap:12px;justify-content:flex-end;margin-top:8px}

    /* Slots Page */
    #slotsContainer{display:flex;gap:24px;flex-wrap:wrap;justify-content:center;padding:16px}
    .slot-card{width:260px;height:220px;background:#fff;border-radius:20px;display:flex;align-items:center;justify-content:center;flex-direction:column;cursor:pointer;position:relative;box-shadow:0 14px 40px rgba(0,0,0,0.14);font-size:18px;text-align:center;transition:all 0.22s;padding:16px}
    .slot-card:hover{transform:translateY(-4px);box-shadow:0 10px 24px rgba(0,0,0,0.15)}
    .slot-card.locked{background:#f3f4f6;color:#111827;font-weight:600}
    .slot-card.locked::before{content:"🔒";font-size:24px;position:absolute;top:8px;right:8px}
    .slot-card .slot-title{font-weight:700;margin-bottom:6px}
    .slot-card .slot-meta{font-size:13px;color:var(--muted)}

    /* Popups */
    .popup { position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35);z-index:300}
    .popup .popup-content{background:#fff;padding:20px;border-radius:12px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.15);max-width:520px;width:92%}
    .popup input{width:100%;padding:10px;margin-bottom:12px;border:1px solid var(--border);border-radius:8px;font-size:16px}

    /* Back button (left bottom) */
    .back-btn{position:fixed;left:18px;bottom:18px;background:#fff;color:#111;padding:10px 14px;border-radius:12px;border:1px solid var(--border);cursor:pointer;font-weight:700;box-shadow:0 8px 30px rgba(0,0,0,0.12)}
    .back-btn .icon{margin-right:8px}

    /* small helpers */
    .row{display:flex;gap:12px;align-items:center;justify-content:center}
    .muted{color:var(--muted)}
  
    
    /* Smaller and mobile-friendly categories */
    #categoriesPage, #serialCategoriesPage {padding:20px;min-height:100vh;display:flex;flex-direction:column;align-items:center;gap:14px;background:var(--bg)}
    .categories-header{max-width:800px;width:100%;text-align:center}
    .categories-grid{display:flex;gap:10px;flex-wrap:nowrap;overflow-x:auto;padding:8px 4px;width:100%;justify-content:center}
    .cat-card{flex:0 0 auto;padding:12px 18px;border-radius:14px;background:#fff;box-shadow:var(--shadow);min-width:110px;text-align:center;cursor:pointer;border:1px solid var(--border);transition:transform .15s, box-shadow .15s}
    .cat-card .cat-title{font-weight:700;margin-bottom:4px;font-size:14px}
    .cat-card .cat-sub{font-size:12px;color:var(--muted)}
    .cat-card:hover{transform:translateY(-3px);box-shadow:0 10px 25px rgba(0,0,0,0.08)}
    .cat-card.active{background:linear-gradient(135deg,var(--accent),#7c3aed);color:#fff;border-color:transparent;box-shadow:0 14px 35px rgba(79,70,229,0.18)}
    .categories-grid::-webkit-scrollbar{height:6px}
    .categories-grid::-webkit-scrollbar-thumb{background:#d1d5db;border-radius:6px}
    #categoriesBackBtn, #serialCategoriesBackBtn{position:fixed;left:14px;bottom:14px}



    /* full-width story cards */
   #storiesCards {
  display: flex;
  flex-direction: column;
  gap: 32px;
  width: 100%;
  align-items: center;
}

.story-card {
  width: 280px;
  height: 420px;
  background: linear-gradient(180deg, #fdf6f0, #e0d8c0);
  border-radius: 14px;
  padding: 24px;
  color: #0f172a;
  box-shadow: 0 10px 25px rgba(0,0,0,0.25);
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  position: relative;
  font-family: 'Georgia', serif;
  overflow: hidden;
  cursor: pointer;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.story-card:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 15px 30px rgba(0,0,0,0.3);
}

.story-card::before {
  content: "";
  position: absolute;
  inset: 0;
  background: url('your-cover-image.jpg') center/cover no-repeat;
  opacity: 0.15;
  pointer-events: none;
}

.story-card h2 {
  margin: 0;
  font-size: 1.8rem;
  font-weight: bold;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.story-card p {
  margin: 4px 0 0;
  font-size: 1rem;
  font-style: italic;
  text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
}

.story-card .read-btn,
.story-card .view-serial-btn {
  margin-top: 12px;
  padding: 8px 16px;
  border: none;
  background: #1e40af;
  color: #fff;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  transition: background 0.2s ease;
}

.story-card .read-btn:hover,
.story-card .view-serial-btn:hover {
  background: #1e3a8a;
}
.scroll-wrap {
  display: flex;
  overflow-x: auto;
  gap: 12px;
  padding: 12px;
  scroll-behavior: smooth;
  flex-wrap: nowrap;
  position: relative; /* important for overlay effect */
}

    /* Fullscreen preview */
    .fullscreen-panel{position:fixed;inset:0;background:var(--bg);z-index:800;display:flex;flex-direction:column;padding:22px;overflow:auto}
    .fullscreen-panel .panel-inner{max-width:1100px;margin:12px auto;display:flex;flex-direction:column;gap:12px}
    .panel-top{display:flex;justify-content:space-between;align-items:flex-start;gap:12px}
    .panel-meta{color:var(--muted)}
    /* Fullscreen reader */
    .reader-full{position:fixed;inset:0;background:#ffffff;z-index:900;display:flex;flex-direction:column;padding:18px;overflow:auto}
    .reader-header{display:flex;justify-content:space-between;align-items:center}
    .reader-body{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center;justify-content:center;padding:12px}
    .reader-sheet{width:100%;max-width:980px;border-radius:10px;padding:18px;min-height:240px;font-size:18px;line-height:1.6;background:linear-gradient(180deg,#fff,#fbfbff);box-shadow:0 12px 40px rgba(0,0,0,0.06)}


/* Added tweaks for murbal: ensure story cards use full-color gradient and fixed height */
.story-card{ color:#0f172a; border-radius:12px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,0.08); min-height:180px; display:flex; flex-direction:column; justify-content:space-between; }
.story-card h4{ margin:0; font-size:18px; font-weight:700; }
.story-card p{ margin:0; }

</style>
</head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<body>
  <header>
    <button class="profile-btn" id="profileBtn"><span class="profile-initials">??</span></button>
    <div class="dropdown" id="profileDropdown"></div>
  </header>

  <main id="welcomePage">
    <h1>Welcome!</h1>
    <div class="buttons">
      <button id="browseStoriesBtn" class="btn btn-primary btn-small">📖 Browse Stories</button>
      <button id="browseSerialsBtn" class="btn btn-secondary btn-small">🎬 Browse Serials</button>
      <button id="createContentBtn" class="btn btn-primary btn-small">✍️ Create Story / Serial</button>
    </div>
  </main>


  <!-- Categories Page (opened from Browse Stories) -->
  <div id="categoriesPage" class="hidden">
    <button class="back-btn" id="categoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Stories</h2>
    </div>
    <div class="categories-grid" id="categoriesGrid" aria-label="story categories">
      <!-- Stories list shown after selecting a category -->
      </div>
      <div id="storiesBrowseList" style="max-width:980px;margin:18px auto;display:none">
        <h3 style="text-align:left;margin:6px 12px">Stories</h3>
        <div id="storiesCards" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;padding:12px"></div>
      </div>
      <!-- Fullscreen Preview & Reader Containers -->
  <div id="previewFull" class="hidden"></div>

  <div id="readerFull" class="hidden"></div>


      <div id="readerModal" class="hidden popup">
        <div class="popup-content" style="width:90%;max-width:900px;padding:12px">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <h3 id="readerTitle">Story</h3>
              <div class="muted" id="readerMeta"></div>
            </div>
            <div style="display:flex;gap:8px">
              <button id="readerDownloadBtn" class="btn btn-secondary">Download Story</button>
              <button id="readerLikeBtn" class="btn btn-secondary">👍 Like <span id="readerLikeCount">0</span></button>
              <button id="readerDislikeBtn" class="btn btn-secondary">👎 Dislike <span id="readerDislikeCount">0</span></button>
              <button id="readerCloseBtn" class="btn btn-secondary">Close</button>
            </div>
          </div>
          <div id="readerContent" style="min-height:260px;padding:12px;margin-top:12px;border-radius:8px;background:#fff;overflow:hidden;position:relative">
            <div id="readerSheet" style="min-height:200px"></div>
          </div>
          <div style="display:flex;justify-content:center;gap:12px;margin-top:12px">
            <button id="readerPrevBtn" class="btn btn-secondary">◀ Prev</button>
            <span id="readerPager" class="muted"></span>
            <button id="readerNextBtn" class="btn btn-primary">Next ▶</button>
          </div>
        </div>
      </div>

      <!-- cards injected by JS -->
    </div>
  </div>

  
  <!-- Serials Categories Page -->
  <div id="serialCategoriesPage" class="hidden">
    <button class="back-btn" id="serialCategoriesBackBtn">← Back</button>
    <div class="categories-header">
      <h2>Browse Serial Categories</h2>
      <p class="muted" style="margin:6px 0 12px">Choose a genre to explore serials. Swipe or scroll horizontally to see all categories.</p>
    </div>
    <div class="categories-grid" id="serialCategoriesGrid" aria-label="serial categories">
      <!-- serial cards injected by JS -->
    </div>
  </div>

  <!-- Profile Form -->
  <div id="profileFormPage" class="form-container hidden">
    <h2>Create Writer Profile</h2>
    <label>Name</label><input type="text" id="profileName">
    <label>Age</label><input type="number" id="profileAge">
    <label>Country</label><input type="text" id="profileCountry">
    <label>Favourite Genres</label>
    <div class="genres-container" id="genresContainer">
      <label class="genre-option"><input type="checkbox" value="Horror">Horror</label>
      <label class="genre-option"><input type="checkbox" value="Comedy">Comedy</label>
      <label class="genre-option"><input type="checkbox" value="Action">Action</label>
      <label class="genre-option"><input type="checkbox" value="Tragic">Tragic</label>
      <label class="genre-option"><input type="checkbox" value="Romance">Romance</label>
      <label class="genre-option"><input type="checkbox" value="Fantasy">Fantasy</label>
      <label class="genre-option"><input type="checkbox" value="Thriller">Thriller</label>
         <label class="genre-option"><input type="checkbox" value="Adventure">Adventure</label>
      <label class="genre-option"><input type="checkbox" value="Crime">Crime</label>
      <label class="genre-option"><input type="checkbox" value="Historic">Historic</label>
    </div>
    <button class="btn btn-primary" id="saveProfileBtn">Create Profile</button>
  </div>

  <!-- Choose Type Popup -->
  <div id="chooseTypePopup" class="hidden popup">
    <div class="popup-content">
      <h2>What do you want to create?</h2>
      <div style="display:flex;gap:12px;justify-content:center;margin-top:12px">
        <button id="createStoryBtn" class="btn btn-primary">Story</button>
        <button id="createSerialBtn" class="btn btn-secondary">Serial</button>
      </div>
    </div>
  </div>

  <!-- Slot Name / Unlock Popup -->
  <div id="slotNamePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Name this slot</h3>
      <input id="slotNameInput" placeholder='Slot name (e.g. "My Fantasy Series")'>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button id="slotNameCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="slotNameUnlockBtn" class="btn btn-primary">Unlock Slot</button>
      </div>
    </div>
  </div>

  <!-- Serial Create Popup (series + episode1) -->
 <div id="serialCreatePopup" class="hidden popup">
  <div class="popup-content" style="max-width:480px;padding:16px;">
    <h3 style="margin-bottom:8px;">Create / Edit Serial</h3>

    <!-- Series Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Series Title</label>
      <input id="seriesTitleInput" placeholder="e.g. The Lost Scrolls" style="margin-bottom:6px;">
      <label>Genre</label>
      <select id="seriesGenreInput" style="margin-bottom:6px;">
        <option value="">Select genre</option>
        <option>Comedy</option>
        <option>Fantasy</option>
        <option>Horror</option>
        <option>Romance</option>
        <option>Action</option>
        <option>Tragic</option>
        <option>Thriller</option>
        <option>Adventure</option>
        <option>Crime</option>
        <option>Historic</option>
      </select>
      <label>Description (optional)</label>
      <textarea id="seriesDescInput" rows="2" placeholder="Short series description" style="margin-bottom:6px;"></textarea>
    </div>

    <!-- Tags -->
    <div style="margin-bottom:10px;">
      <label>Tags</label>
      <div style="display:flex;gap:6px;align-items:center;margin-top:4px;margin-bottom:6px;">
        <input id="seriesTagInput" placeholder="type a tag" style="flex:1;padding:8px;border-radius:6px;border:1px solid var(--border)">
        <button id="addSeriesTagBtn" class="btn btn-secondary" type="button" style="padding:6px 10px;">Add</button>
      </div>
      <div id="seriesTagsContainer" style="display:flex;flex-wrap:wrap;gap:6px;"></div>
    </div>

    <hr style="margin:10px 0;opacity:0.5;">

    <!-- Episode Section -->
    <div style="margin-bottom:8px;">
      <label style="font-weight:600;">Episode 1</label>
      <input id="ep1TitleInput" placeholder="Episode 1 title" style="margin-bottom:6px;">
      <textarea id="ep1DescInput" rows="2" placeholder="Short episode description" style="margin-bottom:6px;"></textarea>

      <!-- Cover -->
      <label>Series Cover</label>
      <input type="file" id="serialCoverInput" accept="image/*">
      <div id="serialCoverPreview" style="margin-top:6px;text-align:center;">
        <img id="serialCoverImg" src="" alt="Cover Preview"
          style="max-width:100px;height:180px;object-fit:cover;border-radius:8px;display:none;">
      </div>
    </div>

    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px;">
      <button id="serialCreateCancelBtn" class="btn btn-secondary" style="padding:6px 12px;">Cancel</button>
      <button id="serialCreateConfirmBtn" class="btn btn-primary" style="padding:6px 12px;">Create / Update</button>
    </div>
  </div>
</div>


  <!-- Add Episode Popup -->
  <div id="addEpisodePopup" class="hidden popup">
    <div class="popup-content">
      <h3>Add Episode</h3>
      <label>Episode Title</label>
      <input id="addEpTitleInput" placeholder="Episode title">
      <label>Episode Description (optional)</label>
      <textarea id="addEpDescInput" rows="2" placeholder="Episode description"></textarea>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="addEpCancelBtn" class="btn btn-secondary">Cancel</button>
        <button id="addEpConfirmBtn" class="btn btn-primary">Add Episode</button>
      </div>
    </div>
  </div>

  <!-- Slots Page -->
  <div id="slidesPage" class="hidden">
    <button class="back-btn" id="slotsBackBtn">← Back</button>
    <h2 style="text-align:center;margin-top:30px">Select a Slot</h2>
    <div id="slotsContainer"></div>
  </div>

  <!-- Story Form -->
  <div id="storyFormPage" class="form-container hidden">
    <h2>Create Story / Serial</h2>
    <label>Title</label><input type="text" id="storyTitle">
    <label>Genre</label>
    <select id="storyGenre">
      <option value="">Select genre</option>
      <option>Horror</option><option>Comedy</option><option>Action</option>
      <option>Romance</option><option>Tragic</option><option>Fantasy</option>
      <option>Thriller</option><option>Adventure</option><option>Crime</option>
       <option>Historic</option>
    </select>
    <label>Description</label>
    <textarea id="storyDesc" rows="3"></textarea>
    <label>Cover Image</label>
<input type="file" id="storyCoverInput" accept="image/*">

    <div id="storyCoverPreview" style="margin-top:10px;text-align:center;">
      <img id="storyCoverImg" src="" alt="Cover Preview" style="max-width:120px;height:220px;object-fit:cover;border-radius:12px;display:none;">
    </div>
    <!-- Story Tags UI (paste after storyDesc) -->
<label>Tags (press Add)</label>
<div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
  <input id="storyTagInput" placeholder="type a tag and press Add" style="flex:1;padding:10px;border-radius:8px;border:1px solid var(--border)" />
  <button id="addStoryTagBtn" class="btn btn-secondary" type="button">Add</button>
</div>
<div id="storyTagsContainer" style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px"></div>

    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button class="btn btn-secondary" id="cancelCreateBtn">Cancel</button>
      <button class="btn btn-primary" id="startCreatingBtn">Start Creating</button>
    </div>
  </div>

  <!-- Dashboard -->
<div id="dashboardPage" class="hidden">
  <div class="dashboard-header">
    <h2>Your Content</h2>
    <div class="row">
      <button class="btn btn-primary" id="showStoriesBtn">Your Stories</button>
      <button class="btn btn-secondary" id="showSerialsBtn">Your Serials</button>
    </div>
  </div>

  <div id="dashboardList"></div>
  <button class="back-btn hidden" id="dashboardBackBtn">← Back</button>
</div>


  <script>
    // ---------- Variables ----------
    const STORAGE_KEY = "writerProfile_v1";

    // palette for random card colors (bright)
    const CARD_COLOR_PALETTE = ['#FF6B6B','#FF8A65','#FFB86B','#FFD166','#6EE7B7','#4FD1FF','#60A5FA','#A78BFA','#FF7AB6','#2DD4BF'];
    function pickCardColor(){ return CARD_COLOR_PALETTE[Math.floor(Math.random()*CARD_COLOR_PALETTE.length)]; }

    let profileExists = false, storiesData = [], serialsData = [];
    let storySlots = [], serialSlots = [];
    let currentType = 'story', selectedSlot = null;

    // Elements
    const profileBtn = document.getElementById('profileBtn');
    const profileDropdown = document.getElementById('profileDropdown');
    const profileFormPage = document.getElementById('profileFormPage');
    const saveProfileBtn = document.getElementById('saveProfileBtn');
    const profileName = document.getElementById('profileName');
    const profileAge = document.getElementById('profileAge');
    const profileCountry = document.getElementById('profileCountry');
    const welcomePage = document.getElementById('welcomePage');
    const createContentBtn = document.getElementById('createContentBtn');
    const storyFormPage = document.getElementById('storyFormPage');
    const storyTitleInput = document.getElementById('storyTitle');
    const storyGenreSelect = document.getElementById('storyGenre');
    const storyDescInput = document.getElementById('storyDesc');
    const startCreatingBtn = document.getElementById('startCreatingBtn');
    const dashboardPage = document.getElementById('dashboardPage');
    const dashboardList = document.getElementById('dashboardList');
    const slidesPage = document.getElementById('slidesPage');
    const slotsContainer = document.getElementById('slotsContainer');
    const chooseTypePopup = document.getElementById('chooseTypePopup');
    const createStoryBtn = document.getElementById('createStoryBtn');
    const createSerialBtn = document.getElementById('createSerialBtn');
    const showStoriesBtn = document.getElementById('showStoriesBtn');
    const showSerialsBtn = document.getElementById('showSerialsBtn');
    const slotsBackBtn = document.getElementById('slotsBackBtn');
    const dashboardBackBtn = document.getElementById('dashboardBackBtn');
    const cancelCreateBtn = document.getElementById('cancelCreateBtn');

    // new popups
    const slotNamePopup = document.getElementById('slotNamePopup');
    const slotNameInput = document.getElementById('slotNameInput');
    const slotNameUnlockBtn = document.getElementById('slotNameUnlockBtn');
    const slotNameCancelBtn = document.getElementById('slotNameCancelBtn');

    const serialCreatePopup = document.getElementById('serialCreatePopup');
    const seriesTitleInput = document.getElementById('seriesTitleInput');
    const seriesGenreInput = document.getElementById('seriesGenreInput');
    const seriesDescInput = document.getElementById('seriesDescInput');
    const ep1TitleInput = document.getElementById('ep1TitleInput');
    const ep1DescInput = document.getElementById('ep1DescInput');
    const serialCreateConfirmBtn = document.getElementById('serialCreateConfirmBtn');
    const serialCreateCancelBtn = document.getElementById('serialCreateCancelBtn');

    const addEpisodePopup = document.getElementById('addEpisodePopup');
    const addEpTitleInput = document.getElementById('addEpTitleInput');
    const addEpDescInput = document.getElementById('addEpDescInput');
    const addEpConfirmBtn = document.getElementById('addEpConfirmBtn');
    const addEpCancelBtn = document.getElementById('addEpCancelBtn');
    let addEpisodeSerialIndex = null; // which serial we're adding to

    
// ---- Cover Image Handling ----
const coverInput = document.getElementById('storyCoverInput');
const coverImg = document.getElementById('storyCoverImg');
if (coverInput) {
  coverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        coverImg.src = ev.target.result;
        coverImg.style.display = 'block';
        window._currentStoryCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
}

// ---- Serial cover handling ----
const serialCoverInput = document.getElementById('serialCoverInput');
const serialCoverImg = document.getElementById('serialCoverImg');
if (serialCoverInput) {
  serialCoverInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        if (serialCoverImg) {
          serialCoverImg.src = ev.target.result;
          serialCoverImg.style.display = 'block';
        }
        window._currentSerialCover = ev.target.result;
      };
      reader.readAsDataURL(file);
    }
  });
} else {
  // create placeholders if elements aren't present yet
  window._serialCoverPending = true;
}

// Ensure current cover vars exist
window._currentStoryCover = window._currentStoryCover || '';
window._currentSerialCover = window._currentSerialCover || '';

// ---------- Profile ----------
    function loadProfile(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(raw){
          const profile = JSON.parse(raw);
          profileExists = true;
          updateProfileUI(profile);
        }
      }catch(e){console.warn(e)}
    }
    
    // show profile button only on home (welcomePage) — hide everywhere else
function updateHeaderVisibility() {
  const welcomePage = document.getElementById('welcomePage');
  const categoriesPage = document.getElementById('categoriesPage');
  const serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const profileDropdown = document.getElementById('profileDropdown');
  const profileBtn = document.getElementById('profileBtn'); // your reference

  if (!welcomePage || !categoriesPage || !serialCategoriesPage || !profileBtn) return;

  const onHome = !welcomePage.classList.contains('hidden');
  const onBrowseStories = !categoriesPage.classList.contains('hidden');
  const onBrowseSerials = !serialCategoriesPage.classList.contains('hidden');

  if (onHome) {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  } else if (onBrowseStories || onBrowseSerials) {
    profileBtn.classList.add('hidden');
    profileDropdown?.classList.add('hidden');
  } else {
    profileBtn.classList.remove('hidden');
    profileDropdown?.classList.remove('hidden');
  }

  console.log('Header updated:', { onHome, onBrowseStories, onBrowseSerials });
}

function updateProfileUI(profile){
      const initials = (profile.name||'??').slice(0,2).toUpperCase();
      profileBtn.innerHTML = `<span class="profile-initials">${initials}</span>`;
    }
   profileBtn.addEventListener('click', () => {
  // prevent dropdown opening on browse pages
  const onBrowseStories = !document.getElementById('categoriesPage').classList.contains('hidden');
  const onBrowseSerials = !document.getElementById('serialCategoriesPage').classList.contains('hidden');
  if (onBrowseStories || onBrowseSerials) return;

  profileDropdown.style.display = (profileDropdown.style.display === 'flex' ? 'none' : 'flex');
  renderDropdown();
});

    function renderDropdown(){
      profileDropdown.innerHTML = '';
      if(!profileExists){
        const btn = document.createElement('button');
        btn.textContent = '✍️ Create Profile';
        btn.addEventListener('click', ()=>{ profileFormPage.classList.remove('hidden'); welcomePage.classList.add('hidden'); profileDropdown.style.display='none'; });
        profileDropdown.appendChild(btn);
      } else {
        const btn = document.createElement('button');
        btn.textContent = '🧭 Writer Dashboard';
        btn.addEventListener('click', ()=>{ showDashboard('stories'); });
        profileDropdown.appendChild(btn);
      }
    }
    saveProfileBtn.addEventListener('click', ()=>{
      const genres = Array.from(document.querySelectorAll('#genresContainer input:checked')).map(c=>c.value);
      const profile = {name:profileName.value,age:profileAge.value,country:profileCountry.value,genres};
      localStorage.setItem(STORAGE_KEY, JSON.stringify(profile));
      profileExists = true; updateProfileUI(profile);
      profileFormPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility();
    });
    document.querySelectorAll('.genre-option').forEach(opt=>{
      opt.addEventListener('click', ()=>{ const input=opt.querySelector('input'); input.checked=!input.checked; opt.classList.toggle('active', input.checked); });
    });

    // ---------- Browse ----------
document.getElementById('browseStoriesBtn').addEventListener('click', () => {
  openCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

document.getElementById('browseSerialsBtn').addEventListener('click', () => {
  openSerialCategoriesPage();
  updateHeaderVisibility(); // ✅ update header after page change
});

    
    
  // ---------- Categories Page ----------
document.addEventListener('DOMContentLoaded', function() {
  // Elements
  const _browseStoriesBtn = document.getElementById('browseStoriesBtn');
  const _browseSerialsBtn = document.getElementById('browseSerialsBtn');
  const _categoriesBackBtn = document.getElementById('categoriesBackBtn');
  const _serialCategoriesBackBtn = document.getElementById('serialCategoriesBackBtn');

  const _welcomePage = document.getElementById('welcomePage');
  const _categoriesPage = document.getElementById('categoriesPage');
  const _categoriesGrid = document.getElementById('categoriesGrid');
  const _serialCategoriesPage = document.getElementById('serialCategoriesPage');
  const _serialCategoriesGrid = document.getElementById('serialCategoriesGrid');

  // Safe header updater
  function safeUpdateHeader() {
    if (typeof updateHeaderVisibility === 'function') {
      updateHeaderVisibility();
    }
  }

  // Render categories
  function renderCategories(targetGrid){
    if(!targetGrid) return;
    targetGrid.innerHTML = '';
    CATEGORIES.forEach(cat=>{
      const card = document.createElement('div');
      card.className = 'cat-card';
      card.innerHTML = '<div class="cat-title">'+cat+'</div><div class="cat-sub">'+(cat==='All' ? 'All genres' : (cat + ' stories'))+'</div>';
      card.addEventListener('click', ()=>{
        targetGrid.querySelectorAll('.cat-card').forEach(c=>c.classList.remove('active'));
        card.classList.add('active');
      });
      targetGrid.appendChild(card);
    });
  }

  // Event listeners
  _browseStoriesBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _categoriesPage?.classList.remove('hidden');
    if (_categoriesGrid) {
      renderCategories(_categoriesGrid);
      _categoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _browseSerialsBtn?.addEventListener('click', () => {
    _welcomePage?.classList.add('hidden');
    _serialCategoriesPage?.classList.remove('hidden');
    if (_serialCategoriesGrid) {
      renderCategories(_serialCategoriesGrid);
      _serialCategoriesGrid.scrollLeft = 0;
    }
   updateHeaderVisibility();
  });

  _categoriesBackBtn?.addEventListener('click', () => {
    _categoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });

  _serialCategoriesBackBtn?.addEventListener('click', () => {
    _serialCategoriesPage?.classList.add('hidden');
    _welcomePage?.classList.remove('hidden');
    updateHeaderVisibility();
  });
});



    // ---------- End Categories Page ----------
    
    // ---------- Create ----------
    createContentBtn.addEventListener('click', ()=>{ if(!profileExists){ alert('Create a writer profile first!'); return; } chooseTypePopup.classList.remove('hidden'); });
    createStoryBtn.addEventListener('click', ()=>{ currentType='story'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });
    createSerialBtn.addEventListener('click', ()=>{ currentType='serial'; chooseTypePopup.classList.add('hidden'); showSlotsPage(); });

    // ---------- Slots Page ----------
    function showSlotsPage(){ welcomePage.classList.add('hidden'); slidesPage.classList.remove('hidden'); renderSlots(); updateHeaderVisibility(); }
    function renderSlots(){
      slotsContainer.innerHTML='';
      let slots = currentType==='story'? storySlots : serialSlots;
      if(slots.length===0) slots = [{id:0,unlocked:false,name:''}];
      slots.forEach((slot,index)=>{
        const div = document.createElement('div');
        div.className = 'slot-card ' + (slot.unlocked ? 'unlocked' : 'locked');
        const meta = slot.unlocked ? (`Episodes: ${ (slot.episodes || []).length }`) : 'Unlock to start';
        div.innerHTML = `<div class="slot-title">${slot.unlocked? (slot.name || ('Slot '+(slot.id+1))) : 'Locked Slot'}</div>
                         <div class="slot-meta">${meta}</div>`;
        div.addEventListener('click', ()=>{ selectedSlot = slot; if(!slot.unlocked){
            // first click: ask to name & unlock (do not auto-open editor)
            slotNameInput.value = slot.name || '';
            slotNamePopup.dataset.slotIndex = index;
            // clear any temporary cover selection so new slots don't inherit previous cover
            window._currentStoryCover = '';
            window._currentSerialCover = '';
            if (document.getElementById('storyCoverImg')) { document.getElementById('storyCoverImg').style.display='none'; document.getElementById('storyCoverImg').src=''; }
            if (document.getElementById('serialCoverImg')) { document.getElementById('serialCoverImg').style.display='none'; document.getElementById('serialCoverImg').src=''; }
            slotNamePopup.dataset.slotIndex = index;
            slotNamePopup.classList.remove('hidden');
        } else {
          // already unlocked
          if(currentType==='story') showStoryForm(slot.name || '');
          else {
            // SERIALS: auto-open the Serial Create/Edit form prefilled for this slot
            // If there's an existing serial with this name, prefill with its data (edit flow), otherwise prefill title and open create form
            const existing = serialsData.find(s=> s.title === slot.name);
            serialCreatePopup.dataset.slotIndex = index;
            if(existing){
              seriesTitleInput.value = existing.title || slot.name || '';
              seriesGenreInput.value = existing.genre || '';
              seriesDescInput.value = existing.description || '';
              // leave episode1 fields empty (user can add a new ep or edit existing eps later)
              ep1TitleInput.value = '';
              ep1DescInput.value = '';
              // load existing cover into preview
              window._currentSerialCover = existing.cover || '';
              if (window._currentSerialCover && document.getElementById('serialCoverImg')) {
                document.getElementById('serialCoverImg').src = window._currentSerialCover;
                document.getElementById('serialCoverImg').style.display = 'block';
              } else if (document.getElementById('serialCoverImg')) {
                document.getElementById('serialCoverImg').style.display = 'none';
                document.getElementById('serialCoverImg').src = '';
              }
            } else {
              seriesTitleInput.value = slot.name || '';
              seriesGenreInput.value = '';
              seriesDescInput.value = '';
              ep1TitleInput.value = '';
              ep1DescInput.value = '';
              // clear any previous serial cover when creating new
              window._currentSerialCover = '';
              if (document.getElementById('serialCoverImg')) { document.getElementById('serialCoverImg').style.display='none'; document.getElementById('serialCoverImg').src=''; }
            }
            serialCreatePopup.classList.remove('hidden');
          }
        }});
        slotsContainer.appendChild(div);
      });
      if(currentType==='story') storySlots = slots; else serialSlots = slots;
    }
    slotsBackBtn.addEventListener('click', ()=>{ slidesPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); updateHeaderVisibility(); });

    // ---------- Slot Name Popup handlers ----------
    slotNameCancelBtn.addEventListener('click', ()=>{ slotNamePopup.classList.add('hidden'); });
    slotNameUnlockBtn.addEventListener('click', ()=>{
      const idx = parseInt(slotNamePopup.dataset.slotIndex || '0', 10);
      const name = slotNameInput.value.trim();
      let slotsArr = currentType==='story' ? storySlots : serialSlots;
      if(slotsArr.length === 0) slotsArr = [{id:0,unlocked:false,name:''}];
      if(!slotsArr[idx]){ slotsArr[idx] = { id: idx, unlocked: false, name: '' }; }
      // set name and unlock, but DO NOT open the create form immediately
      slotsArr[idx].name = name || ('Slot ' + (idx+1));
      slotsArr[idx].unlocked = true;
      // ensure there is always an empty locked slot at the end
      if(slotsArr[slotsArr.length-1] === slotsArr[idx]) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      if(currentType==='story') storySlots = slotsArr; else serialSlots = slotsArr;
      slotNamePopup.classList.add('hidden');
      renderSlots();
    });

    // ---------- Serial Create Popup handlers ----------
    serialCreateCancelBtn.addEventListener('click', ()=>{ serialCreatePopup.classList.add('hidden'); });
    serialCreateConfirmBtn.addEventListener('click', ()=>{
      const title = seriesTitleInput.value.trim();
      const genre = seriesGenreInput.value.trim();
      const sdesc = seriesDescInput.value.trim();
      const epTitle = ep1TitleInput.value.trim();
      const epDesc = ep1DescInput.value.trim();
      if(!title){ alert('Series title is required'); return; }

      // If a serial with same title exists, update it; otherwise create new
      let serIndex = serialsData.findIndex(s=> s.title === title);
      let ser;
      if(serIndex >= 0){
        ser = serialsData[serIndex];
        ser.genre = genre; ser.description = sdesc;
      } else {
        ser = { title, genre, description: sdesc, episodes: [], cover: (window._currentSerialCover || '') };
        serialsData.push(ser);
        serIndex = serialsData.indexOf(ser);
      }
      // always update cover from current selection
      ser.cover = window._currentSerialCover || '';


      // If episode1 fields were provided, create episode 1 and open editor for it
      if(epTitle){
        ser.episodes = ser.episodes || [];
        // Only add episode if none exist or the last episode title differs
        const lastEp = ser.episodes[ser.episodes.length - 1];
        if(!lastEp || lastEp.title !== epTitle){
          ser.episodes.push({ title: epTitle, description: epDesc || '', sheets: [], status: 'Draft' });
        }
      }

      // update slot that matches this title (or slot index passed)
      const idx = parseInt(serialCreatePopup.dataset.slotIndex || '-1', 10);
      let slotsArr = serialSlots.length? serialSlots : [{id:0,unlocked:false,name:''}];
      // find slot with same name, else use idx
      let slotToUpdate = slotsArr.find(s=> s.name === title) || (slotsArr[idx] || slotsArr[0]);
      slotToUpdate.unlocked = true; slotToUpdate.name = title; slotToUpdate.episodes = ser.episodes.slice(); slotToUpdate.cover = ser.cover || '';
      if(slotsArr[slotsArr.length-1] === slotToUpdate) slotsArr.push({id: slotsArr.length, unlocked: false, name: ''});
      serialSlots = slotsArr;

      serialCreatePopup.classList.add('hidden');
      renderSlots();

      // open editor for the newly created episode if we added one (choose last created episode index)
      if(epTitle){
        const epIndex = ser.episodes.length - 1;
        createEditorPage(ser.episodes[epIndex].title, ser.genre, ser.episodes[epIndex].description, { isEdit:true, editType:'serial', index: serIndex, episodeIndex: epIndex });
      }
    });

    // ---------- Add Episode Popup handlers ----------
    addEpCancelBtn.addEventListener('click', ()=>{ addEpisodePopup.classList.add('hidden'); addEpisodeSerialIndex = null; });
    addEpConfirmBtn.addEventListener('click', ()=>{
      const title = addEpTitleInput.value.trim(); const desc = addEpDescInput.value.trim();
      if(!title){ alert('Episode title is required'); return; }
      if(addEpisodeSerialIndex == null){ alert('Serial not selected'); addEpisodePopup.classList.add('hidden'); return; }
      const ser = serialsData[addEpisodeSerialIndex]; if(!ser){ alert('Serial not found'); addEpisodePopup.classList.add('hidden'); return; }
      addEpisodePopup.classList.add('hidden');
      createEditorPage(title, ser.genre, desc, { isEdit:false, editType:'serial', index: addEpisodeSerialIndex, isNewEpisode:true });
      addEpisodeSerialIndex = null;
    });

    // ---------- Story Form & Editor ----------
    function showStoryForm(title=''){ slidesPage.classList.add('hidden'); storyFormPage.classList.remove('hidden'); storyTitleInput.value = title; storyGenreSelect.value=''; storyDescInput.value=''; updateHeaderVisibility(); }
    cancelCreateBtn.addEventListener('click', ()=>{ storyFormPage.classList.add('hidden'); slidesPage.classList.remove('hidden'); updateHeaderVisibility(); });

    startCreatingBtn.addEventListener('click', ()=>{
      // carry-over any tags entered in the story form into pending tags map
      try{
        const t = (document.getElementById('storyTitle') && document.getElementById('storyTitle').value && document.getElementById('storyTitle').value.trim()) ? document.getElementById('storyTitle').value.trim() : 'temp_story';
        const tagsFromForm = getTagsFromContainer(document.getElementById('storyTagsContainer')) || [];
        window._pendingTags = window._pendingTags || {};
        if (tagsFromForm.length) window._pendingTags[t] = Array.from(new Set([...(window._pendingTags[t]||[]), ...tagsFromForm]));
      }catch(e){ console.warn('carry tags into pending failed', e); }

      if(!storyTitleInput.value || !storyGenreSelect.value){ alert('Fill Title & Genre'); return; }
      storyFormPage.classList.add('hidden'); createEditorPage(storyTitleInput.value, storyGenreSelect.value, storyDescInput.value, {isEdit:false, editType:'story'});
    });

    function createEditorPage(title, genre, desc, opts={}){
      // opts: {isEdit, editType:'story'|'serial', index, episodeIndex, isNewEpisode}
      const editType = opts.editType || 'story';
      const isEdit = !!opts.isEdit;
      const isNewEpisode = !!opts.isNewEpisode;

      const editorDiv = document.createElement('div'); editorDiv.id='editorPage';
      editorDiv.innerHTML = `
  ${(editType==='serial' && opts.isEdit && opts.episodeIndex===0) ? `
    <div style="background:#fff8e1;border:1px solid #facc15; border-radius:10px;padding:10px;margin-bottom:8px; text-align:center;font-weight:600;color:#92400e;"> ⚠️ Please create a new sheet before writing your Episode 1 by clicking the + button. </div>` : ''}

        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
          <div>
            <h2 style="margin:0">${editType==='serial' ? (isEdit && opts.episodeIndex!=null ? 'Edit Episode' : (isNewEpisode ? 'New Episode' : 'Edit Serial')) : (isEdit? 'Edit Story' : 'New Story')}</h2>
            <div class="muted">${genre || ''} ${desc? (' • '+desc) : ''}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="btn btn-secondary" id="closeEditorBtn">Close</button>
          </div>
        </div>
        <div class="sheets-bar" id="sheetsBar"><div class="add-sheet-btn" id="addSheetBtn">+</div></div>
        <textarea id="sheetTextarea" class="sheet-textarea" placeholder="Type your story..."></textarea>
        <div style="display:flex;justify-content:flex-start;gap:8px;margin-top:6px"><button id="deleteSheetBtn" class="btn btn-secondary">Delete Active Sheet</button></div>
        <div class="editor-actions">
          <button class="btn btn-secondary" id="saveDraftBtn">Save Draft</button>
          <button class="btn btn-primary" id="publishStoryBtn">${isEdit && editType==='story' ? 'Update' : (isEdit && editType==='serial' && opts.episodeIndex!=null ? 'Update' : (editType==='story' ? 'Publish' : 'Publish Episode'))}</button>
        </div>
      `;
      document.body.appendChild(editorDiv); updateHeaderVisibility();

      const sheetsBar = editorDiv.querySelector('#sheetsBar');
      const addSheetBtn = editorDiv.querySelector('#addSheetBtn');
      const sheetTextarea = editorDiv.querySelector('#sheetTextarea');
      const publishStoryBtn = editorDiv.querySelector('#publishStoryBtn');
      const saveDraftBtnLocal = editorDiv.querySelector('#saveDraftBtn');
      const closeEditorBtn = editorDiv.querySelector('#closeEditorBtn');
      const deleteSheetBtn = editorDiv.querySelector('#deleteSheetBtn');

      let sheets = [], activeSheetId = 0;
      function addNewSheet(content=''){ saveActiveSheet(); const id = sheets.length; sheets.push({id,content}); activeSheetId=id; renderSheetsBar(); sheetTextarea.value = content; sheetTextarea.focus(); }
      function renderSheetsBar(){
        sheetsBar.querySelectorAll('.sheet-thumb').forEach(e=>e.remove());
        sheets.forEach(sheet=>{
          const thumb = document.createElement('div'); thumb.className = 'sheet-thumb' + (sheet.id===activeSheetId ? ' active' : '');
          thumb.innerHTML = `<div class="thumb-text">${(sheet.content||'').slice(0,60) || 'Empty'}</div>`;
          // delete button on the thumb
          const del = document.createElement('button'); del.className = 'del'; del.innerHTML = '✖';
          del.title = 'Delete this sheet';
          del.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(!confirm('Delete this sheet? This cannot be undone.')) return; deleteSheetById(sheet.id); });
          thumb.appendChild(del);
          thumb.addEventListener('click', ()=>{ saveActiveSheet(); activeSheetId = sheet.id; sheetTextarea.value = sheet.content || ''; renderSheetsBar(); });
          sheetsBar.insertBefore(thumb, addSheetBtn);
        });
      }
      function saveActiveSheet(){ const s = sheets.find(s=>s.id===activeSheetId); if(s) s.content = sheetTextarea.value; }
      function deleteSheetById(id){ const idx = sheets.findIndex(s=> s.id === id); if(idx === -1) return; sheets.splice(idx,1); // reassign ids
        sheets = sheets.map((s,i)=> ({id:i, content: s.content}));
        // adjust activeSheetId
        if(sheets.length===0){ addNewSheet(''); return; }
        activeSheetId = Math.min(activeSheetId, sheets.length-1);
        sheetTextarea.value = sheets[activeSheetId].content || '';
        renderSheetsBar();
      }

      addSheetBtn.addEventListener('click', ()=> addNewSheet(''));

      // Delete active sheet button
      deleteSheetBtn.addEventListener('click', ()=>{
        if(!confirm('Delete the active sheet? This cannot be undone.')) return;
        deleteSheetById(activeSheetId);
      });

      // initialize: load existing when editing
      if(isEdit){
        if(editType==='story'){
          const obj = storiesData[opts.index] || {sheets:[]};
          sheets = (obj.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
        } else if(editType==='serial'){
          const ser = serialsData[opts.index] || {episodes:[]};
          if(opts.episodeIndex!=null){
            const ep = (ser.episodes||[])[opts.episodeIndex] || {sheets:[]};
            sheets = (ep.sheets||[]).map((s,i)=>({id:i,content:s.content||s})); activeSheetId=0; renderSheetsBar(); sheetTextarea.value = sheets[0] ? sheets[0].content : '';
          } else {
            sheets = []; addNewSheet('');
          }
        }
      } else {
        // new story or new episode
        addNewSheet('');
      }

      publishStoryBtn.addEventListener('click', ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Public', cover: window._currentStoryCover || '' };
          // --- Attach tags (merge pending tags if present) ---
          try{
            const titleKey = title ? title.trim() : '';
            const pending = (window._pendingTags && Array.isArray(window._pendingTags[titleKey])) ? window._pendingTags[titleKey] : [];
            const existing = Array.isArray(payload.tags) ? payload.tags : [];
            payload.tags = Array.from(new Set([...(existing||[]), ...(pending||[])]));
          }catch(e){ console.warn('tag merge failed', e); }
;
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        // serial path
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Public' });
            serialsData[opts.index] = ser;
          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      saveDraftBtnLocal.addEventListener('click', ()=>{
        saveActiveSheet(); const payloadSheets = sheets.map(s=>({content: s.content || ''}));
        if(editType === 'story'){
          const payload = { title: title, genre: genre, description: desc, sheets: payloadSheets, status: 'Draft', cover: window._currentStoryCover || '' };
          if(isEdit){ storiesData[opts.index] = Object.assign({}, storiesData[opts.index], payload); }
          else { storiesData.push(payload); }
          editorDiv.remove(); showDashboard('stories');
          return;
        }
        if(editType === 'serial'){
          const ser = serialsData[opts.index]; if(!ser){ alert('Serial not found'); return; }
          if(isEdit && opts.episodeIndex!=null){
            ser.episodes[opts.episodeIndex] = Object.assign({}, ser.episodes[opts.episodeIndex], { title: title, description: desc, sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
          } else if(isNewEpisode){
            ser.episodes = ser.episodes || [];
            ser.episodes.push({ title: title || 'Episode', description: desc || '', sheets: payloadSheets, status: 'Draft' });
            serialsData[opts.index] = ser;
          } else {
            serialsData[opts.index] = Object.assign({}, ser, { title: title, genre: genre, description: desc });
          }
          const slot = serialSlots.find(s=> s.name === ser.title);
          if(slot) slot.episodes = ser.episodes.slice();
          editorDiv.remove(); showDashboard('serials');
          return;
        }
      });

      closeEditorBtn.addEventListener('click', ()=>{ if(confirm('Close editor? Unsaved changes will be lost.')) editorDiv.remove(); });
    }

    // ---------- Dashboard ----------
      function showDashboard(type='stories', genreFilter='All'){
      welcomePage.classList.add('hidden'); profileFormPage.classList.add('hidden'); storyFormPage.classList.add('hidden'); slidesPage.classList.add('hidden'); dashboardPage.classList.remove('hidden'); dashboardBackBtn.classList.remove('hidden');
      dashboardList.innerHTML='';
      updateHeaderVisibility();
      if(type==='stories'){
        const published = storiesData.filter(s=>s.status==='Public');
        const drafts = storiesData.filter(s=>s.status!=='Public');
        const ordered = [...published, ...drafts];
        // apply genre filter if requested
        const filtered = (genreFilter && genreFilter !== 'All') ? ordered.filter(s=> (s.genre||'').toLowerCase() === genreFilter.toLowerCase()) : ordered;
        const finalList = filtered;
        finalList.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">Genre: ${s.genre || '—'}</div>
                            <p class="desc">${s.description || ''}</p>
                            <p>Status: <span class="${s.status==='Public'?'status-public':'status-draft'}">${s.status}</span></p></div>`;
          const actions = document.createElement('div'); actions.className='card-actions';
          const editBtn = document.createElement('button');
editBtn.className = 'small-btn btn btn-secondary';
editBtn.textContent = s.status === 'Public' ? 'Update' : 'Edit';
editBtn.addEventListener('click', () => {
  createEditorPage(s.title, s.genre, s.description, {
    isEdit: true,
    editType: 'story',
    index: storiesData.indexOf(s)
  });
});
actions.appendChild(editBtn);

// Add Analytics button only for published stories
if (s.status === 'Public') {
  const analyticsBtn = document.createElement('button');
  analyticsBtn.className = 'small-btn btn btn-primary';
  analyticsBtn.textContent = 'Analytics';
  analyticsBtn.addEventListener('click', () => {
    showStoryAnalytics(s);
  });
  actions.appendChild(analyticsBtn);
}


          card.appendChild(left); card.appendChild(actions); dashboardList.appendChild(card);
        });
      } else {
        const ordered = [...serialsData];
        ordered.forEach((s, idx)=>{
          const card = document.createElement('div'); card.className='dashboard-card';
          const left = document.createElement('div'); left.className='left';
          left.innerHTML = `<div style="max-width:65%"><h3>${s.title}</h3>
                            <div class="meta">${s.genre || '—'} ${s.description? ('• ' + s.description) : ''}</div>
                            <p class="desc">Episodes: ${(s.episodes||[]).length}</p></div>`;
const actions = document.createElement('div');
actions.className = 'card-actions';

// --- Edit Episodes button ---
const editEpisodesBtn = document.createElement('button');
editEpisodesBtn.className = 'small-btn btn btn-secondary';
editEpisodesBtn.textContent = 'Edit Episodes';
editEpisodesBtn.addEventListener('click', () => {
  showSerialEpisodesEditor(serialsData.indexOf(s));
});

const addEpisodeBtn = document.createElement('button');
addEpisodeBtn.className = 'small-btn btn btn-primary';
addEpisodeBtn.textContent = 'Add Episode';

addEpisodeBtn.addEventListener('click', () => {
  addEpisodeSerialIndex = serialsData.indexOf(s);
  addEpTitleInput.value = '';
  addEpDescInput.value = '';
  addEpisodePopup.classList.remove('hidden');
});
const AnalyticBtn = document.createElement('button');
AnalyticBtn.className = 'small-btn btn btn-primary';
AnalyticBtn.textContent = 'Analytics';

AnalyticBtn.addEventListener('click', () => {
    // Get index of the current serial
    const serialIndex = serialsData.indexOf(s);

    // Call a function to show Serial Analytics
    showSerialAnalytics(s, serialIndex);
});



actions.appendChild(editEpisodesBtn);
actions.appendChild(addEpisodeBtn);
actions.appendChild(AnalyticBtn);
card.appendChild(left);
card.appendChild(actions);

dashboardList.appendChild(card);
});
}
}






// ---------- Reader Like/Dislike handlers (persisted in localStorage) ----------
function initReaderLikeButtons(){
  const likeBtn = document.getElementById('readerLikeBtn');
  const dislikeBtn = document.getElementById('readerDislikeBtn');
  const likeCountEl = document.getElementById('readerLikeCount');
  const dislikeCountEl = document.getElementById('readerDislikeCount');
  if(!likeBtn || !dislikeBtn) return;

  // keying based on readerTitle and (if present) episode marker in readerMeta.
  function getKey(){
    const title = (document.getElementById('readerTitle') && document.getElementById('readerTitle').textContent) || 'untitled';
    const meta = (document.getElementById('readerMeta') && document.getElementById('readerMeta').textContent) || '';
    // Try to detect "Episode X" in meta; if present, include it in key
    const epMatch = meta.match(/Episode\s*(\d+)/i);
    const key = epMatch ? `${title}::episode${epMatch[1]}` : title;
    return key;
  }

  function loadCounts(){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    const data = store[key] || {likes:0, dislikes:0};
    likeCountEl.textContent = data.likes || 0;
    dislikeCountEl.textContent = data.dislikes || 0;
  }

  function saveVote(deltaLike, deltaDislike){
    const store = JSON.parse(localStorage.getItem('global_votes_v1') || '{}');
    const key = getKey();
    store[key] = store[key] || {likes:0, dislikes:0};
    store[key].likes = (store[key].likes || 0) + (deltaLike||0);
    store[key].dislikes = (store[key].dislikes || 0) + (deltaDislike||0);
    localStorage.setItem('global_votes_v1', JSON.stringify(store));
    loadCounts();
  }

  likeBtn.addEventListener('click', ()=> saveVote(1,0));
  dislikeBtn.addEventListener('click', ()=> saveVote(0,1));

  // observe title/meta changes to update counts when reader opens different items
  const titleNode = document.getElementById('readerTitle');
  const metaNode = document.getElementById('readerMeta');
  const obs = new MutationObserver(()=> loadCounts());
  if(titleNode) obs.observe(titleNode, {childList:true, characterData:true, subtree:true});
  if(metaNode) obs.observe(metaNode, {childList:true, characterData:true, subtree:true});

  // initial load
  setTimeout(loadCounts, 120);
}
document.addEventListener('DOMContentLoaded', initReaderLikeButtons);
function showStoryAnalytics(s) {
  // Remove existing analytics page
  const existing = document.getElementById("analyticsPage");
  if (existing) existing.remove();

  // Main container
  const page = document.createElement("div");
  page.id = "analyticsPage";
  Object.assign(page.style, {
    position: "fixed",
    inset: "0",
    background: "#f9fafb",
    color: "#111",
    zIndex: 9999,
    overflowY: "auto",
    padding: "40px 20px",
    fontFamily: "Poppins, system-ui, sans-serif",
  });

  // Back button
  const backBtn = document.createElement("button");
  backBtn.textContent = "← Back";
  Object.assign(backBtn.style, {
    position: "fixed",
    top: "20px",
    left: "20px",
    padding: "10px 18px",
    background: "#fff",
    border: "1px solid #ddd",
    borderRadius: "12px",
    fontWeight: "600",
    cursor: "pointer",
    boxShadow: "0 4px 14px rgba(0,0,0,0.08)",
  });
  backBtn.addEventListener("click", () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement("h2");
  title.textContent = `${s.title || "Story"} Analytics`;
  Object.assign(title.style, { textAlign: "center", fontSize: "30px", marginBottom: "18px", fontWeight: "800" });
  page.appendChild(title);

  // Top stats cards
  const globalVotes = JSON.parse(localStorage.getItem("global_votes_v1") || "{}");
  const votes = globalVotes[s.title] || { likes: 0, dislikes: 0 };
  const reads = Number(s.reads || 0);

  let statusText = "ON GOING", statusColor = "#3b82f6";
  if (reads <= 10) { statusText = "ON GOING"; statusColor = "#3b82f6"; }
  else if (reads <= 40) { statusText = "REACHING WELL"; statusColor = "#10b981"; }
  else if (reads <= 75) { statusText = "TRENDING"; statusColor = "#f59e0b"; }
  else { statusText = "POPULAR"; statusColor = "#ef4444"; }

  const statsWrap = document.createElement("div");
  Object.assign(statsWrap.style, {
    display: "flex",
    justifyContent: "space-between",
    gap: "20px",
    marginBottom: "22px",
    maxWidth: "1000px",
    marginLeft: "auto",
    marginRight: "auto",
  });

  const makeBox = (label, value, color) => {
    const box = document.createElement("div");
    Object.assign(box.style, {
      flex: "1",
      background: "#fff",
      borderRadius: "16px",
      padding: "18px",
      boxShadow: "0 6px 20px rgba(0,0,0,0.06)",
      fontWeight: "700",
      textAlign: "center",
      transition: "transform 0.15s",
    });
    box.addEventListener("mouseover", ()=> box.style.transform="translateY(-2px)");
    box.addEventListener("mouseout", ()=> box.style.transform="translateY(0)");
    box.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div>
                     <div style="font-size:24px;color:${color || "#111"}">${value}</div>`;
    return box;
  };

  statsWrap.appendChild(makeBox("👁️ Reads", reads, "#3b82f6"));
  statsWrap.appendChild(makeBox("👍 Likes", votes.likes || 0, "#10b981"));
  statsWrap.appendChild(makeBox("📊 Status", statusText, statusColor));
  page.appendChild(statsWrap);

  // --- Chart area (replaces history) ---

  // Helpers
  const getDateKey = (d) => {
    const dt = new Date(d);
    const y = dt.getFullYear();
    const m = String(dt.getMonth() + 1).padStart(2, "0");
    const day = String(dt.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  };

  // Try to build timeseries from several sources:
  // 1) If story has a history array like [{date:'2025-10-16', reads:10, likes:2}, ...] use that
  // 2) Otherwise, use snapshot store in localStorage ('story_daily_snapshots_v1') keyed by story title
  // 3) Always add current snapshot (today) with current reads/likes so chart is up-to-date.

  const snapshotStoreKey = "story_daily_snapshots_v1";
  const store = JSON.parse(localStorage.getItem(snapshotStoreKey) || "{}");

  // If s.history exists and looks usable, normalize it
  let series = {};
  if (Array.isArray(s.history) && s.history.length > 0) {
    s.history.forEach(h => {
      // Expect h to have date (or publishedAt) and reads/likes
      const dateKey = getDateKey(h.date || h.publishedAt || h.day || new Date());
      series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
      series[dateKey].reads = Math.max(series[dateKey].reads, Number(h.reads || h.r || 0));
      series[dateKey].likes = Math.max(series[dateKey].likes, Number(h.likes || h.l || 0));
    });
  }

  // Merge snapshots from store (for this story)
  const storyKey = s.title || (s.id ? `id_${s.id}` : "untitled");
  const storedForStory = store[storyKey] || {};
  Object.keys(storedForStory).forEach(dateKey => {
    series[dateKey] = series[dateKey] || { reads: 0, likes: 0 };
    // stored snapshot expected shape: { reads: N, likes: M }
    series[dateKey].reads = Math.max(series[dateKey].reads, Number(storedForStory[dateKey].reads || 0));
    series[dateKey].likes = Math.max(series[dateKey].likes, Number(storedForStory[dateKey].likes || 0));
  });

  // Add today's snapshot (so chart shows current)
  const todayKey = getDateKey(new Date());
  series[todayKey] = series[todayKey] || { reads: 0, likes: 0 };
  series[todayKey].reads = Math.max(series[todayKey].reads, reads);
  series[todayKey].likes = Math.max(series[todayKey].likes, votes.likes || 0);

  // Persist today's snapshot into localStorage for future charts
  store[storyKey] = store[storyKey] || {};
  store[storyKey][todayKey] = {
    reads: series[todayKey].reads,
    likes: series[todayKey].likes,
    ts: Date.now()
  };
  localStorage.setItem(snapshotStoreKey, JSON.stringify(store));

  // Build sorted dataPoints
  const dateKeys = Object.keys(series).sort((a,b) => new Date(a) - new Date(b));
  // If nothing meaningful, show a friendly message
  if (dateKeys.length === 0) {
    const noData = document.createElement("div");
    noData.textContent = "No analytics data yet — publish and come back after some reads.";
    Object.assign(noData.style, { textAlign: "center", marginTop: "40px", color: "#6b7280" });
    page.appendChild(noData);
    document.body.appendChild(page);
    return;
  }

  const dataPoints = dateKeys.map(dk => ({ date: dk, reads: Number(series[dk].reads || 0), likes: Number(series[dk].likes || 0) }));

  // Chart container
  const chartWrap = document.createElement("div");
  Object.assign(chartWrap.style, {
    maxWidth: "1000px",
    margin: "0 auto 60px",
    background: "#fff",
    padding: "20px",
    borderRadius: "14px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)"
  });

  // Legend and controls
  const legend = document.createElement("div");
  legend.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px;">
      <div style="display:flex;gap:12px;align-items:center;">
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#3b82f6"></div><div style="font-size:13px;color:#374151">Reads</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="width:12px;height:12px;border-radius:2px;background:#10b981"></div><div style="font-size:13px;color:#374151">Likes</div>
        </div>
      </div>
      <div style="font-size:13px;color:#6b7280">Grouped by date</div>
    </div>
  `;
  chartWrap.appendChild(legend);

  // Build SVG chart
  const svgWidth = Math.min(960, Math.max(600, dataPoints.length * 70));
  const svgHeight = 300;
  const padding = { top: 20, right: 20, bottom: 60, left: 48 };
  const innerW = svgWidth - padding.left - padding.right;
  const innerH = svgHeight - padding.top - padding.bottom;

  // Compute max value to scale bars
  const maxVal = Math.max(...dataPoints.flatMap(d => [d.reads, d.likes]), 1);
  // nice round max
  const niceMax = (() => {
    const exp = Math.floor(Math.log10(maxVal));
    const base = Math.pow(10, exp);
    return Math.ceil(maxVal / base) * base;
  })();

  // Create SVG element
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, "svg");
  svg.setAttribute("width", svgWidth);
  svg.setAttribute("height", svgHeight);
  svg.style.display = "block";
  svg.style.margin = "0 auto";

  // Axes group
  const g = document.createElementNS(svgNS, "g");
  g.setAttribute("transform", `translate(${padding.left},${padding.top})`);
  svg.appendChild(g);

  // Y grid lines and labels
  const ticks = 4;
  for (let i = 0; i <= ticks; i++) {
    const y = innerH - (i / ticks) * innerH;
    const val = Math.round((i / ticks) * niceMax);
    const line = document.createElementNS(svgNS, "line");
    line.setAttribute("x1", 0);
    line.setAttribute("y1", y);
    line.setAttribute("x2", innerW);
    line.setAttribute("y2", y);
    line.setAttribute("stroke", "#e6e9ee");
    line.setAttribute("stroke-width", "1");
    g.appendChild(line);

    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", -10);
    label.setAttribute("y", y + 4);
    label.setAttribute("text-anchor", "end");
    label.setAttribute("font-size", "11");
    label.setAttribute("fill", "#6b7280");
    label.textContent = val;
    g.appendChild(label);
  }

  // Bars: grouped per date (reads + likes)
  const groupGap = 14;
  const groupWidth = innerW / dataPoints.length;
  const barWidth = Math.min(24, (groupWidth - groupGap) / 2);

  // Tooltip element (HTML overlay)
  const tooltip = document.createElement("div");
  Object.assign(tooltip.style, {
    position: "fixed",
    padding: "8px 10px",
    background: "#111",
    color: "#fff",
    fontSize: "12px",
    borderRadius: "6px",
    pointerEvents: "none",
    opacity: 0,
    transition: "opacity 0.12s",
    zIndex: 10000
  });
  document.body.appendChild(tooltip);

  dataPoints.forEach((d, i) => {
    const groupX = i * groupWidth + groupWidth / 2 - (barWidth + 6) / 2 - 6; // center groups

    // Reads bar (left)
    const readsH = (d.reads / niceMax) * innerH;
    const readsRect = document.createElementNS(svgNS, "rect");
    readsRect.setAttribute("x", groupX);
    readsRect.setAttribute("y", innerH - readsH);
    readsRect.setAttribute("width", barWidth);
    readsRect.setAttribute("height", Math.max(1, readsH));
    readsRect.setAttribute("fill", "#3b82f6");
    readsRect.style.cursor = "pointer";
    g.appendChild(readsRect);

    // Likes bar (right)
    const likesH = (d.likes / niceMax) * innerH;
    const likesRect = document.createElementNS(svgNS, "rect");
    likesRect.setAttribute("x", groupX + barWidth + 6);
    likesRect.setAttribute("y", innerH - likesH);
    likesRect.setAttribute("width", barWidth);
    likesRect.setAttribute("height", Math.max(1, likesH));
    likesRect.setAttribute("fill", "#10b981");
    likesRect.style.cursor = "pointer";
    g.appendChild(likesRect);

    // X label (date)
    const lbl = document.createElementNS(svgNS, "text");
    lbl.setAttribute("x", i * groupWidth + groupWidth / 2);
    lbl.setAttribute("y", innerH + 18);
    lbl.setAttribute("text-anchor", "middle");
    lbl.setAttribute("font-size", "11");
    lbl.setAttribute("fill", "#374151");
    lbl.textContent = d.date.slice(5); // show MM-DD for compactness
    g.appendChild(lbl);

    // Hover events for reads
    const attachHover = (elem, type) => {
      elem.addEventListener("mousemove", (ev) => {
        tooltip.style.left = (ev.pageX + 12) + "px";
        tooltip.style.top = (ev.pageY + 12) + "px";
        tooltip.innerHTML = `<strong style="display:block">${type}</strong><div style="font-size:13px">${d[type.toLowerCase()]}</div><div style="font-size:11px;color:#cbd5e1">${d.date}</div>`;
        tooltip.style.opacity = "1";
      });
      elem.addEventListener("mouseleave", () => tooltip.style.opacity = "0");
    };
    attachHover(readsRect, "Reads");
    attachHover(likesRect, "Likes");
  });

  // Y-axis label
  const yAxisLabel = document.createElementNS(svgNS, "text");
  yAxisLabel.setAttribute("x", -padding.left + 6);
  yAxisLabel.setAttribute("y", -6);
  yAxisLabel.setAttribute("font-size", "12");
  yAxisLabel.setAttribute("fill", "#6b7280");
  yAxisLabel.textContent = "Count";
  g.appendChild(yAxisLabel);

  chartWrap.appendChild(svg);

  // Small footnote and export CSV
  const footer = document.createElement("div");
  footer.style.display = "flex";
  footer.style.justifyContent = "space-between";
  footer.style.alignItems = "center";
  footer.style.marginTop = "12px";

  const note = document.createElement("div");
note.style.color = "#6b7280";
note.style.fontSize = "13px";
note.textContent = "Data shown per date (reads vs likes).";

const exportBtn = document.createElement("button");
exportBtn.textContent = "";
Object.assign(exportBtn.style, {
  display: "none", // ✅ this hides the button completely
  fontSize: "13px"
});

footer.appendChild(note);
// exportBtn is hidden but harmless
footer.appendChild(exportBtn);

  exportBtn.addEventListener("click", () => {
    // Build CSV
    const rows = [["date","reads","likes"], ...dataPoints.map(d => [d.date, d.reads, d.likes])];
    const csv = rows.map(r => r.join(",")).join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${(s.title || "story").replace(/\s+/g,'_')}_analytics.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  footer.appendChild(note);
  footer.appendChild(exportBtn);
  chartWrap.appendChild(footer);

  page.appendChild(chartWrap);

  // Basic story meta card
  const storyCard = document.createElement("div");
  Object.assign(storyCard.style, {
    background: "#fff",
    padding: "14px",
    borderRadius: "12px",
    boxShadow: "0 6px 20px rgba(0,0,0,0.04)",
    maxWidth: "1000px",
    margin: "0 auto 40px",
  });

  const createdAt = new Date(s.publishedAt || s.published || s.publishDate || Date.now());
  const getCharCount = (story) => {
    if (story.content) return story.content.length;
    if (story.body) return story.body.length;
    if (story.text) return story.text.length;
    if (story.serial && Array.isArray(story.serial)) {
      return story.serial.reduce((sum, part) => sum + (part.text?.length || 0), 0);
    }
    return 0;
  };
  const charCount = getCharCount(s);

  storyCard.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
    <div>
      <div style="font-size:16px;font-weight:600;color:#111">${s.title || "Untitled Story"}</div>
      <div style="font-size:13px;color:#6b7280;margin-top:4px">Created: ${createdAt.toLocaleString()}</div>
    <div style="text-align:right">
      <div style="font-size:13px;color:#6b7280">Total reads</div>
      <div style="font-size:20px;font-weight:700;color:#3b82f6">${reads}</div>
    </div>
  </div>`;

  page.appendChild(storyCard);

  document.body.appendChild(page);
}


function showSerialAnalytics(serialOrTitle) {
  const VOTES_STORE_KEY = 'global_votes_v1';
  const SNAPSHOT_KEY = 'story_daily_snapshots_v1';
  const READS_KEY = 'serial_reads_v1'; // 🆕 added

  // Safe loader
  function loadSaved() {
    try {
      return typeof loadSavedSerials === 'function'
        ? loadSavedSerials()
        : JSON.parse(localStorage.getItem('saved_serials_v1') || '[]');
    } catch (e) {
      return (serialsData || []).slice();
    }
  }

  const serial =
    typeof serialOrTitle === 'string'
      ? (loadSaved().find(s => s.title === serialOrTitle) ||
         (serialsData || []).find(s => s.title === serialOrTitle))
      : serialOrTitle;

  if (!serial) {
    alert('Serial not found');
    return;
  }

  // Remove old analytics
  const existing = document.getElementById('serialAnalyticsPage');
  if (existing) existing.remove();

  // Main page
  const page = document.createElement('div');
  page.id = 'serialAnalyticsPage';
  Object.assign(page.style, {
    position: 'fixed',
    inset: 0,
    background: '#f9fafb',
    color: '#111',
    zIndex: 9999,
    overflowY: 'auto',
    padding: '36px 20px',
    boxSizing: 'border-box',
    fontFamily: 'Poppins, system-ui, sans-serif'
  });

  // Back button
  const backBtn = document.createElement('button');
  backBtn.textContent = '← Back';
  Object.assign(backBtn.style, {
    position: 'fixed',
    top: '20px',
    left: '20px',
    padding: '10px 18px',
    background: '#fff',
    border: '1px solid #ddd',
    borderRadius: '12px',
    fontWeight: 600,
    cursor: 'pointer',
    boxShadow: '0 4px 14px rgba(0,0,0,0.08)'
  });
  backBtn.addEventListener('click', () => page.remove());
  page.appendChild(backBtn);

  // Title
  const title = document.createElement('h2');
  title.textContent = `${serial.title || 'Untitled Serial'} Analytics`;
  Object.assign(title.style, {
    textAlign: 'center',
    fontSize: '28px',
    margin: '8px 0 20px',
    fontWeight: 800
  });
  page.appendChild(title);

  // Votes
  const votesStore = JSON.parse(localStorage.getItem(VOTES_STORE_KEY) || '{}');
  const voteKey = `serial::${serial.title || 'untitled'}`;
  const votes = votesStore[voteKey] || { likes: Number(serial.likes || 0), dislikes: Number(serial.dislikes || 0) };

  // 🆕 Load reads from the read tracking store
  const readsStore = JSON.parse(localStorage.getItem(READS_KEY) || '{}');
  const readKey = `serial::${serial.title || 'untitled'}`;
  const readData = readsStore[readKey] || { total: 0, episodes: {} };

  const totalReads = Number(readData.total || 0);
  const episodeCount = Array.isArray(serial.episodes) ? serial.episodes.length : 0;

  // --- Top Stats ---
  const statsWrap = document.createElement('div');
  Object.assign(statsWrap.style, {
    display: 'flex',
    gap: '18px',
    justifyContent: 'space-between',
    maxWidth: '980px',
    margin: '0 auto 18px',
    flexWrap: 'wrap'
  });

  const makeBox = (label, value, color) => {
    const b = document.createElement('div');
    Object.assign(b.style, {
      flex: '1',
      minWidth: '180px',
      background: '#fff',
      borderRadius: '12px',
      padding: '14px',
      boxShadow: '0 8px 28px rgba(0,0,0,0.06)',
      textAlign: 'center',
      fontWeight: 700
    });
    b.innerHTML = `<div style="font-size:13px;color:#6b7280">${label}</div><div style="font-size:22px;color:${color ||
      '#111'}">${value}</div>`;
    return b;
  };

  statsWrap.appendChild(makeBox('Episodes', episodeCount, '#7c3aed'));
  statsWrap.appendChild(makeBox('Total Reads', totalReads, '#3b82f6'));
  statsWrap.appendChild(makeBox('👍 Likes', votes.likes || 0, '#10b981'));
  page.appendChild(statsWrap);

  // --- Per Episode Reads Table ---
  if (episodeCount > 0) {
    const table = document.createElement('table');
    Object.assign(table.style, {
      width: '100%',
      maxWidth: '980px',
      margin: '0 auto 30px',
      borderCollapse: 'collapse',
      background: '#fff',
      borderRadius: '12px',
      overflow: 'hidden',
      boxShadow: '0 8px 28px rgba(0,0,0,0.04)'
    });

    table.innerHTML = `
      <thead style="background:#f3f4f6">
        <tr>
          <th style="text-align:left;padding:10px 14px;font-size:14px;">Episode</th>
          <th style="text-align:center;padding:10px 14px;font-size:14px;">Reads</th>
        </tr>
      </thead>
      <tbody>
        ${serial.episodes
          .map((ep, i) => {
            const r = readData.episodes && readData.episodes[i] ? readData.episodes[i] : 0;
            return `<tr>
              <td style="padding:8px 14px;border-top:1px solid #eee;">${i + 1}. ${ep.title || 'Untitled'}</td>
              <td style="padding:8px 14px;border-top:1px solid #eee;text-align:center;color:#3b82f6;font-weight:600">${r}</td>
            </tr>`;
          })
          .join('')}
      </tbody>
    `;
    page.appendChild(table);
  }

  // --- Chart (reads vs likes per day) ---
  // (same as before, unchanged for brevity)
  // you can keep your existing chart + CSV export code here

  document.body.appendChild(page);
}


  
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); });

    function showSerialOptions(slot){
      const modal = document.createElement('div'); modal.className='popup';
      modal.innerHTML = `<div class="popup-content"><h3>${slot.name} — Serial Options</h3>
                         <div style="display:flex;flex-direction:column;gap:8px;margin-top:12px;text-align:left">
                           <button id="manageEpsBtn" class="btn btn-secondary">Manage Episodes</button>
                           <button id="addEpBtn" class="btn btn-primary">Add Episode</button>
                           <button id="openCreateBtn" class="btn btn-primary">Open Serial Form</button>
                           <button id="closeSlotOpts" class="btn btn-secondary" style="margin-top:8px">Close</button>
                         </div></div>`;
      document.body.appendChild(modal);
      modal.querySelector('#manageEpsBtn').addEventListener('click', ()=>{ modal.remove(); showSerialEpisodesEditor(serialSlots.indexOf(slot)); });
      modal.querySelector('#addEpBtn').addEventListener('click', ()=>{ modal.remove();
        const ser = serialsData.find(s=> s.title === slot.name);
        if(!ser){ const newSer = { title: slot.name, genre: '', description: '', episodes: slot.episodes ? slot.episodes.slice() : [] }; serialsData.push(newSer); }
        const serIndex = serialsData.findIndex(s=> s.title === slot.name);
        addEpisodeSerialIndex = serIndex; addEpTitleInput.value = ''; addEpDescInput.value = ''; addEpisodePopup.classList.remove('hidden');
      });
      modal.querySelector('#openCreateBtn').addEventListener('click', ()=>{ modal.remove();
        serialCreatePopup.dataset.slotIndex = serialSlots.indexOf(slot);
        const existing = serialsData.find(s=> s.title === slot.name);
        if(existing){ seriesTitleInput.value = existing.title || slot.name || ''; seriesGenreInput.value = existing.genre || ''; seriesDescInput.value = existing.description || ''; }
        else { seriesTitleInput.value = slot.name || ''; seriesGenreInput.value = ''; seriesDescInput.value = ''; }
        ep1TitleInput.value = ''; ep1DescInput.value = '';
        serialCreatePopup.classList.remove('hidden');
      });
      modal.querySelector('#closeSlotOpts').addEventListener('click', ()=> modal.remove());
    }

    function showSerialEpisodesEditor(serialIndex){
      const ser = serialsData[serialIndex]; if(!ser) { alert('Serial not found'); return; }
      const modal = document.createElement('div'); modal.className='popup'; modal.innerHTML = `<div class="popup-content"><h3>${ser.title} — Episodes</h3><div id="epsList" style="max-height:300px;overflow:auto;margin-top:10px"></div><div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px"><button id="closeEps" class="btn btn-secondary">Close</button></div></div>`;
      document.body.appendChild(modal);
      const epsList = modal.querySelector('#epsList'); const closeEps = modal.querySelector('#closeEps');
      (ser.episodes||[]).forEach((ep, i)=>{
        const row = document.createElement('div'); row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center'; row.style.padding='8px 0';
        row.innerHTML = `<div style="max-width:70%"><strong>${i+1}. ${ep.title}</strong><div style="font-size:13px;color:var(--muted)">${ep.description||''}</div><div style="font-size:12px;color:var(--muted)">Status: ${ep.status||'Draft'}</div></div>`;
        const buttons = document.createElement('div'); buttons.style.display='flex'; buttons.style.gap='8px';
        const editBtn = document.createElement('button'); editBtn.className='small-btn btn btn-secondary'; editBtn.textContent='Edit'; editBtn.addEventListener('click', ()=>{ modal.remove(); createEditorPage(ep.title, ser.genre, ep.description, {isEdit:true, editType:'serial', index: serialIndex, episodeIndex: i, isNewEpisode:false}); });
        buttons.appendChild(editBtn);
        row.appendChild(buttons); epsList.appendChild(row);
      });
      closeEps.addEventListener('click', ()=> modal.remove());
    }

    // ---------- Init ----------
    loadProfile();
    storySlots = [{id:0,unlocked:false,name:''}];
    serialSlots = [{id:0,unlocked:false,name:''}];
    updateHeaderVisibility();
  
    // ---------- Browse Stories rendering & Preview/Reader ----------
const STORY_ALGO_CONFIG = {
  popularityWeight: 0.5,      // lower to allow new creators
  recencyWeight: 0.25,        // same as before
  noveltyWeight: 0.25,        // gives less popular stories a chance
  randomWeight: 0.1,          // small exploration
  freshDaysBoost: 21,         // recent content boost
  freshBoostMultiplier: 1.4,  // stronger boost for fresh content
  explorationFraction: 0.25,
  cardsPerViewport: 6,

  // trending tuning
  trending: {
    addThreshold: 50,   // recentReads >= 50 -> add to trending
    keepThreshold: 100, // recentReads >= 100 -> definitely keep for that update
    dropThreshold: 40,  // trending -> remove if recentReads < 40
    expireDays: 7       // expire entries not updated in this many days
  },

  recentlyReadLimit: 50
};

// Session RNG (seeded per page load)
(function initStorySeed() {
  if (window.__STORY_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__STORY_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForStoryRender() {
  return mulberry32(window.__STORY_RENDER_SEED);
}

// Utilities
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000*60*60*24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng=Math.random) {
  for (let i = arr.length-1; i>0; i--) {
    const j = Math.floor((rng ? rng() : Math.random())*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computeStoryPopularity(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5*Math.log1p(likes); // log scale like ALGO_CONFIG
}

// ================= TRENDING & RECENT HELPERS (stories) =================
function getRecentReadsForStory(s) {
  const candidates = [
    s.recentReads,
    s.readsLast24h,
    s.readsToday,
    s.readsLastDay,
    s.dailyReads
  ];
  for (let c of candidates) if (Number.isFinite(c)) return Number(c);

  if (Number.isFinite(s.readCount) && Number.isFinite(s.prevReadCount)) {
    return Math.max(0, Number(s.readCount) - Number(s.prevReadCount));
  }
  return undefined;
}

function loadTrendingStoriesState() {
  try {
    const raw = localStorage.getItem('trending_stories_v1');
    return raw ? JSON.parse(raw) : { ids: {}, lastUpdated: Date.now() };
  } catch (e) {
    return { ids: {}, lastUpdated: Date.now() };
  }
}
function saveTrendingStoriesState(state) {
  try { localStorage.setItem('trending_stories_v1', JSON.stringify(state)); } catch (e) {}
}

function updateTrendingStateForStories(stories) {
  const state = loadTrendingStoriesState();
  const now = Date.now();
  const cfg = STORY_ALGO_CONFIG.trending;
  stories.forEach(s => {
    const id = s.id ?? s.slug ?? s.title;
    if (!id) return;
    const recent = getRecentReadsForStory(s);
    const currentlyTrending = !!state.ids[id];

    if (Number.isFinite(recent)) {
      if (recent >= cfg.keepThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (recent >= cfg.addThreshold) {
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (currentlyTrending && recent < cfg.dropThreshold) {
        delete state.ids[id];
      } else if (currentlyTrending) {
        state.ids[id] = { ...state.ids[id], lastSeen: now, recent };
      }
    } else {
      if (currentlyTrending) {
        const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
        const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
        if (cfg.expireDays && daysSinceSeen > cfg.expireDays) {
          delete state.ids[id];
        }
      }
    }
  });

  // prune entries not present if expired
  const presentIds = new Set(stories.map(s => s.id ?? s.slug ?? s.title));
  Object.keys(state.ids).forEach(id => {
    if (!presentIds.has(id)) {
      const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
      const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
      if (STORY_ALGO_CONFIG.trending.expireDays && daysSinceSeen > STORY_ALGO_CONFIG.trending.expireDays) {
        delete state.ids[id];
      }
    }
  });

  state.lastUpdated = now;
  saveTrendingStoriesState(state);
  return state;
}

function getTrendingStoriesFromState(stories, state) {
  const ids = new Set(Object.keys(state.ids || {}));
  return stories.filter(s => {
    const id = s.id ?? s.slug ?? s.title;
    return id && ids.has(id);
  });
}

// Recently read (stories)
function recordRecentlyReadStory(story) {
  try {
    const raw = localStorage.getItem('recently_read_stories_v1');
    let arr = raw ? JSON.parse(raw) : [];
    const id = story.id ?? story.slug ?? story.title;
    const entry = {
      id,
      title: story.title || 'Untitled',
      cover: story.cover || null,
      genre: story.genre || null,
      description: story.description || null,
      at: Date.now()
    };
    arr = arr.filter(x => x.id !== id);
    arr.unshift(entry);
    const limit = Number.isFinite(STORY_ALGO_CONFIG.recentlyReadLimit) ? STORY_ALGO_CONFIG.recentlyReadLimit : 50;
    if (arr.length > limit) arr = arr.slice(0, limit);
    localStorage.setItem('recently_read_stories_v1', JSON.stringify(arr));
  } catch (e) {}
}
function loadRecentlyReadStories() {
  try {
    const raw = localStorage.getItem('recently_read_stories_v1');
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}

function openStoryPreviewAndRecord(story) {
  try { recordRecentlyReadStory(story); } catch (e) {}
  if (typeof openPreviewFullScreen === 'function') {
    if (story.id) openPreviewFullScreen(story.id);
    else if (story.slug) openPreviewFullScreen(story.slug);
    else openPreviewFullScreen(story.title || '');
  } else {
    console.warn('openPreviewFullScreen not defined');
  }
}

// ================= SCORING =================
function scoredStories(stories, rng) {
  rng = rng || Math.random;

  const popArr = stories.map(computeStoryPopularity);
  const ageArr = stories.map(s => Math.max(0, 365 - Math.min(daysSince(s.published||s.createdAt||s.date||s.uploadedAt),365)));

  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return stories.map((s,i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];
    const novelty = Math.max(0.2, 1-pop); // ensure new stories get minimum chance
    const randomEps = (rng ? rng() : Math.random()) * STORY_ALGO_CONFIG.randomWeight;

    let score = STORY_ALGO_CONFIG.popularityWeight*pop
              + STORY_ALGO_CONFIG.recencyWeight*rec
              + STORY_ALGO_CONFIG.noveltyWeight*novelty
              + randomEps;

    const ageDays = daysSince(s.published||s.createdAt||s.date||s.uploadedAt);
    if (ageDays <= STORY_ALGO_CONFIG.freshDaysBoost) score *= STORY_ALGO_CONFIG.freshBoostMultiplier;

    return Object.assign({}, s, {
      __score: score,
      __popNorm: pop,
      __recNorm: rec,
      __novelty: novelty,
      __ageDays: ageDays
    });
  });
}

// ================= EXPLORATION =================
function pickStoryExploration(candidates, count, rng) {
  if (!candidates || candidates.length===0 || count<=0) return [];
  rng = rng || Math.random;

  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + (rng ? rng() : Math.random())*0.1 });
  });

  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// Demo stories generator (kept as-is)
function generateDemoStories(count=0,rng){rng=rng||rngForStoryRender(); 
  const genres=["Action","Romance","Comedy","Fantasy","Horror","Tragic","Thriller","Adventure","Crime","Historic"]; 
  const covers=[
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ]; 
  const stories=[]; 
  for(let i=0;i<count;i++){
    const genre=genres[Math.floor(rng()*genres.length)];
    const title=`${genre} Demo Story ${i+1}`;
    const readCount=Math.floor(rng()*1000);
    const likes=Math.floor(rng()*400);
    const daysAgo=Math.floor(rng()*400);
    const date=new Date(Date.now()-daysAgo*86400000).toISOString();
    stories.push({id:`demo-${i+1}`,title,genre,description:`Demo ${genre.toLowerCase()} story — random readCount ${readCount}.`,cover:covers[i%covers.length],readCount,reads:readCount,likes,createdAt:date});
  } 
  return stories;
}

// Main render function with Trending + Recently Read integrated
function renderBrowseStories(selectedCategory = 'All', opts = { includeDemo: true, demoCount: 30, mergeWithSaved: true }) {
  const rng = rngForStoryRender();

  try {
    const storiesListDiv = document.getElementById('storiesBrowseList');
    const cards = document.getElementById('storiesCards');
    if (!cards) return;

    // --- Preserve vertical scroll ---
    const oldScrollY = window.scrollY || document.documentElement.scrollTop;

    // Ensure main container is vertical and full-width
    cards.style.display = 'block';
    cards.style.width = '100%';
    cards.style.flexWrap = 'wrap';

    const publicStories = (storiesData || []).filter(s => s.status === 'Public');
    let filteredStories = selectedCategory !== 'All'
      ? publicStories.filter(s => (s.genre || '').toLowerCase() === selectedCategory.toLowerCase())
      : publicStories;

    const demoStories = opts.includeDemo ? generateDemoStories(opts.demoCount || 50, rng) : [];
    let allStories = opts.mergeWithSaved
      ? demoStories.concat(filteredStories)
      : (demoStories.length ? demoStories : filteredStories);

    if (allStories.length === 0) {
      storiesListDiv.style.display = 'none';
      return;
    } else {
      storiesListDiv.style.display = 'block';
    }

    // --- Preserve horizontal scroll per genre ---
    const oldScrollX = {};
    cards.querySelectorAll('div[data-genre]').forEach(sec => {
      const g = sec.dataset.genre;
      const sc = sec.querySelector('.scroll-wrap');
      if (sc) oldScrollX[g] = sc.scrollLeft;
    });

    const genresOrder = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Thriller","Adventure","Crime","Historic"];
    const grouped = {};
    allStories.forEach(s => {
      const g = s.genre ? s.genre.trim() : "Other";
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    // Update trending state BEFORE scoring
    const trendingState = updateTrendingStateForStories(allStories);

    const allScored = scoredStories(allStories, rng);
    const scoredMap = new Map();
    allScored.forEach(s => scoredMap.set(s.id ?? s.title, s));

    // --- Clear or create sections container ---
    cards.innerHTML = '';
    const imagesToWait = [];

    // --- TRENDING SECTION ---
    const trendingStories = getTrendingStoriesFromState(allScored, trendingState);
    if (trendingStories && trendingStories.length) {
      trendingStories.sort((a, b) => {
        const ida = a.id ?? a.slug ?? a.title;
        const idb = b.id ?? b.slug ?? b.title;
        const sa = (trendingState.ids[ida]?.recent || 0) + (a.__score || 0);
        const sb = (trendingState.ids[idb]?.recent || 0) + (b.__score || 0);
        return sb - sa;
      });

      const trendingSection = document.createElement('div');
      trendingSection.dataset.genre = 'Trending';
      trendingSection.style.display = 'block';
      trendingSection.style.marginBottom = '28px';
      cards.appendChild(trendingSection);

      const heading = document.createElement('h2');
      heading.textContent = '🔥 Trending';
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      trendingSection.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap trending-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';

      // wheel-to-scroll fix
      scrollWrap.addEventListener(
        'wheel',
        e => {
          if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
            scrollWrap.scrollLeft += e.deltaY;
            e.preventDefault();
          }
        },
        { passive: false }
      );

      trendingStories.forEach(s => {
        const card = createStoryCard(s, imagesToWait);
        scrollWrap.appendChild(card);
      });

      trendingSection.appendChild(scrollWrap);

      // restore previous horizontal scroll if any
      if (oldScrollX['Trending'] !== undefined) {
        const prevBehavior = scrollWrap.style.scrollBehavior;
        scrollWrap.style.scrollBehavior = 'auto';
        scrollWrap.scrollLeft = oldScrollX['Trending'];
        scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
      }
    }

    // --- GENRE SECTIONS ---
    genresOrder.forEach(genre => {
      const list = grouped[genre];
      if (!list || list.length === 0) return;

      const section = document.createElement('div');
      section.dataset.genre = genre;
      section.style.display = 'block';
      section.style.marginBottom = '32px';
      cards.appendChild(section);

      const heading = document.createElement('h3');
      heading.textContent = genre;
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      section.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';
      scrollWrap.style.flexWrap = 'nowrap';
      section.appendChild(scrollWrap);

      const scoredList = list.map(s => scoredMap.get(s.id ?? s.title) || Object.assign({}, s, { __score: rng() * 0.2 }));
      const sorted = scoredList.slice().sort((a, b) => b.__score - a.__score);

      const displayCount = Math.min(sorted.length, Math.max(STORY_ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length)));
      const explorationCount = Math.ceil(displayCount * STORY_ALGO_CONFIG.explorationFraction);
      const topCandidates = sorted.slice(0, Math.max(0, displayCount - explorationCount));
      const remaining = sorted.slice(displayCount - explorationCount);
      const explorationPool = remaining.concat(sorted.slice(displayCount));
      const explorationPicked = pickStoryExploration(explorationPool, explorationCount, rng);

      const finalList = [];
      const maxLen = Math.max(topCandidates.length, explorationPicked.length);
      for (let i = 0; i < maxLen; i++) {
        if (i < topCandidates.length) finalList.push(topCandidates[i]);
        if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
      }
      if (finalList.length === 0) finalList.push(...sorted.slice(0, displayCount));
      shuffleArray(finalList, rng);

      finalList.forEach(s => scrollWrap.appendChild(createStoryCard(s, imagesToWait)));

      // restore previous horizontal scroll if available
      if (oldScrollX[genre] !== undefined) {
        const prevBehavior = scrollWrap.style.scrollBehavior;
        scrollWrap.style.scrollBehavior = 'auto';
        scrollWrap.scrollLeft = oldScrollX[genre];
        scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
      }
    });

    // --- RECENTLY READ SECTION ---
    const recentArr = loadRecentlyReadStories();
    if (recentArr && recentArr.length) {
      const recentSection = document.createElement('div');
      recentSection.dataset.section = 'recently-read';
      recentSection.style.marginTop = '28px';
      recentSection.style.marginBottom = '36px';
      cards.appendChild(recentSection);

      const heading = document.createElement('h3');
      heading.textContent = '📚 Recently Read';
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      recentSection.appendChild(heading);

      const wrap = document.createElement('div');
      wrap.style.display = 'flex';
      wrap.style.overflowX = 'auto';
      wrap.style.gap = '12px';
      wrap.style.padding = '12px';
      wrap.style.scrollBehavior = 'smooth';
      recentSection.appendChild(wrap);

      recentArr.forEach(r => {
        const card = createRecentCard(r, allStories);
        wrap.appendChild(card);
      });
    }

    // --- Restore vertical scroll ---
    window.scrollTo({ top: oldScrollY, behavior: 'auto' });

    // Optional: await imagesToWait if needed
    // await Promise.all(imagesToWait);

  } catch (err) {
    console.warn(err);
  }
}

// ---------- Helper to create a story card ----------
function createStoryCard(s, imagesToWait) {
  const card = document.createElement('div');
  card.className = 'story-card';
  card.dataset.title = s.title || '';
  card.style.minWidth = '260px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '14px';
  card.style.padding = '14px';
  card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.cursor = 'pointer';
  card.style.position = 'relative';
  card.style.flexShrink = '0';
  card.style.backfaceVisibility = 'hidden';
  card.style.transition = 'box-shadow 0.25s ease-out';
  card.style.willChange = 'transform, box-shadow';

  if (s.cover) {
    const img = new Image();
    img.src = s.cover;
    imagesToWait.push(new Promise(resolve => { if (img.complete) return resolve(); img.onload = img.onerror = () => resolve(); }));
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${s.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  const titleEl = document.createElement('h4');
  titleEl.textContent = s.title || 'Untitled';
  titleEl.style.margin = '0 0 6px';
  titleEl.style.fontSize = '17px';
  titleEl.style.fontWeight = '700';
  titleEl.style.textShadow = s.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

  const genreEl = document.createElement('p');
  genreEl.textContent = s.genre || 'Unknown';
  genreEl.style.margin = '0 0 6px';
  genreEl.style.fontSize = '13px';
  genreEl.style.fontWeight = '600';
  genreEl.style.opacity = '0.9';
  genreEl.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

  const desc = document.createElement('p');
  desc.textContent = s.description || '';
  desc.style.margin = '4px 0 8px';
  desc.style.fontSize = '14px';
  desc.style.lineHeight = '1.4';
  desc.style.overflow = 'hidden';
  desc.style.display = '-webkit-box';
  desc.style.webkitLineClamp = '3';
  desc.style.webkitBoxOrient = 'vertical';
  desc.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

  const bottomRow = document.createElement('div');
  bottomRow.style.display = 'flex';
  bottomRow.style.justifyContent = 'space-between';
  bottomRow.style.alignItems = 'center';
  bottomRow.style.marginTop = 'auto';

  const reads = document.createElement('div');
  reads.textContent = '👁️ ' + (s.reads || s.readCount || 0);
  reads.style.fontSize = '13px';
  reads.style.fontWeight = '600';

  const readBtn = document.createElement('button');
  readBtn.className = 'btn btn-primary';
  readBtn.textContent = 'Read';
  readBtn.addEventListener('click', e => {
    e.stopPropagation();
    openStoryPreviewAndRecord(s);
  });

  bottomRow.appendChild(reads);
  bottomRow.appendChild(readBtn);

  card.appendChild(titleEl);
  card.appendChild(genreEl);
  card.appendChild(desc);
  card.appendChild(bottomRow);

  // hover / touch scaling
  card.addEventListener('mouseenter', () => { card.style.transform = 'scale(1.06)'; card.style.zIndex = 2; card.style.boxShadow = '0 12px 24px rgba(0,0,0,0.2)'; });
  card.addEventListener('mouseleave', () => { card.style.transform = 'scale(1)'; card.style.zIndex = 1; card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)'; });

  return card;
}

// ---------- Helper to create recently read card ----------
function createRecentCard(r, allStories) {
  const card = document.createElement('div');
  card.className = 'recent-card story-card';
  card.style.minWidth = '260px';
  card.style.flex = '0 0 auto';
  card.style.borderRadius = '14px';
  card.style.padding = '14px';
  card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
  card.style.display = 'flex';
  card.style.flexDirection = 'column';
  card.style.justifyContent = 'space-between';
  card.style.cursor = 'pointer';
  card.style.position = 'relative';
  card.style.flexShrink = '0';
  card.style.backfaceVisibility = 'hidden';

  if (r.cover) {
    card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${r.cover})`;
    card.style.backgroundSize = 'cover';
    card.style.backgroundPosition = 'center';
    card.style.color = '#fff';
  } else {
    card.style.background = '#fff';
    card.style.color = '#000';
  }

  const titleDiv = document.createElement('h4');
  titleDiv.textContent = r.title || 'Untitled';
  titleDiv.style.margin = '0 0 6px';
  titleDiv.style.fontSize = '17px';
  titleDiv.style.fontWeight = '700';
  titleDiv.style.textShadow = r.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

  const genreDiv = document.createElement('div');
  genreDiv.textContent = r.genre || 'Unknown';
  genreDiv.style.margin = '0 0 6px';
  genreDiv.style.fontSize = '13px';
  genreDiv.style.fontWeight = '600';
  genreDiv.style.opacity = '0.9';

  const descDiv = document.createElement('p');
  descDiv.textContent = r.description || '';
  descDiv.style.margin = '4px 0 8px';
  descDiv.style.fontSize = '14px';
  descDiv.style.lineHeight = '1.4';
  descDiv.style.overflow = 'hidden';
  descDiv.style.display = '-webkit-box';
  descDiv.style.webkitLineClamp = '3';
  descDiv.style.webkitBoxOrient = 'vertical';

  const bottomRow = document.createElement('div');
  bottomRow.style.display = 'flex';
  bottomRow.style.justifyContent = 'flex-end';
  bottomRow.style.alignItems = 'center';
  bottomRow.style.marginTop = 'auto';

  const readBtn = document.createElement('button');
  readBtn.className = 'btn btn-primary';
  readBtn.textContent = 'Read';
  readBtn.addEventListener('click', e => {
    e.stopPropagation();
    const found = allStories.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openStoryPreviewAndRecord(found);
    else if (typeof openPreviewFullScreen === 'function') openPreviewFullScreen(r.title);
    else console.warn('openPreviewFullScreen not defined');
  });

  bottomRow.appendChild(readBtn);

  card.appendChild(titleDiv);
  card.appendChild(genreDiv);
  card.appendChild(descDiv);
  card.appendChild(bottomRow);

  // click whole card to open too
  card.addEventListener('click', () => {
    const found = allStories.find(s => (s.id ?? s.slug ?? s.title) === r.id);
    if (found) openStoryPreviewAndRecord(found);
    else if (typeof openPreviewFullScreen === 'function') openPreviewFullScreen(r.title);
  });

  return card;
}

// --- Initial render ---
renderBrowseStories('All');
//render


    // open preview modal for a story object
    function openPreview(story){
      const modal = document.getElementById('previewModal');
      document.getElementById('previewTitle').textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      document.getElementById('previewMeta').textContent = `${story.genre || '—'} • Written by ${author} • Written on ${dateStr}`;
      document.getElementById('previewDesc').textContent = story.description || '';
      // pick random sentence(s) from sheets
      let snippet = '';
      try{
        const allText = (story.sheets||[]).map(sh => sh.content || '').join(' ');
        const sentences = allText.split(/(?<=[.!?])\s+/).filter(Boolean);
        for(let i=0;i<3 && i<sentences.length;i++){
          const r = Math.floor(Math.random()*sentences.length);
          snippet += (sentences[r] || '') + ' ';
        }
        snippet = snippet.trim().slice(0,300) + (snippet.length>300 ? '...' : '');
      }catch(e){ snippet = (story.sheets && story.sheets[0] && story.sheets[0].content.slice(0,200)) || ''; }
      document.getElementById('previewSnippet').textContent = snippet;
      modal.classList.remove('hidden');
      document.getElementById('previewCloseBtn').onclick = ()=> modal.classList.add('hidden');
      document.getElementById('startReadingBtn').onclick = ()=> { modal.classList.add('hidden'); openReader(story); };
    }

    // Reader
    let _currentReader = { story:null, sheetIndex:0 };
    function openReader(story){
      const modal = document.getElementById('readerModal');
      const titleEl = document.getElementById('readerTitle');
      const metaEl = document.getElementById('readerMeta');
      const sheetEl = document.getElementById('readerSheet');
      const pager = document.getElementById('readerPager');
      _currentReader.story = story;
      _currentReader.sheetIndex = 0;
      titleEl.textContent = story.title;
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      let author = '—';
      if(profileRaw){ try{ const p = JSON.parse(profileRaw); author = p.name || '—'; }catch(e){} }
      const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];
      metaEl.textContent = `${story.genre || '—'} • Written by ${author} • Published on ${dateStr}`;
      function renderSheet(){
        const sheets = story.sheets || [];
        const s = sheets[_currentReader.sheetIndex] || { content: '' };
        sheetEl.textContent = s.content || '';
        pager.textContent = `${_currentReader.sheetIndex+1} / ${Math.max(1,sheets.length)}`;
        document.getElementById('readerPrevBtn').disabled = _currentReader.sheetIndex===0;
        document.getElementById('readerNextBtn').disabled = _currentReader.sheetIndex >= sheets.length-1;
      }
      document.getElementById('readerPrevBtn').onclick = ()=> { if(_currentReader.sheetIndex>0) _currentReader.sheetIndex--; renderSheet(); };
      document.getElementById('readerNextBtn').onclick = ()=> { if((_currentReader.sheetIndex+1) < (story.sheets||[]).length) _currentReader.sheetIndex++; renderSheet(); };
      document.getElementById('readerCloseBtn').onclick = ()=> { modal.classList.add('hidden'); };
      document.getElementById('readerDownloadBtn').onclick = ()=> { downloadSingleStory(story); };
      // simple swipe support
      let startX = null;
      const readerContent = document.getElementById('readerContent');
      readerContent.ontouchstart = (e)=> { startX = e.touches[0].clientX; };
      readerContent.ontouchend = (e)=> {
        if(startX==null) return;
        const dx = e.changedTouches[0].clientX - startX;
        if(dx < -40){ // swipe left -> next
          if(_currentReader.sheetIndex < (story.sheets||[]).length-1) _currentReader.sheetIndex++;
        } else if(dx > 40){ // swipe right -> prev
          if(_currentReader.sheetIndex > 0) _currentReader.sheetIndex--;
        }
        renderSheet();
        startX = null;
      };
      modal.classList.remove('hidden');
      renderSheet();
    }

    // Download functions
    function downloadAllContent(){
      const data = { stories: storiesData, serials: serialsData, exportedOn: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'writer_content_export_'+(new Date().toISOString().slice(0,10))+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    function downloadSingleStory(story){
      const blob = new Blob([JSON.stringify(story, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = (story.title || 'story').replace(/[^\w\-]/g,'_') + '.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    // wire dashboard download button
    document.addEventListener('click', function(e){
      if(e.target && e.target.id === 'dashboardDownloadBtn') downloadAllContent();
    });

    // Ensure published stories show up in Browse after publish/save (hook used in createEditorPage)
    const originalPublishHook = null; // placeholder
    // We'll monkey-patch the place where storiesData is pushed: after publish or saveDraft in createEditorPage, renderBrowseStories is called.
    // To be safe, call renderBrowseStories periodically and when dashboard opens.
    setInterval(()=>{ renderBrowseStories(currentCategorySelection || 'All'); }, 1200);

    // hook categories selection to render browse list appropriately
    const cats = document.querySelectorAll('.cat-card');
    let currentCategorySelection = 'All';
    function attachCategoryClicks(){
      const grid = document.getElementById('categoriesGrid');
      if(!grid) return;
      grid.querySelectorAll('.cat-card').forEach(c=>{
        c.addEventListener('click', ()=>{
          const cat = c.querySelector('.cat-title').textContent || 'All'; currentCategorySelection = cat;
          renderBrowseStories(cat);
        });
      });
    }
    // attach on DOM ready
    window.addEventListener('DOMContentLoaded', ()=>{ setTimeout(attachCategoryClicks, 400); });

    // Fix profile header visibility when returning from dashboard - ensure profile button shown on welcome page
    dashboardBackBtn.addEventListener('click', ()=>{ dashboardPage.classList.add('hidden'); welcomePage.classList.remove('hidden'); dashboardBackBtn.classList.add('hidden'); profileBtn.style.display = 'inline-flex'; });

    // Also whenever showDashboard is called, ensure profile button hidden and dropdown closed
    const originalShowDashboard = showDashboard;
    showDashboard = function(type, genreFilter){ profileBtn.style.display = 'none'; profileDropdown.style.display = 'none'; originalShowDashboard(type, genreFilter); };

    // Ensure renderBrowseStories runs when storiesData changes: override publish/save code paths by wrapping push functions
    // To keep it simple, we override the global arrays' push to call renderBrowseStories after new story added (only for storiesData)
    (function(){
      const origPush = storiesData.push;
      storiesData.push = function(){
        const res = origPush.apply(this, arguments);
        try{ renderBrowseStories(currentCategorySelection || 'All'); }catch(e){};
        return res;
      };
    })();

    // Also when editor publishes (the code in createEditorPage already pushes and then calls showDashboard), but renderBrowseStories will update automatically.
    // Finally, when page loads, render browse stories once
    window.addEventListener('load', ()=>{ setTimeout(()=> renderBrowseStories('All'), 600); });


function openPreviewFullScreen(story){
  const previewFull = document.getElementById('previewFull');
  previewFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'fullscreen-panel';
  const inner = document.createElement('div');
  inner.className = 'panel-inner';

  // --- Author & Date ---
  const profileRaw = localStorage.getItem(STORAGE_KEY);
  let author = 'Jashandeep'; // fallback
  if(profileRaw){
    try{
      const p = JSON.parse(profileRaw);
      if(p.name && p.name.trim()) author = p.name;
    }catch(e){}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  // --- Snippet from first sheet ---
  let topSnippet = '';
  try{
    const firstSheet = (story.sheets && story.sheets[0] && story.sheets[0].content) || '';
    const sentences = firstSheet.split(/(?<=[.!?])\s+/).filter(Boolean);
    topSnippet = sentences.length ? sentences.slice(0,2).join(' ').trim().slice(0,360) : firstSheet.slice(0,300);
  }catch(e){ topSnippet = ''; }

  const storyTitle = story.title && story.title.trim() ? story.title : 'GENZ';

  // --- Build inner HTML ---
  // --- Build inner HTML ---
inner.innerHTML = `
  <div class="panel-top" style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start">
    <div style="flex:1;min-width:0">
      <h1 style="margin:6px 0 4px 0;word-break:break-word">${storyTitle}</h1>
      <div style="display:flex;align-items:center;gap:12px;font-size:14px;color:var(--muted);margin-bottom:6px">
  <span>Genre: ${story.genre || '—'}</span>
<span id="previewReadCount" style="font-weight:600;color:#fff;background:#000000;padding:2px 6px;border-radius:4px;">👁️ ${story.reads || 0} Reads</span>

</div>

      <div class="panel-meta" style="word-break:break-word">${story.description || ''}</div>
      <div class="panel-meta" style="margin-top:6px">Written by ${author} • Written on ${dateStr}</div>
    </div>
  </div>

  <hr />

  <div style="font-style:italic;color:var(--muted);margin-top:8px;min-height:44px;">${topSnippet}</div>
  <div style="margin-top:12px;color:var(--muted);font-size:14px">(Preview shows a few sentences from the story. Click Start Reading to open the full reader.)</div>

  <div id="previewFullTags" class="tag-row" style="margin-top:12px"></div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap">
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button id="previewCloseBtn" class="btn btn-secondary">Close</button>
      <button id="previewStartBtn" class="btn btn-primary">Start Reading</button>
    </div>
  </div>

  <div style="display:flex;gap:12px;align-items:center;margin-top:12px">
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewLikeBtn" class="btn btn-secondary" aria-pressed="false">👍 Like</button>
      <span id="previewLikeCount" class="muted">0</span>
    </div>
    <div style="display:flex;align-items:center;gap:8px">
      <button id="previewDislikeBtn" class="btn btn-secondary" aria-pressed="false">👎 Dislike</button>
      <span id="previewDislikeCount" class="muted">0</span>
    </div>
  </div>
`;


  panel.appendChild(inner);
  previewFull.appendChild(panel);
  previewFull.classList.remove('hidden');

  // --- Render Tags ---
  const tagContainer = document.getElementById('previewFullTags');
  tagContainer.innerHTML = '';

  // Safe merge: story.tags + pending tags
  const storyKey = story.title ? story.title.trim() : '';
  const pendingTags = (window._pendingTags && Array.isArray(window._pendingTags[storyKey])) ? window._pendingTags[storyKey] : [];
  const storyTags = Array.isArray(story.tags) ? story.tags : [];
  const tags = [...new Set([...storyTags, ...pendingTags])]; // merge & remove duplicates

  if(tags.length === 0){
    const placeholder = document.createElement('span');
    placeholder.className = 'muted';
    placeholder.textContent = '(No tags yet)';
    tagContainer.appendChild(placeholder);
  } else {
    tags.forEach(t => {
      const chip = document.createElement('div');
      chip.className = 'tag-chip';
      chip.textContent = t;
      tagContainer.appendChild(chip);
    });
  }

  // --- Reads counter ---
  try{
    let reads = story.reads || 0;
    const readLabel = document.createElement('div');
    readLabel.style.textAlign = 'center';
    readLabel.style.marginTop = '12px';
    readLabel.style.fontWeight = '600';
    inner.appendChild(readLabel);

    const previewStartBtn = inner.querySelector('#previewStartBtn');
    if(previewStartBtn){
      previewStartBtn.addEventListener('click', function(){
        story.reads = (story.reads || 0) + 1;
        try{ localStorage.setItem('storiesData', JSON.stringify(storiesData)); }catch(e){}
      });
    }
  }catch(e){ console.warn('reads init failed', e); }

  // --- Like/Dislike logic ---
  (function setupPreviewVotes(){
    try{
      const keyGlobal = 'global_votes_v1';
      const keyMine = 'my_votes_v1';
      const title = (story && (story.title || 'untitled')).toString();

      function loadJSON(k){ try{ return JSON.parse(localStorage.getItem(k)||'{}'); }catch(e){ return {}; } }
      function saveJSON(k,v){ localStorage.setItem(k, JSON.stringify(v)); }

      const globalVotes = loadJSON(keyGlobal);
      const myVotes = loadJSON(keyMine);

      if(!globalVotes[title]) globalVotes[title] = { likes: story.likes||0, dislikes: story.dislikes||0 };
      story.likes = globalVotes[title].likes;
      story.dislikes = globalVotes[title].dislikes;

      const likeBtn = inner.querySelector('#previewLikeBtn');
      const dislikeBtn = inner.querySelector('#previewDislikeBtn');
      const likeCount = inner.querySelector('#previewLikeCount');
      const dislikeCount = inner.querySelector('#previewDislikeCount');

      function render(){
        const mine = myVotes[title] || null;
        if(likeCount) likeCount.textContent = globalVotes[title].likes || 0;
        if(dislikeCount) dislikeCount.textContent = globalVotes[title].dislikes || 0;
        if(likeBtn){
          likeBtn.classList.toggle('btn-primary', mine==='like');
          likeBtn.classList.toggle('btn-secondary', mine!=='like');
        }
        if(dislikeBtn){
          dislikeBtn.classList.toggle('btn-primary', mine==='dislike');
          dislikeBtn.classList.toggle('btn-secondary', mine!=='dislike');
        }
      }

      function saveAndRender(){ saveJSON(keyGlobal, globalVotes); saveJSON(keyMine, myVotes); render(); }

      if(likeBtn) likeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          delete myVotes[title];
        } else if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        } else {
          globalVotes[title].likes = (globalVotes[title].likes||0)+1;
          myVotes[title]='like';
        }
        saveAndRender();
      });

      if(dislikeBtn) dislikeBtn.addEventListener('click', function(e){
        e.stopPropagation();
        const prev = myVotes[title] || null;
        if(prev==='dislike'){
          globalVotes[title].dislikes = Math.max(0, (globalVotes[title].dislikes||0)-1);
          delete myVotes[title];
        } else if(prev==='like'){
          globalVotes[title].likes = Math.max(0, (globalVotes[title].likes||0)-1);
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        } else {
          globalVotes[title].dislikes = (globalVotes[title].dislikes||0)+1;
          myVotes[title]='dislike';
        }
        saveAndRender();
      });

      render();
    }catch(e){ console.warn('vote setup failed', e); }
  })();

  // --- Share UI: styles (single injection) ---
  if (!document.getElementById('share-ui-style')) {
    const style = document.createElement('style');
    style.id = 'share-ui-style';
    style.textContent = `
      /* small share button inside panels */
     .share-btn-small {
        background: linear-gradient(135deg,#6ea8fe,#8bd3ff);
        border:none;
        color:#fff;
        padding:6px 10px;
        border-radius:12px;
        cursor:pointer;
        font-weight:600;
        font-size:13px;
        transition:transform .15s ease,box-shadow .15s ease;
      }
      .share-btn-small:hover{ transform:scale(1.03); box-shadow:0 4px 10px rgba(0,0,0,0.12); }

      /* menu */
      .share-menu {
        position:absolute;
        background:#fff;
        border:1px solid #e6e6e6;
        border-radius:10px;
        padding:8px;
        display:flex;
        flex-direction:column;
        gap:8px;
        min-width:210px;
        box-shadow:0 8px 24px rgba(15,15,15,0.12);
        z-index:1400;
      }
      .share-option {
        display:flex;
        align-items:center;
        gap:10px;
        padding:8px;
        border-radius:8px;
        border:none;
        background:#fbfbfb;
        cursor:pointer;
        font-weight:500;
      }
      .share-option:hover { background:#fff1e6; }
    `;
    document.head.appendChild(style);
  }

  // --- Create share menu and logic ---
  const existingMenu = document.getElementById('story-preview-share-menu');
  if (existingMenu) existingMenu.remove();

  const shareMenu = document.createElement('div');
  shareMenu.id = 'story-preview-share-menu';
  shareMenu.className = 'share-menu';
  shareMenu.style.display = 'none';
  document.body.appendChild(shareMenu);

  function getShareLink(platform){
    const link = `https://meurbal.in?story=${encodeURIComponent(story.title || '')}`;
    const message = `Title: ${story.title || 'Untitled'}\nGenre: ${story.genre || '—'}\nDescription: ${story.description || ''}\nRead here: ${link}`;

    if(platform === 'WhatsApp') return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
    if(platform === 'Facebook') return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
    if(platform === 'Twitter') return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
    return link;
  }

  const options = [
    { name: 'WhatsApp', label: 'WhatsApp', emoji: '🟢' },
    { name: 'Facebook', label: 'Facebook', emoji: '🔵' },
    { name: 'Twitter', label: 'Twitter', emoji: '🐦' },
    { name: 'Copy', label: 'Copy Link', emoji: '🔗' }
  ];

  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'share-option';
    btn.type = 'button';
    btn.innerHTML = `${opt.emoji} ${opt.label}`;
    btn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      if(opt.name === 'Copy'){
        const link = getShareLink();
        try{
          await navigator.clipboard.writeText(link);
          btn.textContent = '✅ Link Copied!';
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }catch(e){
          // fallback: select temporary input
          const tmp = document.createElement('input');
          tmp.value = link;
          document.body.appendChild(tmp);
          tmp.select();
          try{ document.execCommand('copy'); btn.textContent = '✅ Link Copied!'; }catch(_){}
          tmp.remove();
          setTimeout(()=> btn.innerHTML = `${opt.emoji} ${opt.label}`, 1400);
        }
      } else {
        const url = getShareLink(opt.name);
        window.open(url, '_blank');
      }
      shareMenu.style.display = 'none';
      const shareBtn = inner.querySelector('#previewShareBtn');
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    });
    shareMenu.appendChild(btn);
  });


  // Position & toggle share menu
  const shareBtn = inner.querySelector('#previewShareBtn');
  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const rect = shareBtn.getBoundingClientRect();
      // prefer below button; if not enough space, open above
      const spaceBelow = window.innerHeight - rect.bottom;
      const menuHeightGuess = 200; // safe guess
      if(spaceBelow > menuHeightGuess) {
        shareMenu.style.top = (rect.bottom + window.scrollY + 8) + 'px';
      } else {
        shareMenu.style.top = Math.max(8, rect.top + window.scrollY - menuHeightGuess - 8) + 'px';
      }
      // align to right edge of button when possible
      const left = rect.right + window.scrollX - Math.min(shareMenu.offsetWidth || 220, 220);
      shareMenu.style.left = (left > 8 ? left : rect.left + window.scrollX) + 'px';
      shareMenu.style.display = shareMenu.style.display === 'flex' || shareMenu.style.display === 'block' ? 'none' : 'flex';
      shareMenu.style.flexDirection = 'column';
      shareBtn.setAttribute('aria-expanded', shareMenu.style.display !== 'none');
    });
  }

  // Close share menu on outside click or escape
  function closeShareMenuOnClick(e){
    if(!shareMenu.contains(e.target) && e.target !== shareBtn) {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  function closeShareMenuOnEsc(e){
    if(e.key === 'Escape') {
      shareMenu.style.display = 'none';
      if(shareBtn) shareBtn.setAttribute('aria-expanded', 'false');
    }
  }
  document.addEventListener('click', closeShareMenuOnClick);
  document.addEventListener('keydown', closeShareMenuOnEsc);

  // --- Close / Start Reading buttons ---
  const closeBtn = inner.querySelector('#previewCloseBtn');
  const startBtn = inner.querySelector('#previewStartBtn');
  if(closeBtn) closeBtn.addEventListener('click', ()=> previewFull.classList.add('hidden'));
  if(startBtn) startBtn.addEventListener('click', ()=> {
    previewFull.classList.add('hidden');
    openReaderFullScreen(story);
  });

  // optional: remove listeners when preview closed to avoid leaks
  // (lightweight cleanup when previewFull hidden)
  const observer = new MutationObserver((mutations)=>{
    if(previewFull.classList.contains('hidden')){
      document.removeEventListener('click', closeShareMenuOnClick);
      document.removeEventListener('keydown', closeShareMenuOnEsc);
      observer.disconnect();
      const menu = document.getElementById('story-preview-share-menu');
      if(menu) menu.style.display = 'none';
    }
  });
  observer.observe(previewFull, { attributes: true, attributeFilter: ['class'] });
}

	
    // ---------- Fullscreen Reader ----------
function openReaderFullScreen(story) {
  const readerFull = document.getElementById('readerFull');
  readerFull.innerHTML = '';

  const panel = document.createElement('div');
  panel.className = 'reader-full';
  panel.style.position = 'fixed';
  panel.style.top = 0;
  panel.style.left = 0;
  panel.style.width = '100vw';
  panel.style.height = '100vh';
  panel.style.background = '#f7f7fb';
  panel.style.zIndex = 1200;
  panel.style.display = 'flex';
  panel.style.flexDirection = 'column';

  // --- HEADER ---
  const header = document.createElement('div');
  header.className = 'reader-header';
  header.style.display = 'flex';
  header.style.justifyContent = 'space-between';
  header.style.alignItems = 'center';
  header.style.padding = '12px 18px';
  header.style.background = '#fff';

  const profileRaw = localStorage.getItem(STORAGE_KEY);
  let author = '—';
  if (profileRaw) {
    try { author = JSON.parse(profileRaw).name || '—'; } catch (e) {}
  }
  const dateStr = story.publishedOn || new Date().toISOString().split('T')[0];

  header.innerHTML = `
    <div>
      <strong>${story.title}</strong>
      <div class="muted" style="font-size:12px">${story.genre || '—'} • Written by ${author} • ${dateStr}</div>
    </div>
    <div>
      <button id="readerCloseFullBtn" class="btn btn-secondary">Close</button>
    </div>
  `;
  panel.appendChild(header);

  // --- BODY ---
  const body = document.createElement('div');
  body.className = 'reader-body';
  body.style.flex = 1;
  body.style.overflowY = 'auto';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.alignItems = 'center';
  body.style.justifyContent = 'flex-start';
  body.style.padding = '12px';

  const sheet = document.createElement('div');
  sheet.className = 'reader-sheet';
  sheet.style.position = 'relative';
  sheet.style.width = '100%';
  sheet.style.maxWidth = '880px';
  sheet.style.minHeight = '400px';
  sheet.style.padding = '20px';
  sheet.style.background = '#fffef9';
  sheet.style.border = '1px solid #e5d7b7';
  sheet.style.borderRadius = '12px';
  sheet.style.boxShadow = '0 8px 16px rgba(0,0,0,0.1)';
  sheet.style.fontFamily = `'Georgia', 'Times New Roman', serif`;
  sheet.style.fontSize = '16px';
  sheet.style.lineHeight = '1.6';
  sheet.style.color = '#2e2b23';
  sheet.style.textAlign = 'justify';
  sheet.style.letterSpacing = '0.3px';
  sheet.style.whiteSpace = 'pre-wrap';
  sheet.style.overflowWrap = 'break-word';
  body.appendChild(sheet);

  // --- CANVAS ---
  const canvas = document.createElement('canvas');
  canvas.style.position = 'absolute';
  canvas.style.top = 0;
  canvas.style.left = 0;
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  canvas.style.pointerEvents = 'none';
  sheet.appendChild(canvas);

  // --- CONTROLS ---
  const controls = document.createElement('div');
  controls.className = 'reader-controls';
  controls.style.display = 'flex';
  controls.style.flexWrap = 'wrap';
  controls.style.gap = '6px';
  controls.style.marginTop = '12px';
  controls.innerHTML = `
    <button id="prevFullBtn" class="btn btn-secondary">◀ Prev</button>
    <button id="startFullBtn" class="btn btn-primary">Start</button>
    <button id="nextFullBtn" class="btn btn-secondary">Next ▶</button>
    <button id="markBtn" class="btn btn-warning">✏️ Mark Last Read</button>
    <button id="removeMarkBtn" class="btn btn-danger" style="display:none;">🗑️ Remove Last Mark</button>
  `;
  body.appendChild(controls);
  panel.appendChild(body);
  readerFull.appendChild(panel);
  readerFull.classList.remove('hidden');

  const sheets = story.sheets || [{ content: '' }];
  let idx = 0;
  const savedKey = `lastReadMark_${story.id || story.title}`;

  // --- CANVAS CONTEXT ---
  const ctx = canvas.getContext('2d');
  ctx.strokeStyle = 'red';
  ctx.lineWidth = 2;
  let drawing = false;
  let lastX = 0, lastY = 0;

  function enableDrawing(canvas, context) {
    // Desktop
    canvas.addEventListener('mousedown', e => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    });
    canvas.addEventListener('mousemove', e => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    });
    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseout', () => drawing = false);

    // Mobile / Touch
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.touches[0].clientX - rect.left;
      lastY = e.touches[0].clientY - rect.top;
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      context.beginPath();
      context.moveTo(lastX, lastY);
      context.lineTo(x, y);
      context.stroke();
      lastX = x;
      lastY = y;
    }, { passive: false });

    canvas.addEventListener('touchend', () => drawing = false);
    canvas.addEventListener('touchcancel', () => drawing = false);
  }

  // --- LOAD MARK ---
  function loadMark() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const imgData = localStorage.getItem(`${savedKey}_${idx}`);
    if (imgData) {
      const img = new Image();
      img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      img.src = imgData;
      removeMarkBtn.style.display = 'inline-block';
    } else {
      removeMarkBtn.style.display = 'none';
    }
  }

  const markBtn = document.getElementById('markBtn');
  const removeMarkBtn = document.getElementById('removeMarkBtn');
  const startBtn = document.getElementById('startFullBtn');

  // --- INITIAL LOAD ---
  sheet.textContent = sheets[idx].content || '';
  loadMark();

  // --- EVENT LISTENERS ---
  markBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'auto';
    enableDrawing(canvas, ctx);
  });

  removeMarkBtn.addEventListener('click', () => {
    canvas.style.pointerEvents = 'none';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    localStorage.removeItem(`${savedKey}_${idx}`);
    removeMarkBtn.style.display = 'none';
  });

  startBtn.addEventListener('click', () => {
    if (canvas) {
      localStorage.setItem(`${savedKey}_${idx}`, canvas.toDataURL());
      canvas.style.pointerEvents = 'none';
      removeMarkBtn.style.display = 'inline-block';
    }
  });

  document.getElementById('prevFullBtn').addEventListener('click', () => {
    if (idx > 0) {
      idx--;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('nextFullBtn').addEventListener('click', () => {
    if (idx < sheets.length - 1) {
      idx++;
      sheet.textContent = sheets[idx].content || '';
      loadMark();
    }
  });

  document.getElementById('readerCloseFullBtn').addEventListener('click', () => {
    readerFull.classList.add('hidden');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
}
    
// --- Fix: Show only one section (stories or serials) and highlight active tab ---
function setDashboardTabHighlight(type) {
  const storiesBtn = document.getElementById('showStoriesBtn');
  const serialsBtn = document.getElementById('showSerialsBtn');

  if (type === 'stories') {
    storiesBtn.classList.add('btn-primary');
    storiesBtn.classList.remove('btn-secondary');
    serialsBtn.classList.add('btn-secondary');
    serialsBtn.classList.remove('btn-primary');
  } else {
    serialsBtn.classList.add('btn-primary');
    serialsBtn.classList.remove('btn-secondary');
    storiesBtn.classList.add('btn-secondary');
    storiesBtn.classList.remove('btn-primary');
  }
}

document.getElementById('showStoriesBtn').addEventListener('click', () => {
  showDashboard('stories');
  setDashboardTabHighlight('stories');
});

document.getElementById('showSerialsBtn').addEventListener('click', () => {
  showDashboard('serials');
  setDashboardTabHighlight('serials');
});

const oldShowDashboard = showDashboard;
showDashboard = function(type = 'stories', genreFilter = 'All') {
  oldShowDashboard(type, genreFilter);
  setDashboardTabHighlight(type);
};

</script>

<!-- START: SERIALS EXTENSION INJECTION -->
<script>
// Saved serials storage key
const SAVED_SERIALS_KEY = 'savedSerials_v1';

// Utility: load/save serials from localStorage
function loadSavedSerials(){
  try{ const raw = localStorage.getItem(SAVED_SERIALS_KEY); return raw ? JSON.parse(raw) : []; }catch(e){ console.warn(e); return []; }
}
function saveSavedSerials(arr){ try{ localStorage.setItem(SAVED_SERIALS_KEY, JSON.stringify(arr)); }catch(e){ console.warn(e); } }

// Ensure serialsData syncs to savedSerials periodically and on key events
function syncSerialsToStorage(){
  try{
    const current = loadSavedSerials();
    // merge serialsData into saved (by title)
    (serialsData || []).forEach(s => {
      if(!s || !s.title) return;
      const existing = current.find(x => x.title === s.title);
      if(existing){
        // update existing
        existing.genre = s.genre || existing.genre;
        existing.description = s.description || existing.description;
        existing.episodes = s.episodes || existing.episodes || [];
      } else {
        current.push(JSON.parse(JSON.stringify(s)));
      }
    });
    saveSavedSerials(current);
    renderBrowseSerials(current);
  }catch(e){ console.warn(e); }
}
// call periodically as a safety net
setInterval(syncSerialsToStorage, 1500);

// Hook some UI actions that already exist to call sync after create/update
try{
  // when serial create popup confirms
  const origSerialCreateConfirm = window.serialCreateConfirmBtn;
}catch(e){ /* ignore if not accessible */ }

// expose a function to render serials browse listing
// Tunable parameters
// ------------------ CONFIG ------------------
const ALGO_CONFIG = {
  popularityWeight: 0.5,     // slightly lower to allow novelty
  recencyWeight: 0.25,
  noveltyWeight: 0.25,       // increased to give new serials more chance
  randomWeight: 0.1,         // slightly higher for exploration
  freshDaysBoost: 21,        // recent content boost
  freshBoostMultiplier: 1.4, // stronger boost
  explorationFraction: 0.25,
  cardsPerViewport: 6,

  // Trending config (moved here for easy tuning)
  trending: {
    addThreshold: 50,   // recentReads >= 50 -> add to trending
    keepThreshold: 100, // recentReads >= 100 -> definitely keep for that update
    dropThreshold: 40,  // trending -> remove if recentReads < 40
    expireDays: 7       // optionally expire trending entries not updated for this many days
  },

  // Recently-read UI config
  recentlyReadLimit: 50
};

// ================= SESSION SEED =================
(function initSessionSeed() {
  if (window.__SERIALS_RENDER_SEED) return;
  let extra = 0;
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    extra = arr[0];
  } else {
    extra = Math.floor(Math.random() * 0xffffffff);
  }
  window.__SERIALS_RENDER_SEED = ((Date.now() & 0xffffffff) ^ extra) >>> 0;
})();

// small deterministic PRNG
function mulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r = r + Math.imul(r ^ (r >>> 7), 61 | r) ^ r;
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function rngForThisRender() {
  return mulberry32(window.__SERIALS_RENDER_SEED);
}

// ================= UTILITIES =================
function daysSince(dateString) {
  if (!dateString) return Number.MAX_SAFE_INTEGER;
  const d = new Date(dateString);
  if (isNaN(d)) return Number.MAX_SAFE_INTEGER;
  return Math.floor((Date.now() - d.getTime()) / (1000 * 60 * 60 * 24));
}
function normalizeArray(values) {
  const clean = values.map(v => Number.isFinite(v) ? v : 0);
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  return max === min ? clean.map(() => 0.5) : clean.map(v => (v - min) / (max - min));
}
function shuffleArray(arr, rng = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor((rng ? rng() : Math.random()) * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function computePopularityMetric(s) {
  const reads = Number(s.reads ?? s.readCount ?? 0);
  const likes = Number(s.likes ?? 0);
  return Math.log1p(reads) + 1.5 * Math.log1p(likes); // log scale for both
}

// ================= TRENDING & RECENT HELPERS =================
function getRecentReadsForSerial(s) {
  // flexible detection of "recent reads"
  const candidates = [
    s.recentReads,
    s.readsLast24h,
    s.readsToday,
    s.readsLastDay,
    s.dailyReads
  ];
  for (let c of candidates) if (Number.isFinite(c)) return Number(c);

  // fallback: difference between readCount and prevReadCount (if available)
  if (Number.isFinite(s.readCount) && Number.isFinite(s.prevReadCount)) {
    return Math.max(0, Number(s.readCount) - Number(s.prevReadCount));
  }

  // no data
  return undefined;
}

function loadTrendingState() {
  try {
    const raw = localStorage.getItem('trending_serials_v1');
    return raw ? JSON.parse(raw) : { ids: {}, lastUpdated: Date.now() };
  } catch (e) {
    return { ids: {}, lastUpdated: Date.now() };
  }
}
function saveTrendingState(state) {
  try { localStorage.setItem('trending_serials_v1', JSON.stringify(state)); } catch (e) {}
}

// Update trending membership based on recentReads thresholds (returns new state)
function updateTrendingStateForSerials(serials) {
  const state = loadTrendingState();
  const now = Date.now();
  const cfg = ALGO_CONFIG.trending;
  serials.forEach(s => {
    const id = s.id ?? s.slug ?? s.title;
    if (!id) return;
    const recent = getRecentReadsForSerial(s);
    const currentlyTrending = !!state.ids[id];

    if (Number.isFinite(recent)) {
      if (recent >= cfg.keepThreshold) {
        // definitely trending / keep
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (recent >= cfg.addThreshold) {
        // newly trending candidate or keep
        state.ids[id] = { since: state.ids[id]?.since || now, lastSeen: now, recent };
      } else if (currentlyTrending && recent < cfg.dropThreshold) {
        // drop out if below drop threshold
        delete state.ids[id];
      } else if (currentlyTrending) {
        // update lastSeen when still trending but not dropped
        state.ids[id] = { ...state.ids[id], lastSeen: now, recent };
      }
    } else {
      // no recent metric — optionally remove if expired
      if (currentlyTrending) {
        const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
        const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
        if (cfg.expireDays && daysSinceSeen > cfg.expireDays) {
          delete state.ids[id];
        }
      }
    }
  });

  // also prune any stale trending entries not present in serial list (optional)
  const presentIds = new Set(serials.map(s => s.id ?? s.slug ?? s.title));
  Object.keys(state.ids).forEach(id => {
    if (!presentIds.has(id)) {
      const lastSeen = state.ids[id]?.lastSeen || state.ids[id]?.since || now;
      const daysSinceSeen = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));
      if (ALGO_CONFIG.trending.expireDays && daysSinceSeen > ALGO_CONFIG.trending.expireDays) {
        delete state.ids[id];
      }
    }
  });

  state.lastUpdated = now;
  saveTrendingState(state);
  return state;
}

function getTrendingSerialsFromState(serials, state) {
  const ids = new Set(Object.keys(state.ids || {}));
  return serials.filter(s => {
    const id = s.id ?? s.slug ?? s.title;
    return id && ids.has(id);
  });
}

// Recently read storage
function recordRecentlyRead(serial) {
  try {
    const raw = localStorage.getItem('recently_read_v1');
    let arr = raw ? JSON.parse(raw) : [];
    const id = serial.id ?? serial.slug ?? serial.title;
    // create minimal entry for display
    const entry = {
      id,
      title: serial.title || 'Untitled',
      cover: serial.cover || null,
      genre: serial.genre || null,
      description: serial.description || null,
      at: Date.now()
    };
    // remove duplicate
    arr = arr.filter(x => x.id !== id);
    arr.unshift(entry);
    const limit = Number.isFinite(ALGO_CONFIG.recentlyReadLimit) ? ALGO_CONFIG.recentlyReadLimit : 50;
    if (arr.length > limit) arr = arr.slice(0, limit);
    localStorage.setItem('recently_read_v1', JSON.stringify(arr));
  } catch (e) {}
}
function loadRecentlyRead() {
  try {
    const raw = localStorage.getItem('recently_read_v1');
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}

// Helper to safely open preview + record recent
function openSerialPreviewAndRecord(serial) {
  try { recordRecentlyRead(serial); } catch (e) {}
  if (typeof openSerialPreview === 'function') {
    // prefer id/slug/title depending on what the preview expects
    if (serial.id) openSerialPreview(serial.id);
    else if (serial.slug) openSerialPreview(serial.slug);
    else openSerialPreview(serial.title || '');
  } else {
    console.warn('openSerialPreview not defined');
  }
}

// ================= SCORING & EXPLORATION =================
function scoredSerialsWithNormalization(serials, rng) {
  rng = rng || Math.random;

  const popArr = serials.map(computePopularityMetric);
  const ageArr = serials.map(s => {
    const ds = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);
    return Math.max(0, 365 - Math.min(ds, 365));
  });

  const popNorm = normalizeArray(popArr);
  const recNorm = normalizeArray(ageArr);

  return serials.map((s,i) => {
    const pop = popNorm[i];
    const rec = recNorm[i];

    // novelty: higher for less popular, but minimum 0.2
    const novelty = Math.max(0.2, 1 - pop);

    // small random noise for exploration
    const randomEps = (rng ? rng() : Math.random()) * ALGO_CONFIG.randomWeight;

    // combined score
    let score = ALGO_CONFIG.popularityWeight * pop
              + ALGO_CONFIG.recencyWeight * rec
              + ALGO_CONFIG.noveltyWeight * novelty
              + randomEps;

    const ageDays = daysSince(s.published || s.createdAt || s.date || s.uploadedAt);

    // fresh boost for recent content
    if (ageDays <= ALGO_CONFIG.freshDaysBoost) score *= ALGO_CONFIG.freshBoostMultiplier;

    return Object.assign({}, s, { __score: score, __popNorm: pop, __recNorm: rec, __novelty: novelty, __ageDays: ageDays });
  });
}

// pick exploration serials (optional)
function pickExploration(candidates, count, rng) {
  if (!candidates || candidates.length === 0 || count <= 0) return [];
  rng = rng || Math.random;

  const scored = candidates.map(s => {
    const novelty = s.__novelty ?? 0.5;
    const recency = s.__recNorm ?? 0.5;
    return Object.assign({}, s, { __exploreScore: novelty*0.6 + recency*0.4 + (rng ? rng() : Math.random())*0.1 });
  });

  scored.sort((a,b) => b.__exploreScore - a.__exploreScore);
  return shuffleArray(scored.slice(0, Math.min(count, scored.length)), rng);
}

// ================= DEMO SERIAL GENERATOR =================
function generateDemoSerials(count = 0, rng) {
  const genres = ["Action","Romance","Comedy","Fantasy","Horror","Tragedy","Tragic","Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/demo1/600/900",
    "https://picsum.photos/seed/demo2/600/900",
    "https://picsum.photos/seed/demo3/600/900",
    "https://picsum.photos/seed/demo4/600/900",
    "https://picsum.photos/seed/demo5/600/900",
    "https://picsum.photos/seed/demo6/600/900"
  ];
  const serials = [];
  for (let i=0;i<count;i++){
    const genre = genres[Math.floor(rng()*genres.length)];
    const title = `${genre} Demo Serial ${i+1}`;
    const readCount = Math.floor(rng()*1000);
    const likes = Math.floor(rng()*400);
    const daysAgo = Math.floor(rng()*400);
    const date = new Date(Date.now()-daysAgo*86400000).toISOString();
    serials.push({
      id:`demo-${i+1}`,
      title, genre, description:`Demo ${genre.toLowerCase()} serial — random readCount ${readCount}.`,
      cover: covers[i % covers.length], readCount, likes, createdAt: date
    });
  }
  return serials;
}

// ================= MAIN RENDER FUNCTION =================
function renderBrowseSerials(list = null, opts = { includeDemo: true, demoCount: 0, mergeWithSaved: false }) {
  const rng = rngForThisRender();
  try {
    // --- Container setup ---
    let container = document.getElementById('serialsBrowseList');
    if (!container) {
      const parent = document.getElementById('serialCategoriesPage') || document.body;
      container = document.createElement('div');
      container.id = 'serialsBrowseList';
      container.style.maxWidth = '980px';
      container.style.margin = '18px auto';
      parent.appendChild(container);
    }

    // --- Load serials ---
    const saved = Array.isArray(list)
      ? list
      : (typeof loadSavedSerials === 'function'
          ? loadSavedSerials()
          : JSON.parse(localStorage.getItem('saved_serials_v1') || '[]'));
    const demo = opts.includeDemo ? generateDemoSerials(opts.demoCount || 50, rng) : [];
    const serialsRaw =
      saved && saved.length && opts.mergeWithSaved ? demo.concat(saved) : saved && saved.length ? saved : demo;
    if (!serialsRaw || !serialsRaw.length) {
      container.style.display = 'none';
      return;
    }

    // Clear container to avoid stale DOM
    container.innerHTML = '';
    container.style.display = 'block';

    const genresOrder = ['Action', 'Romance', 'Comedy', 'Fantasy', 'Horror', 'Tragic', "Thriller","Adventure","Crime","Historic"];
    const grouped = {};
    serialsRaw.forEach(s => {
      const g = s.genre ? s.genre.trim() : 'Other';
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    // Update trending state before scoring
    const trendingState = updateTrendingStateForSerials(serialsRaw);

    const allScored = scoredSerialsWithNormalization(serialsRaw, rng);
    const scoredMap = new Map();
    allScored.forEach(s => {
      const key = s.id ?? s.slug ?? s.title ?? JSON.stringify({ title: s.title, createdAt: s.createdAt });
      scoredMap.set(key, s);
    });

    const imagesToWait = [];

    // --- TRENDING SECTION (top) ---
    const trendingSerials = getTrendingSerialsFromState(allScored, trendingState);
    if (trendingSerials && trendingSerials.length) {
      trendingSerials.sort((a, b) => {
        const ida = a.id ?? a.slug ?? a.title;
        const idb = b.id ?? b.slug ?? b.title;
        const sa = (trendingState.ids[ida]?.recent || 0) + (a.__score || 0);
        const sb = (trendingState.ids[idb]?.recent || 0) + (b.__score || 0);
        return sb - sa;
      });

      const trendingSection = document.createElement('div');
      trendingSection.dataset.genre = 'Trending';
      trendingSection.style.marginBottom = '28px';

      const heading = document.createElement('h2');
      heading.textContent = '🔥 Trending';
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      trendingSection.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap trending-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';

      // wheel-to-scroll fix
      scrollWrap.addEventListener(
        'wheel',
        e => {
          if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
            scrollWrap.scrollLeft += e.deltaY;
            e.preventDefault();
          }
        },
        { passive: false }
      );

      trendingSerials.forEach(s => {
        const card = document.createElement('div');
        card.className = 'serial-card trending-card';
        // match main serial card size
        card.style.minWidth = '300px';
        card.style.height = '400px';
        card.style.flex = '0 0 auto';
        card.style.borderRadius = '16px';
        card.style.padding = '16px';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.justifyContent = 'space-between';
        card.style.position = 'relative';
        card.style.cursor = 'pointer';
        card.style.scrollSnapAlign = 'center';
        if (s.cover) {
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.42),rgba(0,0,0,0.42)),url(${s.cover})`;
          card.style.backgroundSize = 'cover';
          card.style.backgroundPosition = 'center';
          card.style.color = '#fff';
        } else {
          card.style.background = '#fff';
          card.style.color = '#000';
        }

        // Info block (title, genre, description)
        const infoDiv = document.createElement('div');
        infoDiv.innerHTML = `<h4 style="margin:0;font-size:17px;text-shadow:1px 1px 3px rgba(0,0,0,0.6)">${s.title || 'Untitled Series'}</h4>
          <div style="margin-top:6px;font-size:12px;opacity:0.9">${s.genre || 'Genre: Unknown'}</div>
          <p style="margin:8px 0 0;font-size:13px;color:inherit;opacity:0.95;overflow:hidden;display:-webkit-box;-webkit-line-clamp:4;-webkit-box-orient:vertical;line-height:1.35;text-shadow:1px 1px 2px rgba(0,0,0,0.4)">${s.description || ''}</p>`;

        card.appendChild(infoDiv);

        const rc = document.createElement('div');
        rc.style.position = 'absolute';
        rc.style.left = '12px';
        rc.style.top = '12px';
        rc.style.background = 'rgba(255,255,255,0.85)';
        rc.style.padding = '6px 8px';
        rc.style.borderRadius = '12px';
        rc.style.fontSize = '12px';
        rc.style.color = '#222';
        const recent = getRecentReadsForSerial(s);
        rc.textContent = recent !== undefined ? `+${recent} today` : (s.readCount ? `reads ${Number(s.readCount).toLocaleString()}` : '');
        card.appendChild(rc);

        const bottomDiv = document.createElement('div');
        bottomDiv.style.display = 'flex';
        bottomDiv.style.justifyContent = 'flex-end';

        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn view-serial-btn';
        viewBtn.textContent = '🎬 View';
        viewBtn.addEventListener('click', ev => {
          ev.stopPropagation();
          openSerialPreviewAndRecord(s);
        });
        bottomDiv.appendChild(viewBtn);
        card.appendChild(bottomDiv);

        // hover/touch behavior
        card.addEventListener('mouseenter', () => { card.style.transform = 'scale(1.06)'; card.style.zIndex = 2; });
        card.addEventListener('mouseleave', () => { card.style.transform = 'scale(1)'; card.style.zIndex = 1; });

        scrollWrap.appendChild(card);
      });

      trendingSection.appendChild(scrollWrap);
      container.appendChild(trendingSection);
    }

    // --- GENRE SECTIONS ---
    genresOrder.forEach(genre => {
      const rawList = grouped[genre];
      if (!rawList || !rawList.length) return;

      const scoredList = rawList.map(s => {
        const key = s.id ?? s.slug ?? s.title ?? JSON.stringify({ title: s.title, createdAt: s.createdAt });
        return scoredMap.get(key) || Object.assign({}, s, { __score: rng() * 0.2 });
      });

      const sorted = scoredList.slice().sort((a, b) => (b.__score || 0) - (a.__score || 0));
      const displayCount = Math.min(sorted.length, Math.max(ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length)));
      const explorationCount = Math.ceil(displayCount * ALGO_CONFIG.explorationFraction);
      const topCandidates = sorted.slice(0, Math.max(0, displayCount - explorationCount));
      const remaining = sorted.slice(displayCount - explorationCount);
      const explorationPool = remaining.concat(sorted.slice(displayCount));
      const explorationPicked = pickExploration(explorationPool, explorationCount, rng);

      const finalList = [];
      const maxLen = Math.max(topCandidates.length, explorationPicked.length);
      for (let i = 0; i < maxLen; i++) {
        if (i < topCandidates.length) finalList.push(topCandidates[i]);
        if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
      }
      if (finalList.length === 0) finalList.push(...sorted.slice(0, displayCount));
      shuffleArray(finalList, rng);

      // --- Section setup ---
      const section = document.createElement('div');
      section.dataset.genre = genre;
      section.style.marginBottom = '32px';

      const heading = document.createElement('h3');
      heading.textContent = genre;
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      section.appendChild(heading);

      const scrollWrap = document.createElement('div');
      scrollWrap.className = 'scroll-wrap';
      scrollWrap.style.display = 'flex';
      scrollWrap.style.overflowX = 'auto';
      scrollWrap.style.gap = '12px';
      scrollWrap.style.padding = '12px';
      scrollWrap.style.scrollBehavior = 'smooth';
      scrollWrap.style.scrollSnapType = 'x mandatory';
      scrollWrap.style.scrollbarWidth = 'thin';

      // --- Fix horizontal scrolling with mouse wheel ---
      scrollWrap.addEventListener(
        'wheel',
        e => {
          if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) {
            scrollWrap.scrollLeft += e.deltaY;
            e.preventDefault();
          }
        },
        { passive: false }
      );

      // --- Cards ---
      finalList.forEach(s => {
        const card = document.createElement('div');
        card.className = 'serial-card';
        card.dataset.title = s.title || '';
        card.style.minWidth = '300px';
        card.style.height = '400px';
        card.style.flex = '0 0 auto';
        card.style.borderRadius = '16px';
        card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)';
        card.style.padding = '16px';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.justifyContent = 'space-between';
        card.style.position = 'relative';
        card.style.transition = 'transform 0.25s ease, box-shadow 0.25s ease';
        card.style.overflow = 'hidden';
        card.style.cursor = 'pointer';
        card.style.scrollSnapAlign = 'center';

        if (s.cover) {
          const img = new Image();
          img.src = s.cover;
          img.alt = s.title || 'cover';
          imagesToWait.push(
            new Promise(resolve => {
              if (img.complete) return resolve();
              img.onload = img.onerror = () => resolve();
            })
          );
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.45),rgba(0,0,0,0.45)),url(${s.cover})`;
          card.style.backgroundSize = 'cover';
          card.style.backgroundPosition = 'center';
          card.style.color = '#fff';
        } else {
          card.style.background = '#fff';
          card.style.color = '#000';
        }

        // --- Netflix-style hover/touch scale ---
        card.style.transition = 'transform 0.25s ease, box-shadow 0.25s ease';

        const scaleUp = () => {
          card.style.transform = 'scale(1.08)';
          card.style.zIndex = '2';
          card.style.boxShadow = '0 12px 24px rgba(0,0,0,0.3)';
        };
        const scaleDown = () => {
          card.style.transform = 'scale(1)';
          card.style.zIndex = '1';
          card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.15)';
        };

        // Desktop hover
        card.addEventListener('mouseenter', scaleUp);
        card.addEventListener('mouseleave', scaleDown);

        // Mobile / touch
        card.addEventListener('touchstart', scaleUp);
        card.addEventListener('touchend', scaleDown);
        card.addEventListener('touchcancel', scaleDown);

        // --- Info + buttons ---
        const infoDiv = document.createElement('div');
        infoDiv.innerHTML = `<h4 style="margin:0;font-size:17px;text-shadow:1px 1px 3px rgba(0,0,0,0.6)">${s.title ||
          'Untitled Series'}</h4>
        <div style="margin-top:6px;font-size:12px;opacity:0.9">${s.genre || 'Genre: Unknown'}</div>
        <p style="margin:6px 0 0;font-size:13px;color:inherit;opacity:0.9;overflow:hidden;display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;line-height:1.4;text-shadow:1px 1px 2px rgba(0,0,0,0.4)">${
          s.description || ''
        }</p>`;

        if (typeof s.readCount !== 'undefined') {
          const rc = document.createElement('div');
          rc.style.position = 'absolute';
          rc.style.right = '12px';
          rc.style.top = '12px';
          rc.style.background = 'rgba(255,255,255,0.85)';
          rc.style.padding = '6px 8px';
          rc.style.borderRadius = '12px';
          rc.style.fontSize = '12px';
          rc.style.color = '#222';
          rc.textContent = `reads ${Number(s.readCount).toLocaleString()}`;
          card.appendChild(rc);
        }

        const bottomDiv = document.createElement('div');
        bottomDiv.style.display = 'flex';
        bottomDiv.style.justifyContent = 'flex-end';
        bottomDiv.style.gap = '8px';
        bottomDiv.style.marginTop = '10px';
        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn btn-secondary view-serial-btn';
        viewBtn.textContent = '🎬 View';
        viewBtn.addEventListener('click', ev => {
          ev.stopPropagation();
          openSerialPreviewAndRecord(s);
        });
        bottomDiv.appendChild(viewBtn);

        card.appendChild(infoDiv);
        card.appendChild(bottomDiv);
        scrollWrap.appendChild(card);
      });

      section.appendChild(scrollWrap);
      container.appendChild(section);
    });

    // --- RECENTLY READ SECTION (bottom) ---
    const recentArr = loadRecentlyRead();
    if (recentArr && recentArr.length) {
      const recentSection = document.createElement('div');
      recentSection.dataset.section = 'recently-read';
      recentSection.style.marginTop = '28px';
      recentSection.style.marginBottom = '36px';

      const heading = document.createElement('h3');
      heading.textContent = '📚 Recently Viewed';
      heading.style.margin = '6px 12px';
      heading.style.textAlign = 'left';
      recentSection.appendChild(heading);

      const wrap = document.createElement('div');
      wrap.style.display = 'flex';
      wrap.style.overflowX = 'auto';
      wrap.style.gap = '12px';
      wrap.style.padding = '12px';

      recentArr.forEach(r => {
        const card = document.createElement('div');
        card.className = 'recent-card serial-card';
        // match main card size
        card.style.minWidth = '300px';
        card.style.height = '400px';
        card.style.flex = '0 0 auto';
        card.style.borderRadius = '16px';
        card.style.padding = '16px';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.justifyContent = 'space-between';
        card.style.position = 'relative';
        card.style.cursor = 'pointer';
        card.style.scrollSnapAlign = 'center';

        if (r.cover) {
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.2),rgba(0,0,0,0.2)),url(${r.cover})`;
          card.style.backgroundSize = 'cover';
          card.style.backgroundPosition = 'center';
          card.style.color = '#fff';
        } else {
          card.style.background = '#fff';
          card.style.color = '#000';
        }

        // show title, genre, description (use stored genre/description if available)
        const titleDiv = document.createElement('div');
        titleDiv.innerHTML = `<h4 style="margin:0;font-size:17px;text-shadow:1px 1px 3px rgba(0,0,0,0.6)">${r.title || 'Untitled'}</h4>
          <div style="margin-top:6px;font-size:12px;opacity:0.9">${r.genre || 'Genre: Unknown'}</div>
          <p style="margin:8px 0 0;font-size:13px;color:inherit;opacity:0.95;overflow:hidden;display:-webkit-box;-webkit-line-clamp:4;-webkit-box-orient:vertical;line-height:1.35;text-shadow:1px 1px 2px rgba(0,0,0,0.3)">${r.description || ''}</p>`;
        card.appendChild(titleDiv);

        card.addEventListener('click', () => {
          // find serial by id in serialsRaw first, fallback to opening by title if not present
          const found = serialsRaw.find(s => (s.id ?? s.slug ?? s.title) === r.id);
          if (found) openSerialPreviewAndRecord(found);
          else openSerialPreview(r.title);
        });

        wrap.appendChild(card);
      });

      recentSection.appendChild(wrap);
      container.appendChild(recentSection);
    }

  } catch (e) {
    console.warn(e);
  }
}


// Optional: auto-run demo on DOMContentLoaded (uncomment if desired)
// document.addEventListener('DOMContentLoaded', () => runDemoTest({ demoCount: 50, mergeWithSaved: true }));

function openSerialPreview(title) {
  try {
    const VOTES_STORE_KEY = 'global_votes_v1';
    const USER_VOTES_KEY = 'user_votes_v1';
    const READS_KEY = 'serial_reads_v1';

    let saved = [];
    try { 
      saved = typeof loadSavedSerials === 'function' ? loadSavedSerials() : (JSON.parse(localStorage.getItem('saved_serials_v1')||'[]')); 
    } catch(e) { saved = []; }

    const serial = (saved || []).find(s => s.title === title) || (serialsData || []).find(s => s.title === title);
    if (!serial) { alert('Serial not found'); return; }

    const voteKey = `serial::${serial.title || 'untitled'}`;
    const readKey = `serial::${serial.title || 'untitled'}`;

    function loadStore(key) { try { return JSON.parse(localStorage.getItem(key) || '{}'); } catch(e) { return {}; } }
    function saveStore(key, obj) { try { localStorage.setItem(key, JSON.stringify(obj || {})); } catch(e) {} }

    const votesStore = loadStore(VOTES_STORE_KEY);
    const userStore = loadStore(USER_VOTES_KEY);
    const readsStore = loadStore(READS_KEY);

    const storedVotes = votesStore[voteKey] || { likes: Number(serial.likes || 0), dislikes: Number(serial.dislikes || 0) };
    serial.likes = Number(storedVotes.likes || 0);
    serial.dislikes = Number(storedVotes.dislikes || 0);
    votesStore[voteKey] = { likes: serial.likes, dislikes: serial.dislikes };
    saveStore(VOTES_STORE_KEY, votesStore);

    const storedReads = readsStore[readKey] || { total: 0, episodes: {} };
    readsStore[readKey] = storedReads;
    saveStore(READS_KEY, readsStore);

    let panel = document.getElementById('serialPreviewFull');
    if (!panel) {
      panel = document.createElement('div');
      panel.id = 'serialPreviewFull';
      panel.className = 'fullscreen-panel';
      panel.style.zIndex = 1100;
      panel.style.overflow = 'auto';
      document.body.appendChild(panel);
    }

    panel.innerHTML = '';
    const inner = document.createElement('div');
    inner.className = 'panel-inner';

    function esc(str) { return String(str == null ? '' : str).replace(/</g,'&lt;'); }
    function formatDateVal(raw) {
      if (!raw && raw !== 0) return '—';
      let d = null;
      if (typeof raw === 'number' || /^\d+$/.test(String(raw))) d = new Date(Number(raw));
      else d = new Date(raw);
      if (isNaN(d.getTime())) return '—';
      return d.toLocaleDateString('en-IN', { year: 'numeric', month: 'short', day: 'numeric' });
    }

    let author = serial.author || serial.authorName || serial.writtenBy || serial.writer || serial.by;
    if (!author) {
      const profileRaw = localStorage.getItem(STORAGE_KEY);
      if (profileRaw) {
        try {
          const p = JSON.parse(profileRaw);
          if (p.name && p.name.trim()) author = p.name.trim();
        } catch(e) {}
      }
    }
    author = author || 'Unknown';

    let rawPublished = serial.publishedOn || serial.date || serial.published || serial.published_on || serial.publishedDate || serial.published_at;
    if (!rawPublished) {
      rawPublished = new Date().toISOString();
      serial.publishedOn = rawPublished;
      try { if (typeof saveSerials === 'function') saveSerials(); } catch(e){}
    }
    const dateStr = formatDateVal(rawPublished);

    // Header (with genre div for share button)
    const header = document.createElement('div');
    header.className = 'panel-top';
    header.innerHTML = `
      <div style="flex:1">
        <h1 style="margin:6px 0 4px 0">${esc(serial.title || 'Untitled')}</h1>
        <div class="panel-meta" style="margin-top:6px">Written by ${esc(author)} • Written on ${dateStr}</div>
        <div class="serial-genre" style="display:flex;align-items:center;gap:8px;font-size:14px;color:var(--muted);margin-top:6px">
          Genre: ${esc(serial.genre || '—')}
        </div>
        <div class="panel-meta" style="margin-top:6px">${esc(serial.description || '')}</div>
      </div>
    `;
    inner.appendChild(header);

    // SHARE BUTTON
    const genreDiv = header.querySelector('.serial-genre');
    if (genreDiv) {
      const shareBtn = document.createElement('button');
      shareBtn.className = 'share-btn';
      shareBtn.textContent = 'Share';
      genreDiv.appendChild(shareBtn);

      if (!document.getElementById('share-ui-style')) {
        const style = document.createElement('style');
        style.id = 'share-ui-style';
        style.textContent = `
          .share-btn {
            background: linear-gradient(135deg, #ff5f6d, #ffc371);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
          }
          .share-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
          }
          .share-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.15);
            z-index: 1200;
            animation: fadeIn 0.15s ease-out;
          }
          .share-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border: none;
            border-radius: 8px;
            background: #f9f9f9;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
          }
          .share-option:hover {
            background: #ffe9d6;
          }
          @keyframes fadeIn {
            from {opacity:0; transform:translateY(-5px);}
            to {opacity:1; transform:translateY(0);}
          }
        `;
        document.head.appendChild(style);
      }

      const shareMenu = document.createElement('div');
      shareMenu.className = 'share-menu';
      document.body.appendChild(shareMenu);

      function getShareLink(platform) {
        const link = `https://meurbal.in?serial=${encodeURIComponent(serial.title)}`;
        const message = `Title: ${serial.title || 'Untitled'}\nGenre: ${serial.genre || '—'}\nDescription: ${serial.description || ''}\nRead here: ${link}`;
        if (platform === 'WhatsApp') return `https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`;
        if (platform === 'Facebook') return `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(link)}`;
        if (platform === 'Twitter') return `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
        return link;
      }

      const platforms = [
        { name: 'WhatsApp', emoji: '🟢' },
        { name: 'Facebook', emoji: '🔵' },
        { name: 'Twitter', emoji: '🐦' },
        { name: 'Copy Link', emoji: '🔗' }
      ];

      platforms.forEach(({ name, emoji }) => {
        const option = document.createElement('button');
        option.className = 'share-option';
        option.innerHTML = `${emoji} ${name}`;
        option.addEventListener('click', async () => {
          if (name === 'Copy Link') {
            const link = getShareLink();
            await navigator.clipboard.writeText(link);
            option.textContent = '✅ Link Copied!';
            setTimeout(() => (option.innerHTML = `${emoji} ${name}`), 1500);
          } else {
            const url = getShareLink(name);
            window.open(url, '_blank');
          }
          shareMenu.style.display = 'none';
        });
        shareMenu.appendChild(option);
      });

      shareBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const rect = shareBtn.getBoundingClientRect();
        shareMenu.style.top = `${rect.bottom + window.scrollY + 6}px`;
        shareMenu.style.left = `${rect.left + window.scrollX}px`;
        shareMenu.style.display = shareMenu.style.display === 'flex' ? 'none' : 'flex';
      });

      document.addEventListener('click', (e) => {
        if (!shareMenu.contains(e.target) && e.target !== shareBtn) {
          shareMenu.style.display = 'none';
        }
      });
    }

    // CONTROL WRAPPER (close + likes/dislikes + reads)
// --- CONTROL WRAPPER (close + likes/dislikes + reads) ---
// NOTE: removed the separate "countDisplay" element to avoid duplication.
// Like/dislike counts are shown inside the buttons (.cnt spans).
const controlWrapper = document.createElement('div');
controlWrapper.style.display = 'flex';
controlWrapper.style.alignItems = 'center';
controlWrapper.style.gap = '12px';
controlWrapper.style.margin = '12px 0';

const closeBtn = document.createElement('button');
closeBtn.className = 'jelly-btn';
closeBtn.id = 'closeSerialPreviewBtn';
closeBtn.textContent = 'Close';
controlWrapper.appendChild(closeBtn);

const likeBtn = document.createElement('button');
likeBtn.className = 'jelly-btn';
likeBtn.innerHTML = '👍 <span class="cnt">0</span>';
likeBtn.dataset.state = 'none';
controlWrapper.appendChild(likeBtn);

const dislikeBtn = document.createElement('button');
dislikeBtn.className = 'jelly-btn dislike-btn';
dislikeBtn.innerHTML = '👎 <span class="cnt">0</span>';
dislikeBtn.dataset.state = 'none';
controlWrapper.appendChild(dislikeBtn);

// --- keep reads display as single label ---
// remove any existing duplicate reads element (safe-guard)
const existingReadEl = document.getElementById('readCountDisplay');
if (existingReadEl) existingReadEl.remove();

// --- keep reads display as single label ---


inner.appendChild(controlWrapper);

// --- refreshUI (update only button counts and reads) ---
function refreshUI() {
  serial.likes = Math.max(0, Number(serial.likes || 0));
  serial.dislikes = Math.max(0, Number(serial.dislikes || 0));

  // update counts inside the buttons
  const likeCnt = likeBtn.querySelector('.cnt');
  const dislikeCnt = dislikeBtn.querySelector('.cnt');
  if (likeCnt) likeCnt.textContent = serial.likes;
  if (dislikeCnt) dislikeCnt.textContent = serial.dislikes;

  // update button visual states
  const userChoice = (loadStore(USER_VOTES_KEY)[voteKey]) || 'none';
  likeBtn.dataset.state = (userChoice === 'liked') ? 'liked' : 'none';
  dislikeBtn.dataset.state = (userChoice === 'disliked') ? 'disliked' : 'none';
  likeBtn.style.backgroundColor = likeBtn.dataset.state === 'liked' ? '#dbeafe' : '';
  dislikeBtn.style.backgroundColor = dislikeBtn.dataset.state === 'disliked' ? '#fee2e2' : '';

  // update reads
  const readsNow = (loadStore(READS_KEY)[readKey] || { total: 0 }).total;
  const rDisplay = document.getElementById('readCountDisplay');
  if (rDisplay) rDisplay.textContent = `Reads = ${readsNow}`;
}


    function incrementReadCount(epIndex) {
      const reads = loadStore(READS_KEY);
      reads[readKey] = reads[readKey] || { total: 0, episodes: {} };
      reads[readKey].total++;
      reads[readKey].episodes[epIndex] = (reads[readKey].episodes[epIndex] || 0) + 1;
      saveStore(READS_KEY, reads);
      refreshUI();
    }

    function updateUserVote(newChoice) {
      const votes = loadStore(VOTES_STORE_KEY);
      const user = loadStore(USER_VOTES_KEY);
      votes[voteKey] = votes[voteKey] || { likes: 0, dislikes: 0 };
      const prev = user[voteKey] || 'none';

      if (prev === 'liked') votes[voteKey].likes = Math.max(0, (votes[voteKey].likes||1) - 1);
      if (prev === 'disliked') votes[voteKey].dislikes = Math.max(0, (votes[voteKey].dislikes||1) - 1);

      if (newChoice === 'liked') votes[voteKey].likes = (votes[voteKey].likes||0) + 1;
      if (newChoice === 'disliked') votes[voteKey].dislikes = (votes[voteKey].dislikes||0) + 1;

      user[voteKey] = (newChoice === 'none') ? 'none' : newChoice;

      saveStore(VOTES_STORE_KEY, votes);
      saveStore(USER_VOTES_KEY, user);

      serial.likes = votes[voteKey].likes;
      serial.dislikes = votes[voteKey].dislikes;
      refreshUI();
      try { if (typeof saveSerials === 'function') saveSerials(); } catch(e) {}
    }

    likeBtn.addEventListener('click', function () {
      const current = likeBtn.dataset.state === 'liked' ? 'liked' : (dislikeBtn.dataset.state === 'disliked' ? 'disliked' : 'none');
      if (current === 'liked') updateUserVote('none');
      else updateUserVote('liked');
    });

    dislikeBtn.addEventListener('click', function () {
      const current = dislikeBtn.dataset.state === 'disliked' ? 'disliked' : (likeBtn.dataset.state === 'liked' ? 'liked' : 'none');
      if (current === 'disliked') updateUserVote('none');
      else updateUserVote('disliked');
    });

    const epsWrap = document.createElement('div');
    epsWrap.style.display = 'flex';
    epsWrap.style.flexDirection = 'column';
    epsWrap.style.gap = '10px';

    (serial.episodes || []).forEach((ep, i) => {
      const epCard = document.createElement('div');
      epCard.className = 'story-card';
      epCard.style.display = 'flex';
      epCard.style.justifyContent = 'space-between';
      epCard.style.alignItems = 'center';
      epCard.innerHTML = `
        <div style="max-width:72%">
          <strong>${i+1}. ${(ep.title||('Episode '+(i+1))).replace(/</g,'&lt;')}</strong>
          <div style="font-size:13px;color:var(--muted)">${(ep.description || '').replace(/</g,'&lt;')}</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn btn-primary read-episode-btn">Read Episode</button>
        </div>
      `;
      epCard.querySelector('.read-episode-btn').addEventListener('click', ()=> {
        incrementReadCount(i);
        openSerialReader(serial.title, i);
      });
      epsWrap.appendChild(epCard);
    });

    inner.appendChild(epsWrap);
    panel.appendChild(inner);

    closeBtn.addEventListener('click', ()=> panel.remove());

    refreshUI();
    window.scrollTo(0,0);

  } catch (err) {
    console.error('openSerialPreview error', err);
    alert('Something went wrong opening preview — check console for details.');
  }
}


// Open dedicated fullscreen reader for a serial episode (separate page div)
function openSerialReader(serialTitle, episodeIndex) {
    const saved = loadSavedSerials();
    const serial = (saved || []).find(s => s.title === serialTitle) || (serialsData || []).find(s => s.title === serialTitle);
    if (!serial) { alert('Serial not found'); return; }
    const ep = (serial.episodes || [])[episodeIndex];
    if (!ep) { alert('Episode not found'); return; }

    // --- CREATE PANEL ---
    let panel = document.getElementById('serialReaderFull');
    if (!panel) {
        panel = document.createElement('div');
        panel.id = 'serialReaderFull';
        panel.className = 'reader-full';
        panel.style.position = 'fixed';
        panel.style.top = '0';
        panel.style.left = '0';
        panel.style.width = '100vw';
        panel.style.height = '100vh';
        panel.style.zIndex = '1200';
        panel.style.background = '#f7f7fb';
        panel.style.display = 'flex';
        panel.style.flexDirection = 'column';
        panel.style.overflow = 'hidden';
        document.body.appendChild(panel);
    }
    panel.innerHTML = '';

    // --- HEADER ---
    const header = document.createElement('div');
    header.className = 'reader-header';
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    header.style.flexShrink = '0';
    header.style.padding = '12px 18px';
    header.style.background = '#fff';
    header.innerHTML = `
        <div><button class="btn btn-secondary" id="backToSerialBtn">← Back</button></div>
        <div style="text-align:center;flex:1">
            <h2 style="margin:6px 0;font-size:16px">${serial.title} — ${ep.title}</h2>
            <div class="muted" style="font-size:12px">${serial.genre || '—'} • ${ep.description || ''}</div>
        </div>
        <div style="width:120px;visibility:hidden"></div>
    `;

    // --- BODY ---
    const body = document.createElement('div');
    body.className = 'reader-body';
    body.style.flex = '1';
    body.style.overflowY = 'auto';
    body.style.padding = '12px';
    body.style.display = 'flex';
    body.style.flexDirection = 'column';
    body.style.alignItems = 'center';
    body.style.justifyContent = 'flex-start';

    const sheetsArray = (ep.sheets || []).map(s => (typeof s === 'string') ? { content: s } : (s.content ? s : { content: s }));
    const totalPages = Math.max(1, sheetsArray.length || 1);
    let currentPage = 0;

    // --- PAGE WRAP & BOX ---
    const pageWrap = document.createElement('div');
    pageWrap.style.display = 'flex';
    pageWrap.style.flexDirection = 'column';
    pageWrap.style.alignItems = 'center';
    pageWrap.style.width = '100%';
    pageWrap.style.boxSizing = 'border-box';

    const pageBox = document.createElement('div');
    pageBox.className = 'reader-sheet';
    pageBox.style.width = '100%';
    pageBox.style.maxWidth = '880px';
    pageBox.style.minHeight = '540px';
    pageBox.style.margin = '20px auto';
    pageBox.style.padding = '30px 35px';
    pageBox.style.background = 'linear-gradient(135deg, #fffef9 0%, #fdf8e4 100%)';
    pageBox.style.border = '1px solid #e5d7b7';
    pageBox.style.borderRadius = '12px';
    pageBox.style.boxShadow = '0 8px 16px rgba(0,0,0,0.1)';
    pageBox.style.boxSizing = 'border-box';
    pageBox.style.fontFamily = `'Georgia', 'Times New Roman', serif`;
    pageBox.style.fontSize = '16px';
    pageBox.style.lineHeight = '1.7';
    pageBox.style.color = '#2e2b23';
    pageBox.style.textAlign = 'justify';
    pageBox.style.letterSpacing = '0.3px';
    pageBox.style.whiteSpace = 'pre-wrap';
    pageBox.style.overflowWrap = 'break-word';
    pageBox.style.position = 'relative';
    pageBox.style.transition = 'all 0.3s ease';

    // --- PAGER ROW ---
    const pagerRow = document.createElement('div');
    pagerRow.style.display = 'flex';
    pagerRow.style.flexWrap = 'wrap';
    pagerRow.style.alignItems = 'center';
    pagerRow.style.justifyContent = 'center';
    pagerRow.style.gap = '6px';
    pagerRow.style.marginTop = '12px';

    const prevPageBtn = document.createElement('button');
    prevPageBtn.className = 'btn btn-secondary';
    prevPageBtn.textContent = '◀ Prev Page';

    const pageIndicator = document.createElement('div');
    pageIndicator.className = 'muted';
    pageIndicator.style.minWidth = '80px';
    pageIndicator.style.textAlign = 'center';
    pageIndicator.style.fontSize = '14px';

    const nextPageBtn = document.createElement('button');
    nextPageBtn.className = 'btn btn-primary';
    nextPageBtn.textContent = 'Next Page ▶';

    const markLastReadBtn = document.createElement('button');
    markLastReadBtn.className = 'btn btn-warning';
    markLastReadBtn.textContent = 'Mark Last Read';

    const completeMarkBtn = document.createElement('button');
    completeMarkBtn.className = 'btn btn-success';
    completeMarkBtn.textContent = 'Complete Mark';
    completeMarkBtn.style.display = 'none';

    const removeMarkBtn = document.createElement('button');
    removeMarkBtn.className = 'btn btn-danger';
    removeMarkBtn.textContent = 'Remove Last Mark';
    removeMarkBtn.style.display = 'inline-block';

    // --- SMALL BUTTON STYLE ---
    function styleButton(btn) {
        btn.style.padding = '6px 10px';
        btn.style.fontSize = '14px';
        btn.style.borderRadius = '6px';
        btn.style.minWidth = 'auto';
    }
    [prevPageBtn, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn].forEach(styleButton);

    pagerRow.append(prevPageBtn, pageIndicator, nextPageBtn, markLastReadBtn, completeMarkBtn, removeMarkBtn);
    pageWrap.append(pageBox, pagerRow);
    body.appendChild(pageWrap);

    // --- DRAWING CANVAS ---
    const marksPerPage = {};
    let drawCanvas = null;
    let drawContext = null;

    function enableDrawing(canvas, context) {
        let isDrawing = false;
        let lastX = 0, lastY = 0;

        // Desktop
        canvas.addEventListener('mousedown', e => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        });
        canvas.addEventListener('mousemove', e => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            lastX = x;
            lastY = y;
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Mobile / Touch
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.touches[0].clientX - rect.left;
            lastY = e.touches[0].clientY - rect.top;
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(x, y);
            context.stroke();
            lastX = x;
            lastY = y;
        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);
        canvas.addEventListener('touchcancel', () => isDrawing = false);
    }

    markLastReadBtn.addEventListener('click', () => {
        if (!drawCanvas) {
            drawCanvas = document.createElement('canvas');
            drawCanvas.style.position = 'absolute';
            drawCanvas.style.top = '0';
            drawCanvas.style.left = '0';
            drawCanvas.style.width = '100%';
            drawCanvas.style.height = '100%';
            drawCanvas.width = pageBox.clientWidth;
            drawCanvas.height = pageBox.clientHeight;
            drawCanvas.style.zIndex = 5;
            drawCanvas.style.pointerEvents = 'auto';
            drawCanvas.style.cursor = 'crosshair';
            pageBox.appendChild(drawCanvas);

            drawContext = drawCanvas.getContext('2d');
            drawContext.strokeStyle = 'rgba(0,0,0,0.7)';
            drawContext.lineWidth = 2;

            // Restore previous marks
            if (marksPerPage[currentPage]) {
                const img = new Image();
                img.onload = () => drawContext.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height);
                img.src = marksPerPage[currentPage];
            }

            enableDrawing(drawCanvas, drawContext);
        }
        completeMarkBtn.style.display = 'inline-block';
    });

    completeMarkBtn.addEventListener('click', () => {
        if (drawCanvas) {
            marksPerPage[currentPage] = drawCanvas.toDataURL();
            drawCanvas.style.pointerEvents = 'none';
        }
        completeMarkBtn.style.display = 'none';
    });

    removeMarkBtn.addEventListener('click', () => {
        if (drawCanvas) {
            drawCanvas.remove();
            drawCanvas = null;
            drawContext = null;
        }
        delete marksPerPage[currentPage];
        completeMarkBtn.style.display = 'none';
    });

    // --- RENDER PAGE FUNCTION ---
    function renderPage(idx) {
        currentPage = Math.max(0, Math.min(idx, totalPages - 1));
        const sheetObj = sheetsArray[currentPage] || { content: '(No content in this page)' };

        if (typeof sheetObj.content === 'string' && /<[a-z][\s\S]*>/i.test(sheetObj.content)) {
            pageBox.innerHTML = sheetObj.content;
        } else {
            pageBox.textContent = sheetObj.content || '(No content in this page)';
        }

        pageIndicator.textContent = `Page ${currentPage + 1} / ${totalPages}`;
        prevPageBtn.disabled = currentPage === 0;
        nextPageBtn.disabled = currentPage === totalPages - 1;

        if (drawCanvas) {
            drawCanvas.remove();
            drawCanvas = null;
            drawContext = null;
            completeMarkBtn.style.display = 'none';
            removeMarkBtn.style.display = 'none';
        }

        if (marksPerPage[currentPage] && !drawCanvas) {
            drawCanvas = document.createElement('canvas');
            drawCanvas.style.position = 'absolute';
            drawCanvas.style.top = 0;
            drawCanvas.style.left = 0;
            drawCanvas.style.width = '100%';
            drawCanvas.style.height = '100%';
            drawCanvas.width = pageBox.clientWidth;
            drawCanvas.height = pageBox.clientHeight;
            drawCanvas.style.zIndex = 5;
            drawCanvas.style.pointerEvents = 'none';
            pageBox.appendChild(drawCanvas);
            drawContext = drawCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => drawContext.drawImage(img, 0, 0, drawCanvas.width, drawCanvas.height);
            img.src = marksPerPage[currentPage];
        }
    }

    prevPageBtn.addEventListener('click', () => renderPage(currentPage - 1));
    nextPageBtn.addEventListener('click', () => renderPage(currentPage + 1));
    if (sheetsArray.length === 0) sheetsArray.push({ content: '(No content in this episode yet)' });
    renderPage(0);

    // --- FOOTER ---
    const footer = document.createElement('div');
    footer.style.display = 'flex';
    footer.style.justifyContent = 'center';
    footer.style.flexWrap = 'wrap';
    footer.style.gap = '6px';
    footer.style.padding = '12px';
    footer.style.flexShrink = 0;
    footer.style.background = '#fff';

    const prevBtn = document.createElement('button');
    prevBtn.className = 'btn btn-secondary';
    prevBtn.textContent = '◀ Prev Episode';

    const nextBtn = document.createElement('button');
    nextBtn.className = 'btn btn-primary';
    nextBtn.textContent = 'Next Episode ▶';

    [prevBtn, nextBtn].forEach(styleButton);

    footer.append(prevBtn, nextBtn);
    panel.append(header, body, footer);

    document.getElementById('backToSerialBtn').addEventListener('click', () => {
        panel.remove();
        openSerialPreview(serialTitle);
    });

    prevBtn.addEventListener('click', () => {
        if (episodeIndex > 0) openSerialReader(serialTitle, episodeIndex - 1);
    });

    nextBtn.addEventListener('click', () => {
        if (episodeIndex < (serial.episodes || []).length - 1) openSerialReader(serialTitle, episodeIndex + 1);
    });

    window.scrollTo(0, 0);
}

// --- DOMContentLoaded Hook --- document.addEventListener('DOMContentLoaded', ()=>{ const browseSerialsBtn = document.getElementById('browseSerialsBtn'); if(browseSerialsBtn){ browseSerialsBtn.addEventListener('click', ()=>{ const welcomePage = document.getElementById('welcomePage'); if(welcomePage) welcomePage.classList.add('hidden'); const serialPage = document.getElementById('serialCategoriesPage'); if(serialPage) serialPage.classList.remove('hidden'); renderBrowseSerials(loadSavedSerials()); }); } if(document.getElementById('serialCategoriesPage') && !document.getElementById('serialsBrowseList')){ renderBrowseSerials(loadSavedSerials()); } }); // --- Optional: Sync serialsData push --- (function(){ try{ if(Array.prototype._origSerialPush == null){ Array.prototype._origSerialPush = Array.prototype.push; } if(window.serialsData && window.serialsData.push){ const orig = window.serialsData.push; window.serialsData.push = function(){ const res = orig.apply(this, arguments); try{ syncSerialsToStorage(); }catch(e){} return res; }; } }catch(e){} })();
// --- Optional: Sync serialsData push ---
(function(){
  try{
    if(Array.prototype._origSerialPush == null){
      Array.prototype._origSerialPush = Array.prototype.push;
    }
    if(window.serialsData && window.serialsData.push){
      const orig = window.serialsData.push;
      window.serialsData.push = function(){
        const res = orig.apply(this, arguments);
        try{ syncSerialsToStorage(); }catch(e){}
        return res;
      };
    }
  }catch(e){}
})();

// Also call sync after some known buttons if they exist
setTimeout(()=>{
  if(window.serialCreateConfirmBtn){
    serialCreateConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
  if(window.addEpConfirmBtn){
    addEpConfirmBtn.addEventListener('click', ()=> setTimeout(syncSerialsToStorage, 500) );
  }
}, 800);

</script>
<!-- END: SERIALS EXTENSION INJECTION -->

<!-- START: Auto-Injected Serial READs & Download Augmentation -->
<script>
(function(){
  // Helper: stable key for serial (using title)
  function serialKey(title) {
    return 'serial_reads_' + (title || 'unknown').replace(/\s+/g,'_').toLowerCase();
  }

  // Persisted storage helpers
  function loadCounts(key) {
    try {
      const raw = localStorage.getItem(key);
      return raw ? JSON.parse(raw) : {};
    } catch(e){ return {}; }
  }
  function saveCounts(key, obj) {
    try { localStorage.setItem(key, JSON.stringify(obj)); } catch(e){}
  }

  // Download helper
  function downloadJSON(filename, obj) {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(obj, null, 2));
    const a = document.createElement('a');
    a.setAttribute('href', dataStr);
    a.setAttribute('download', filename);
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Try to detect serial preview containers added to DOM.
  const observer = new MutationObserver(mutations => {
    for (const m of mutations) {
      for (const node of m.addedNodes) {
        if (!(node instanceof HTMLElement)) continue;
        // Detect likely serial preview by common heuristics: header with <h1>, description, and multiple episode cards/lists.
        const h1 = node.querySelector && (node.querySelector('h1') || node.querySelector('.serial-title') || node.querySelector('.title'));
        const episodes = node.querySelectorAll && (node.querySelectorAll('.episode, .ep, .story-card, .episode-card, .ep-card') || []);
        // episodes NodeList may be empty; we will further search inside for lists
        const potentialEpisodeItems = node.querySelectorAll('li, .episode, .story-card, .episode-card, .ep-card');
        const epCount = potentialEpisodeItems.length;
        if (h1 && (epCount > 0 || node.querySelectorAll('.episode').length>0)) {
          enhanceSerialPreview(node);
        } else {
          // Some previews might use a wrapper with class 'serial-preview' or id 'serialPreview'
          if (node.matches && (node.matches('.serial-preview') || node.id === 'serialPreview')) {
            enhanceSerialPreview(node);
          }
        }
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });

  // Also attempt to enhance already-present preview on page load (in case it exists)
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const previews = document.querySelectorAll('.serial-preview, [data-serial-preview], #serialPreview');
      if (previews.length) previews.forEach(enhanceSerialPreview);
      // Fallback: find containers with h1 and multiple story-card children
      const nodes = Array.from(document.querySelectorAll('div, section'));
      for (const n of nodes) {
        const h1 = n.querySelector && (n.querySelector('h1') || n.querySelector('.serial-title'));
        const items = n.querySelectorAll && n.querySelectorAll('.story-card, .episode, li').length;
        if (h1 && items>0) enhanceSerialPreview(n);
      }
    }, 500);
  });

  // Main enhancer function
  function enhanceSerialPreview(container){
    try {
      // Avoid double-enhancing
      if (container.__readsEnhanced) return;
      container.__readsEnhanced = true;

      // Locate serial title, genre, description
      const titleEl = container.querySelector('h1') || container.querySelector('.serial-title') || container.querySelector('.title');
      const title = titleEl ? titleEl.textContent.trim() : 'untitled_serial';
      const key = serialKey(title);

      // Find or create the READ total label under header
      let readsLabel = container.querySelector('#serialReadsLabel');
      if (!readsLabel) {
        readsLabel = document.createElement('div');
        readsLabel.id = 'serialReadsLabel';
        readsLabel.style.fontWeight = '700';
        readsLabel.style.marginTop = '8px';
        // Prefer to insert after the title or after a header block
        if (titleEl && titleEl.parentElement) {
          titleEl.parentElement.appendChild(readsLabel);
        } else {
          container.insertBefore(readsLabel, container.firstChild);
        }
      }


      // Load counts from storage
      const counts = loadCounts(key);

      // Identify episode elements (best-effort)
      let episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .ep-card, .story-card, li'));
      // Filter out container-level lists that are not episodes by checking for a 'Read' button inside or 'Start Reading' text
      episodeEls = episodeEls.filter(el => {
        const txt = (el.textContent||'').toLowerCase();
        const hasReadBtn = !!el.querySelector('button, a');
        return txt.length<10000 && (hasReadBtn || txt.includes('episode') || txt.includes('start reading') || txt.includes('read'));
      });

      // If nothing found, try direct children
      if (episodeEls.length === 0) {
        const list = container.querySelectorAll('ul > li, ol > li');
        episodeEls = Array.from(list);
      }

      // Add per-episode UI
      episodeEls.forEach((epEl, idx) => {
        // Avoid double-insert
        if (epEl.querySelector('.read-count-badge')) return;

        // Determine an episode title
        const epTitleEl = epEl.querySelector('h3, h4, .ep-title, .title') || epEl.querySelector('strong') || epEl;
        const epTitle = epTitleEl ? (epTitleEl.textContent || '').trim().substring(0,120) : ('Episode ' + (idx+1));

        // Ensure reads value exists
        if (typeof counts[idx] !== 'number') counts[idx] = counts[idx] || 0;

        // Create read badge
        const badge = document.createElement('span');
        badge.className = 'read-count-badge';
        badge.style.marginLeft = '8px';
        badge.style.fontWeight = '700';
        badge.style.fontSize = '13px';
        badge.textContent = 'Reads = ' + (counts[idx]||0);

        // Append badge near title or at the end
        if (epTitleEl && epTitleEl.parentElement) {
          epTitleEl.parentElement.appendChild(badge);
        } else {
          epEl.appendChild(badge);
        }

        // Wire the episode's "Read" or "Start Reading" button to increment the count
        // Search for button-like elements
        const candidateBtns = Array.from(epEl.querySelectorAll('button, a'));
        let readBtn = candidateBtns.find(b => /read|start reading|open/i.test((b.textContent||'')));
        if (!readBtn && candidateBtns.length) readBtn = candidateBtns[0];

        if (readBtn) {
          readBtn.addEventListener('click', (ev) => {
            // Increment count and save
            counts[idx] = (counts[idx] || 0) + 1;
            saveCounts(key, counts);
            // Update badge and total label
            badge.textContent = 'READ = ' + counts[idx];
            updateTotalLabel(container, counts);
            // allow other handlers to run
            setTimeout(()=>{},0);
          });
        }
      });

      // Save counts back (initial)
      saveCounts(key, counts);
      updateTotalLabel(container, counts);
    } catch(e){
      console.error('enhanceSerialPreview error', e);
    }
  }

  function updateTotalLabel(container, counts) {
    const total = (Array.isArray(counts) ? counts.reduce((a,b)=>a+(b||0),0) : Object.values(counts).reduce((a,b)=>a+(b||0),0));
    let lbl = container.querySelector('#serialReadsLabel');
    if (!lbl) {
      lbl = document.createElement('div');
      lbl.id = 'serialReadsLabel';
      lbl.style.fontWeight = '700';
      lbl.style.marginTop = '8px';
      if (container.querySelector('h1')) container.querySelector('h1').parentElement.appendChild(lbl);
      else container.appendChild(lbl);
    }
    lbl.textContent = 'Reads = ' + total;
  }

  // Build a best-effort serial JSON from the DOM preview (title, genre, description, episodes text)
  function buildSerialJSON(container) {
    const title = (container.querySelector('h1') || container.querySelector('.serial-title') || {textContent:'Untitled'}).textContent.trim();
    const genre = (container.querySelector('.genre') || container.querySelector('[data-genre]') || {textContent:''}).textContent.trim();
    const desc = (container.querySelector('.description') || container.querySelector('.serial-description') || {textContent:''}).textContent.trim();
    const episodes = [];
    const episodeEls = Array.from(container.querySelectorAll('.episode, .episode-card, .story-card, li'));
    episodeEls.forEach((el, idx) => {
      const epTitle = (el.querySelector('h3, h4, .ep-title') || el.querySelector('strong') || {textContent:('Episode '+(idx+1))}).textContent.trim();
      const body = (el.querySelector('.body, p') || el).textContent.trim();
      // load counts
      const key = 'serial_reads_' + title.replace(/\s+/g,'_').toLowerCase();
      let counts = {};
      try { counts = JSON.parse(localStorage.getItem(key) || '{}'); } catch(e){}
      const reads = counts[idx] || 0;
      episodes.push({ title: epTitle, body: body, reads: reads });
    });
    return { title, genre, description: desc, episodes };
  }

    })();

  // Additional UI tweaks:
  // 1) If both Close and Download buttons exist in a preview, swap their positions so Close is where Download was and vice versa.
  function swapPreviewButtons(container) {
    try {
      const closeBtn = container.querySelector('#closeSerialPreviewBtn') || Array.from(container.querySelectorAll('button')).find(b => /close/i.test(b.textContent||''));
      const downloadBtn = container.querySelector('#downloadSerialBtn') || Array.from(container.querySelectorAll('button')).find(b => /download serial/i.test(b.textContent||''));
      if (closeBtn && downloadBtn && closeBtn.parentElement && downloadBtn.parentElement) {
        const closeParent = closeBtn.parentElement;
        const downloadParent = downloadBtn.parentElement;
        // Swap by replacing nodes
        const closeClone = closeBtn.cloneNode(true);
        const downloadClone = downloadBtn.cloneNode(true);
        closeClone.id = closeBtn.id || 'closeSerialPreviewBtn_clone';
        downloadClone.id = downloadBtn.id || 'downloadSerialBtn_clone';
        // replace
        closeParent.replaceChild(downloadClone, closeBtn);
        downloadParent.replaceChild(closeClone, downloadBtn);
        // reattach listeners if any by clicking behaviors (best-effort: forward click to original behavior)
        downloadClone.addEventListener('click', function(e){ downloadBtn.click && downloadBtn.click(); });
        closeClone.addEventListener('click', function(e){ closeBtn.click && closeBtn.click(); });
      }
    } catch(e){console.warn('swapPreviewButtons failed', e);}
  }

 
  // Run these helpers when new previews are detected and on DOMContentLoaded
  const extraObserver = new MutationObserver(muts => {
    muts.forEach(m => {
      m.addedNodes.forEach(n => {
        if (!(n instanceof HTMLElement)) return;
        // If a preview or header added, attempt swap
        if (n.querySelector && (n.querySelector('#downloadSerialBtn') || n.querySelector('#closeSerialPreviewBtn') || n.querySelector('h1'))) {
          swapPreviewButtons(n);
        }
      });
    });
    // Also attempt to ensure Back button on any mutation
    ensureBrowseBackButton();
  });
  extraObserver.observe(document.body, { childList: true, subtree: true });

  document.addEventListener('DOMContentLoaded', () => {
    // Try swapping in already-present previews
    const previews = document.querySelectorAll('.serial-preview, #serialPreview, .preview-modal, .story-preview');
    previews.forEach(p => swapPreviewButtons(p));
    ensureBrowseBackButton();
    // Also attempt a second pass after a short delay
    setTimeout(()=>{ previews.forEach(p => swapPreviewButtons(p)); ensureBrowseBackButton(); }, 800);
  });

</script>
<!-- END: Auto-Injected Serial READs & Download Augmentation -->
  <!-- existing app scripts -->
  <script>
// ---------- Tags helpers (insert near other helpers) ----------

// create a tag "chip" element
function makeTagChip(tagText) {
  const chip = document.createElement('div');
  chip.className = 'tag-chip';
  chip.style.cssText = 'display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid #e5e7eb;font-weight:600';
  chip.innerHTML = `<span class="tag-label">${tagText}</span><button type="button" class="tag-remove" title="Remove tag" style="background:transparent;border:0;cursor:pointer;font-weight:700">✕</button>`;
  chip.querySelector('.tag-remove').addEventListener('click', () => chip.remove());
  return chip;
}

// add one tag from an input to a container (prevents duplicates, trims)
function addTagFromInput(inputEl, containerEl) {
  if (!inputEl || !containerEl) return;
  const raw = (inputEl.value || '').trim();
  if (!raw) return inputEl.value = '';

  // support comma-separated tags (e.g. "apple, banana")
  const parts = raw.split(',').map(s => s.trim()).filter(Boolean);

  parts.forEach(v => {
    // prevent duplicates (case-insensitive)
    const exist = Array.from(containerEl.querySelectorAll('.tag-label'))
      .some(n => n.textContent.toLowerCase() === v.toLowerCase());
    if (exist) return;
    const chip = makeTagChip(v);
    containerEl.appendChild(chip);
  });

  inputEl.value = '';
  inputEl.focus();
}

// return array of tag texts from a container
function getTagsFromContainer(containerEl) {
  if (!containerEl) return [];
  return Array.from(containerEl.querySelectorAll('.tag-label')).map(n => n.textContent.trim()).filter(Boolean);
}

// clear container and set tags (useful when loading an existing story/serial)
function setTagsToContainer(containerEl, tagsArray) {
  if (!containerEl) return;
  containerEl.innerHTML = '';
  (Array.isArray(tagsArray) ? tagsArray : []).forEach(t => {
    if (!t) return;
    const chip = makeTagChip(t);
    containerEl.appendChild(chip);
  });
}

// wire inputs/buttons: inputEl = <input>, btnEl = add button, containerEl = tags container
function wireTagInput(inputEl, btnEl, containerEl) {
  if (!inputEl || !btnEl || !containerEl) return;

  // add click handler
  btnEl.addEventListener('click', () => addTagFromInput(inputEl, containerEl));

  // add Enter handler on input
  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    } else if (e.key === ',' && e.ctrlKey) {
      // optional: ctrl+, to quickly add current value
      e.preventDefault();
      addTagFromInput(inputEl, containerEl);
    }
  });

  // handle paste of multiple tags (comma-separated)
  inputEl.addEventListener('paste', (ev) => {
    const text = (ev.clipboardData || window.clipboardData).getData('text');
    if (text && text.includes(',')) {
      ev.preventDefault();
      inputEl.value = text;
      addTagFromInput(inputEl, containerEl);
    }
  });
}

// convenience initialiser — automatically finds the elements you added earlier
function initTagsUI() {
  try {
    const storyInput = document.getElementById('storyTagInput');
    const storyBtn = document.getElementById('addStoryTagBtn');
    const storyCont = document.getElementById('storyTagsContainer');

    const seriesInput = document.getElementById('seriesTagInput');
    const seriesBtn = document.getElementById('addSeriesTagBtn');
    const seriesCont = document.getElementById('seriesTagsContainer');

    if (storyInput && storyBtn && storyCont) wireTagInput(storyInput, storyBtn, storyCont);
    if (seriesInput && seriesBtn && seriesCont) wireTagInput(seriesInput, seriesBtn, seriesCont);

    // If you want to pre-load tags when editing, call setTagsToContainer(container, tagsArray)
    // Example:
    // setTagsToContainer(storyCont, existingStory.tags || []);

  } catch (err) {
    console.warn('initTagsUI error', err);
  }
}

// call init on DOM ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initTagsUI);
} else {
  initTagsUI();
}

// ---- Helpers to attach tags to your payloads before save/publish ----

// Usage: before saving/publishing a story, do:
// const story = { title: ..., content: ... };
// attachStoryTagsToPayload(story);
// then save story object
function attachStoryTagsToPayload(payload) {
  const c = document.getElementById('storyTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// Usage for series/serial create flow:
// const series = { title: ..., desc: ... };
// attachSeriesTagsToPayload(series);
function attachSeriesTagsToPayload(payload) {
  const c = document.getElementById('seriesTagsContainer');
  if (!payload) payload = {};
  payload.tags = getTagsFromContainer(c);
  return payload;
}

// ---- Small CSS helper (optional) ----
// If you prefer to add styles inside a <style> tag, here's a compact rule you can paste into your CSS:
const tagChipStyle = `
.tag-chip { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:#f3f4f6; border:1px solid #e5e7eb; font-weight:600; margin:2px; }
.tag-chip .tag-remove { cursor:pointer; font-weight:700; padding-left:6px; }
`;
// inject style once (non-destructive)
if (!document.getElementById('meurbal-tagchip-styles')) {
  const s = document.createElement('style');
  s.id = 'meurbal-tagchip-styles';
  s.textContent = tagChipStyle;
  document.head.appendChild(s);
}

    // your main app code ...
  </script>

  <!-- ✅ Add this line for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js">
// ---- Inject cover background in browse stories ----
function applyCoverToStoryCards() {
  document.querySelectorAll('#storiesCards .story-card').forEach(card => {
    const title = card.querySelector('h2')?.innerText?.trim();
    if (!title) return;
    const story = (window.storiesData || []).find(s => s.title === title);
    if (story && story.cover) {
      card.style.backgroundImage = `url(${story.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}



// ---- Enhanced cover display for Browse Stories ----
function renderStoryCardsWithCovers(storiesArray) {
  const container = document.getElementById('storiesCards');
  if (!container) return;
  container.innerHTML = '';
  (storiesArray || []).forEach(story => {
    const storyCard = document.createElement('div');
    storyCard.className = 'story-card';
    storyCard.innerHTML = `<h2>${story.title}</h2><p>${story.genre || ''}</p>`;

    if (story.cover) {
      storyCard.style.backgroundImage = `url(${story.cover})`;
      storyCard.style.backgroundSize = 'cover';
      storyCard.style.backgroundPosition = 'center';
      storyCard.style.color = '#fff';
    }

    container.appendChild(storyCard);
  });
}

// Automatically override story browsing behavior
window._oldRenderStories = window.renderStories;
window.renderStories = function() {
  if (typeof window._oldRenderStories === 'function') window._oldRenderStories();
  try {
    renderStoryCardsWithCovers(window.storiesData || []);
  } catch (e) { console.warn('Cover apply failed:', e); }
};

// Run once on page load in case stories are already shown
document.addEventListener('DOMContentLoaded', () => renderStoryCardsWithCovers(window.storiesData || []));


// Apply covers to serial cards in browse serials (runs after serials rendered)
function applySerialCovers() {
  // serialCategoriesGrid might contain cat cards; serial listing rendering may be elsewhere.
  // We'll scan serialsData and update any card elements that have data-title attribute matching serial title.
  document.querySelectorAll('.serial-card').forEach(card => {
    const title = card.dataset.title;
    if (!title) return;
    const ser = (window.serialsData || []).find(s => s.title === title);
    if (ser && ser.cover) {
      card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.35)), url(${ser.cover})`;
      card.style.backgroundSize = 'cover';
      card.style.backgroundPosition = 'center';
      card.style.color = '#fff';
    }
  });
}
document.addEventListener('DOMContentLoaded', () => setTimeout(applySerialCovers, 300));
// === TESTING ONLY ===
// Generates 100 random serials with varying popularity, genres, and recency
function generateFakeSerials(count = 100) {
  const genres = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Thriller","Adventure","Crime","Historic"];
  const covers = [
    "https://picsum.photos/seed/serial1/500/700",
    "https://picsum.photos/seed/serial2/500/700",
    "https://picsum.photos/seed/serial3/500/700",
    "https://picsum.photos/seed/serial4/500/700",
    "https://picsum.photos/seed/serial5/500/700"
  ];

  const randomDate = () => {
    const daysAgo = Math.floor(Math.random() * 365); // up to 1 year old
    const date = new Date(Date.now() - daysAgo * 86400000);
    return date.toISOString();
  };

  const serials = [];
  for (let i = 0; i < count; i++) {
    const genre = genres[Math.floor(Math.random() * genres.length)];
    const title = `${genre} Serial #${i + 1}`;
    const views = Math.floor(Math.random() * 10000);
    const likes = Math.floor(Math.random() * 500);
    const votes = Math.floor(Math.random() * 200);
    const cover = covers[Math.floor(Math.random() * covers.length)];
    const description = `A ${genre.toLowerCase()} story full of twists, heroes, and heart. Random ID ${i}.`;

    serials.push({
      id: i + 1,
      title,
      genre,
      description,
      views,
      likes,
      votes,
      cover,
      createdAt: randomDate()
    });
  }

  return serials;
}

// === CALL THIS TO TEST ===
function testSerialAlgorithm() {
  const fakeList = generateFakeSerials(100);
  renderBrowseSerials(fakeList);
  console.log("✅ Generated 100 fake serials and rendered using new algorithm.");
}

// Run automatically for quick testing (you can remove this after testing)
document.addEventListener('DOMContentLoaded', () => {
  testSerialAlgorithm();
});

</script>
</body>
</html>

</body>
</html>
