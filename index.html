<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Maurbal - Your Hiring Platform</title>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<style>
  :root{
    --primary:#0077ff;
    --primary-2:#2aa0ff;
    --accent:#ff6a00;
    --danger:#ff3333;
    --bg:#f4f7fb;
    --card-bg:#ffffff;
    --muted:#6b7280;
    --glass: rgba(255,255,255,0.6);
  }

  html,body{height:100%; margin:0; padding:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#111;}
  .page{ display:none; min-height:100vh; box-sizing:border-box; padding:28px; }

  #home {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 0;
  }
#savedProfilesPage h2 {
  text-align: center;
  margin-top: 0;
  margin-bottom: 16px;
}


  .menu-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    gap: 22px;
    align-items: center;
  }

  .menu-container button{
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    border: none;
    border-radius: 14px;
    padding: 14px 32px;
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    box-shadow: 0 10px 28px rgba(0, 0, 0, 0.12);
    transition: all 0.25s ease;
}
    min-width:260px;
    font-size:18px;
    padding:12px 32px;
    border-radius:12px;
    border:none;
    cursor:pointer;
    font-weight:700;
    letter-spacing:0.2px;
    background: linear-gradient(90deg,var(--primary),var(--primary-2));
    color:#fff;
    box-shadow: 0 10px 30px rgba(34,120,255,0.12);
    transition: transform .22s ease, box-shadow .22s;
  }
  .menu-container button:hover{ transform: translateY(-4px); box-shadow: 0 16px 40px rgba(34,120,255,0.16); }

  button { font-family: inherit; }

  .back-btn{
    position:fixed;
    bottom:20px;
    left:20px;
    background:var(--danger);
    color:#fff;
    padding:10px 20px;
    border-radius:10px;
    border:none;
    cursor:pointer;
    font-weight:bold;
    box-shadow:0 6px 16px rgba(0,0,0,0.12);
  }

  /* Categories page */
  #categoriesPage h2{
    text-align:center;
    margin-top:0;
    margin-bottom:16px;
  }
  .categories{
    display:flex;
    justify-content:center;
    gap:12px;
    margin-bottom:18px;
    flex-wrap:wrap;
  }
  .category{
    background:#fff;
    padding:10px 18px;
    border-radius:999px;
    box-shadow:0 6px 18px rgba(12,40,80,0.06);
    cursor:pointer;
    font-weight:600;
    transition: background .2s, transform .12s;
  }
  .category:hover{ transform: translateY(-4px); }

  .search-bar{ display:flex; justify-content:center; margin-bottom:20px; }
  .search-bar input{
    width:50%;
    max-width:520px;
    padding:12px 14px;
    border:1px solid #e6eefc;
    border-radius:12px;
    font-size:16px;
    box-shadow: 0 6px 20px rgba(18,40,80,0.04);
  }

  .profile-list{ display:flex; flex-direction:column; gap:12px; padding-bottom:80px; }
  .profile-box{
    background:linear-gradient(180deg,#ffffff, #fbfdff);
    color:#111;
    padding:18px;
    border-radius:14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:18px;
    box-shadow: 0 8px 28px rgba(14,30,70,0.06);
  }
  .profile-box button {
    background: linear-gradient(90deg,#28a745,#66cc66);
    color:#fff;
    border:none;
    border-radius:12px;
    padding:8px 16px;
    font-size:14px;
    cursor:pointer;
    font-weight:700;
    box-shadow:0 6px 18px rgba(34,120,255,0.06);
    transition:transform .18s, box-shadow .18s;
  }
  .profile-box button:hover {
    transform:translateY(-3px);
    box-shadow:0 10px 26px rgba(34,120,255,0.08);
  }

  .save-btn {
    margin-left: 12px;
    cursor: pointer;
    font-size: 20px;
    user-select:none;
  }
  .saved { color: gold; }

  /* Create Profile form */
  #createProfilePage h2{ text-align:center; margin-bottom:14px; }
  form{
    display:flex;
    flex-direction:column;
    gap:12px;
    max-width:520px;
    margin:auto;
    background:#fff;
    padding:20px;
    border-radius:12px;
    box-shadow:0 6px 24px rgba(14,30,70,0.06);
  }
  input,select,textarea{
    padding:12px;
    font-size:16px;
    border-radius:8px;
    border:1px solid #e8eefb;
  }
  input:focus,select:focus,textarea:focus{ border-color:var(--primary); outline:none; box-shadow:0 8px 20px rgba(42,160,255,0.06); }
  .note{ font-size:13px; color:var(--muted); }

  form button[type="submit"] {
    background: linear-gradient(90deg,var(--accent),#ff3c82);
    font-size:18px;
    font-weight:800;
    border:none;
    border-radius:12px;
    color:#fff;
    padding:12px;
    cursor:pointer;
    box-shadow:0 10px 28px rgba(255,80,120,0.08);
    transition:transform .16s, box-shadow .16s;
  }
  form button[type="submit"]:hover {
    transform:scale(1.02);
    box-shadow:0 14px 38px rgba(255,80,120,0.12);
  }

  /* Redesigned open profile card */
  .open-profile{
    background: linear-gradient(180deg,#0f172a 0%, #071229 60%);
    color:#fff;
    padding:22px;
    max-width:820px;
    margin:28px auto;
    border-radius:18px;
    box-shadow: 0 18px 40px rgba(3,9,23,0.6);
    position:relative;
    text-align:left;
    overflow:hidden;
  }
  .open-profile .close-btn{
    position:absolute;
    top:14px; right:14px;
    background:transparent;
    color:#fff;
    border:none;
    padding:8px;
    border-radius:8px;
    cursor:pointer;
    font-size:18px;
    background: rgba(255,255,255,0.06);
  }
  .profile-header{
    display:flex;
    gap:18px;
    align-items:center;
  }
  .avatar{
    width:96px; height:96px; border-radius:18px;
    background: linear-gradient(135deg,#1e3a8a,#0ea5a6);
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:28px; color:#fff;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  .profile-head-info h3{ margin:0 0 6px 0; font-size:24px; letter-spacing:0.2px; }
  .profile-meta{ display:flex; gap:8px; align-items:center; }
  .skill-badge{
    background: rgba(255,255,255,0.06);
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
  }
  .status-badge{
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
    background: rgba(255,255,255,0.06);
  }
  .profile-body{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:14px;
    margin-top:18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:14px;
    border-radius:12px;
  }
  .profile-body strong{ color: #cfe8ff; display:block; margin-bottom:6px; font-weight:700; }
  .profile-body div{ color:#d6e9ff; padding-bottom:6px; }

  .profile-actions{
    margin-top:18px; display:flex; gap:12px; align-items:center;
  }
  .hire-btn{
    background: linear-gradient(90deg,#ff8a3d,#ff3c82);
    border:none; color:#fff; padding:12px 18px; font-weight:800; border-radius:12px; cursor:pointer;
    box-shadow:0 12px 30px rgba(255,60,130,0.14); font-size:16px;
  }
  .save-small{
    background:transparent; border:1px solid rgba(255,255,255,0.12); color:#fff; padding:10px 12px; border-radius:10px; cursor:pointer;
    font-weight:700;
  }

  .privacy-note{ margin-top:12px; font-size:13px; color:rgba(255,255,255,0.7); }

  /* Modal */
  .modal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999;
    background: linear-gradient(90deg, rgba(2,6,23,0.6), rgba(2,6,23,0.6));
    padding:20px;
  }
  .modal.open{ display:flex; }
  .modal-content{
    width:100%; max-width:520px; background: #fff; color:#111; border-radius:12px; padding:18px; position:relative;
    box-shadow:0 22px 60px rgba(2,6,23,0.3);
  }
  .modal-close{
    position:absolute; top:10px; right:10px; border:none; background:transparent; font-size:18px; cursor:pointer;
  }
  .modal-buttons{ display:flex; gap:12px; margin-top:10px; }
  .modal-buttons button{ flex:1; padding:12px; border-radius:10px; border:none; font-weight:700; cursor:pointer; }
  .modal-buttons button:first-child{ background: linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff; }
  .modal-buttons button:last-child{ background: #eef2ff; color:#111; }

  .modal-result{ margin-top:14px; padding:12px; border-radius:8px; background:#fbfdff; color:#0b1220; }
  .modal-result .note{ color:#6b7280; font-size:13px; margin-top:8px; }

  /* Notifications tab tweaks */
  #notificationsPage {
    display: flex;
    flex-direction: column;
    justify-content: flex-start; 
    align-items: center;          
    height: 100vh;
    padding-top: 40px;            
    text-align: center;
  }

  #notificationsPage .tabs {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  .tabs button {
    padding: 10px 16px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    background: #eee;
    font-weight: bold;
  }
  .tabs button.active {
    background: linear-gradient(90deg,#ff6a00,#ff3c82);
    color: white;
  }

  @media (max-width:700px){
    .profile-body{ grid-template-columns: 1fr; }
    .avatar{ width:80px; height:80px; border-radius:14px; }
    .open-profile{ padding:16px; border-radius:12px; margin:16px; }
  }

.contact-btn {
  flex:1;
  padding: 10px 16px;
  border-radius: 10px;
  border: none;
  font-weight: 700;
  cursor: pointer;
  font-size: 15px;
  transition: transform 0.2s, box-shadow 0.2s;
}
.copy-btn {
  background: linear-gradient(90deg,#0077ff,#2aa0ff);
  color: #fff;
}
.close-btn {
  background: linear-gradient(90deg,#ef4444,#f97316);
  color: #fff;
}
.contact-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
}


/* Hide back buttons during auth/login/registration/account completion */
#authPage .back-btn, #completeAccountModal .back-btn { display:none !important; }

</style>
<style>
  .icon-btn {
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    color: #fff;
    border: none;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .icon-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  }

  .dropdown {
    display: none;
    position: absolute;
    top: 44px;
    left: 0;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    min-width: 160px;
    flex-direction: column;
    z-index: 200;
    overflow: hidden;
  }
  .dropdown div {
    padding: 12px 16px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  .dropdown div:hover {
    background: #f0f4ff;
    color: #0077ff;
  }
</style>
<style>
  .notif-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .notif-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
  }
  .reply-btn {
    background: linear-gradient(90deg,#0077ff,#2aa0ff);
    color: #fff;
    margin-right: 6px;
  }
  .read-btn {
    background: linear-gradient(90deg,#22c55e,#4ade80);
    color: #fff;
  }
  .bell-container {
    position: relative;
    display: inline-block;
  }
  .bell-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    background: red;
    color: #fff;
    border-radius: 50%;
    padding: 2px 6px;
    font-size: 12px;
    font-weight: 700;
  }
</style>
<style>
/* Improved menu button styles (scoped to .menu-container to avoid affecting other buttons) */
.menu-container .menu-btn{
  min-width:260px;
  padding:14px 34px;
  border-radius:14px;
  border:none;
  cursor:pointer;
  font-weight:800;
  color:#fff;
  font-size:18px;
  box-shadow:0 12px 36px rgba(2,6,23,0.12);
  transition: transform .22s ease, box-shadow .22s;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
}
.menu-container .menu-btn.view-btn{
  background: linear-gradient(90deg,#06b6d4,#0ea5a6);
}
.menu-container .menu-btn.profile-btn{
  background: linear-gradient(90deg,#ff8a3d,#ff3c82);
}
.menu-container .menu-btn:hover{ transform: translateY(-6px); box-shadow: 0 18px 46px rgba(2,6,23,0.18); }
</style>
<!-- Added: Leaderboard + Ratings + UID styles -->
<style>
  /* Leaderboard styles */
  .leaderboard-tabs{display:flex;gap:10px;justify-content:center;margin-bottom:18px}
  .leaderboard-tabs button{padding:10px 16px;border-radius:10px;border:none;cursor:pointer;font-weight:700;background:#eee}
  .leaderboard-tabs button.active{background:linear-gradient(90deg,#0077ff,#2aa0ff);color:#fff}
  .leaderboard-list{display:flex;flex-direction:column;gap:12px;padding-bottom:40px}
  .leader-card{background:linear-gradient(180deg,#fff,#fbfdff);padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06);display:flex;gap:12px;align-items:center}
  .leader-rank{font-size:32px;font-weight:900;width:64px;text-align:center;border-radius:8px;padding:6px}
  .leader-gold{background:linear-gradient(135deg,#facc15,#f59e0b);color:#111}
  .leader-silver{background:linear-gradient(135deg,#d1d5db,#9ca3af);color:#111}
  .leader-bronze{background:linear-gradient(135deg,#fbbf24,#b45309);color:#111}
  .leader-info strong{display:block;font-size:18px}
  .leader-info .uid{font-size:12px;color:var(--muted);margin-top:4px}
  .leader-info .meta{margin-top:8px;color:#374151;font-weight:700}
  /* Rating stars inside open profile */
  .profile-rating{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .rating-stars{display:inline-flex;gap:6px}
  .rating-stars span{cursor:pointer;font-size:20px;color:#e5e7eb}
  .rating-stars span.active{color:#fbbf24}
  .rating-result{margin-top:6px;font-weight:800;color:#0077ff}
  
/* Improved styling for leaderboard ranks */
.leader-rank{
  font-size:28px;
  font-weight:900;
  width:80px;
  text-align:center;
  border-radius:12px;
  padding:10px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.leader-gold{
  background:linear-gradient(145deg,#fde047,#facc15);
  color:#7c2d12;
  box-shadow:0 0 16px rgba(250,204,21,0.6);
}
.leader-silver{
  background:linear-gradient(145deg,#e5e7eb,#9ca3af);
  color:#111827;
  box-shadow:0 0 16px rgba(156,163,175,0.5);
}
.leader-bronze{
  background:linear-gradient(145deg,#fcd34d,#b45309);
  color:#78350f;
  box-shadow:0 0 16px rgba(180,83,9,0.5);
}

  
/* Enhanced styling for top 3 full cards */
.leader-card.top1{
  background:linear-gradient(180deg,#fff7d6,#fde047);
  border:2px solid #facc15;
  position:relative;
}
.leader-card.top1::before{
  content:"üëë";
  position:absolute;
  top:-18px;
  left:16px;
  font-size:32px;
}
.leader-card.top2{
  background:linear-gradient(180deg,#f3f4f6,#d1d5db);
  border:2px solid #9ca3af;
}
.leader-card.top3{
  background:linear-gradient(180deg,#fef3c7,#fcd34d);
  border:2px solid #b45309;
}

  
/* Animated crown + glowing for top 1 */
.leader-card.top1{
  background:linear-gradient(180deg,#fff7d6,#fde047);
  border:2px solid #facc15;
  position:relative;
  animation:pulseGlow 2s infinite;
}
.leader-card.top1::before{
  content:"üëë";
  position:absolute;
  top:-22px;
  left:20px;
  font-size:34px;
  animation:bounce 1.5s infinite;
}
.leader-card.top2{
  background:linear-gradient(180deg,#f3f4f6,#d1d5db);
  border:2px solid #9ca3af;
}
.leader-card.top3{
  background:linear-gradient(180deg,#fef3c7,#fcd34d);
  border:2px solid #b45309;
}

@keyframes pulseGlow{
  0%,100%{box-shadow:0 0 20px rgba(250,204,21,0.6);}
  50%{box-shadow:0 0 40px rgba(250,204,21,0.9);}
}
@keyframes bounce{
  0%,100%{transform:translateY(0);}
  50%{transform:translateY(-6px);}
}

  
/* Leaderboard crowns, glow, and tab fade animations */
.leaderboard-list{
  opacity:1;
  transition:opacity 0.4s ease;
}
.leaderboard-list.fade-out{
  opacity:0;
}

.leader-card{
  opacity:0;
  transform:translateY(10px);
  animation:fadeInUp 0.6s ease forwards;
}
.leader-card.top1{
  background:linear-gradient(180deg,#fff7d6,#fde047);
  border:2px solid #facc15;
  position:relative;
  animation:pulseGlow 2s infinite, fadeInUp 0.6s ease forwards;
}
.leader-card.top1::before{
  content:"üëë";
  position:absolute;
  top:-22px;
  left:20px;
  font-size:34px;
  animation:bounce 1.5s infinite;
  color:gold;
}
.leader-card.top2{
  background:linear-gradient(180deg,#f3f4f6,#d1d5db);
  border:2px solid #9ca3af;
  position:relative;
}
.leader-card.top2::before{
  content:"üëë";
  position:absolute;
  top:-22px;
  left:20px;
  font-size:30px;
  color:silver;
  opacity:0.9;
}
.leader-card.top3{
  background:linear-gradient(180deg,#fef3c7,#fcd34d);
  border:2px solid #b45309;
  position:relative;
}
.leader-card.top3::before{
  content:"üëë";
  position:absolute;
  top:-22px;
  left:20px;
  font-size:28px;
  color:#cd7f32; /* bronze */
  opacity:0.85;
}

@keyframes pulseGlow{
  0%,100%{box-shadow:0 0 20px rgba(250,204,21,0.6);}
  50%{box-shadow:0 0 40px rgba(250,204,21,0.9);}
}
@keyframes bounce{
  0%,100%{transform:translateY(0);}
  50%{transform:translateY(-6px);}
}
@keyframes fadeInUp{
  from{opacity:0; transform:translateY(20px);}
  to{opacity:1; transform:translateY(0);}
}

  /* OTP box style */
  .otp-card{background:#ecfdf5;border:1px solid #bbf7d0;color:#065f46;padding:12px;border-radius:10px;font-weight:800;box-shadow:0 8px 30px rgba(2,6,23,0.04);margin-top:10px}
</style>
<!-- End injection -->

<style id="authDelayStyle">#authPage{display:none !important;}</style>
</head>
<body>
<!-- Top-left 3-dots menu -->
<div id="topMenu" style="position:fixed; top:12px; left:12px; z-index:10000;">
<button id="menuBtn" style="background:none;border:none;font-size:22px;cursor:pointer;">‚ãÆ</button>
<div id="menuDropdown" style="display:none; position:absolute; top:28px; left:0; background:white; border:1px solid #ccc; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); min-width:160px; overflow:hidden;">

<div onclick="showPage('savedProfilesPage'); closeMenu()" style="padding:10px; cursor:pointer; font-weight:600;">‚≠ê Saved Profiles</div>
  <div onclick="showPage('leaderboardPage'); closeMenu()" style="padding:10px; cursor:pointer; font-weight:600;">üèÜ Leaderboards</div>
</div>
</div>
<script>
function closeMenu(){ document.getElementById('menuDropdown').style.display='none'; }
document.addEventListener('DOMContentLoaded', function(){
  const btn = document.getElementById('menuBtn');
  const dd = document.getElementById('menuDropdown');
  if(btn && dd){
    btn.addEventListener('click', function(e){
      e.stopPropagation();
      dd.style.display = (dd.style.display==='block') ? 'none' : 'block';
    });
    document.addEventListener('click', function(){ dd.style.display='none'; });
  }
});
</script>
<!-- ===== Upgraded Auth UI + Flow (fixed: DOM ready, modal, toggles) ===== -->
<style>
/* scoped auth styles (improved modal + toggle) */
.auth-card{
  width:360px;
  max-width:92vw;
  background: linear-gradient(180deg,#fff,#fbfdff);
  border-radius:14px;
  padding:18px;
  box-shadow: 0 18px 40px rgba(2,6,23,0.08);
  text-align:left;
  font-weight:700;
  color:#071229;
}
.auth-row{display:flex; gap:8px; align-items:center; margin-top:10px;}
.fake-toggle {
  width:46px; height:26px; border-radius:999px; display:inline-block; position:relative; background:#e6eefc; vertical-align:middle; margin-right:8px; box-shadow: inset 0 2px 6px rgba(0,0,0,0.06);
}
.fake-toggle::after { content:''; position:absolute; top:3px; left:3px; width:20px; height:20px; border-radius:50%; background:#fff; transition: transform .18s; box-shadow:0 6px 16px rgba(2,6,23,0.06); }
.fake-toggle.on { background: linear-gradient(90deg,#06b6d4,#0ea5a6); }
.fake-toggle.on::after { transform: translateX(20px); }
.auth-input{ width:100%; padding:10px; border-radius:10px; border:1px solid #e8eefb; font-size:15px; box-sizing:border-box; }
.auth-primary{ background: linear-gradient(90deg,#0077ff,#2aa0ff); color:#fff; border:none; padding:10px 12px; border-radius:12px; font-weight:800; cursor:pointer; }
.auth-secondary{ background:#eef2ff; color:#111; border:none; padding:10px 12px; border-radius:12px; font-weight:800; cursor:pointer; }
.linkish{ color:#0077ff; cursor:pointer; font-weight:800; text-decoration:underline; }
.google-btn{ width:100%; padding:10px; border-radius:10px; border:1px solid #e6eefc; background:#fff; cursor:pointer; font-weight:800; }
.auth-small-note{ font-size:13px; color:#6b7280; margin-top:8px; }

/* Modal overlay */
.modal{
  display:none;
  position:fixed;
  left:0; top:0; right:0; bottom:0;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.45);
  z-index:9999;
}
.modal.open{ display:flex; }
.modal-content{
  background:white;
  border-radius:12px;
  padding:18px;
  width:420px;
  max-width:94vw;
  box-shadow:0 18px 48px rgba(2,6,23,0.12);
  position:relative;
}
.modal-close{
  position:absolute; right:12px; top:8px; background:transparent; border:none; font-size:18px; cursor:pointer;
}
</style>
<!-- Auth Page -->
<div class="page" id="authPage" style="display:none; align-items:center; justify-content:center; height:100vh; background:#f9fafb;">
  <div aria-label="Authentication" class="auth-card" role="region" 
       style="padding:20px; border-radius:12px; background:white; box-shadow:0 4px 15px rgba(0,0,0,0.1); width:320px;">
    
    
    <!-- Email / password area -->
    <div id="emailFormArea" style="margin-top:12px;">
      <input autocomplete="email" class="auth-input" id="emailInput" placeholder="Email" type="email"/>
      <div style="height:8px"></div>
      <input autocomplete="current-password" class="auth-input" id="passwordInput" placeholder="Password" type="password"/>
      
      <div class="auth-row" style="margin-top:12px; display:flex; gap:8px;">
        <button class="auth-primary" id="primaryAuthBtn">Create account</button>
        <button class="auth-secondary" id="secondaryAuthBtn" style="display:none">Login</button>
      </div>
      
      <div style="margin-top:12px; text-align:center;">
        <button class="google-btn" id="googleBtn">Continue with Google</button>
      </div>
      
      <div class="auth-small-note" style="text-align:center;">
        <span class="linkish" id="authToggleLink">Already have an account? Login</span>
      </div>
    </div>

    <!-- Phone/OTP area (hidden by default) -->
    <div id="phoneFormArea" style="margin-top:12px; display:none;">
      <input class="auth-input" id="phoneInput" placeholder="+91 98765 43210" type="text"/>
      <div id="recaptcha-container" style="margin-top:8px;"></div>
      
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="auth-primary" id="sendOtpBtn">Send OTP</button>
        <input class="auth-input" id="otpInput" placeholder="Enter OTP" style="flex:1;" type="text"/>
      </div>
      
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="auth-secondary" id="verifyOtpBtn">Verify OTP</button>
      </div>
      
      <div class="auth-small-note">Use phone if you prefer contact-based sign in.</div>
    </div>

    <!-- Status/Error messages -->
    <p id="authStatus" style="color:#d73a49; font-weight:800; margin-top:12px;"></p>
  </div>
</div>

<!-- Script -->
<script>
  const switchInput = document.getElementById("useContactSwitch");
  const emailForm = document.getElementById("emailFormArea");
  const phoneForm = document.getElementById("phoneFormArea");

  switchInput.addEventListener("change", () => {
    if (switchInput.checked) {
      emailForm.style.display = "none";
      phoneForm.style.display = "block";
    } else {
      emailForm.style.display = "block";
      phoneForm.style.display = "none";
    }
  });
</script>

<!-- Styles -->
<style>
  .auth-input {
    width: 100%;
    padding: 10px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 14px;
  }
  .auth-primary {
    flex:1;
    padding:10px;
    background:#2563eb;
    color:white;
    border:none;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
  }
  .auth-secondary {
    flex:1;
    padding:10px;
    background:#e5e7eb;
    color:#374151;
    border:none;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
  }
  .google-btn {
    padding:10px;
    background:#fff;
    border:1px solid #d1d5db;
    border-radius:6px;
    cursor:pointer;
    font-weight:600;
    width:100%;
  }
  .auth-small-note {
    font-size:12px;
    color:#6b7280;
    margin-top:8px;
  }
  .linkish {
    color:#2563eb;
    cursor:pointer;
    font-weight:600;
  }

  /* Modern toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 40px;
    height: 22px;
  }
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #d1d5db;
    transition: .4s;
    border-radius: 34px;
  }
  .slider:before {
    position: absolute;
    content: "";
    height: 16px; width: 16px;
    left: 3px; bottom: 3px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
  }
  .switch input:checked + .slider {
    background-color: #34d399; /* green */
  }
  .switch input:checked + .slider:before {
    transform: translateX(18px);
  }
</style>

<!-- Post-register "Complete account" modal (inserts when needed) -->
<div aria-labelledby="completeTitle" aria-modal="true" class="modal" id="completeAccountModal" role="dialog">
  <div class="modal-content">
    
    <h4 id="completeTitle">Complete your account</h4>
    <p class="auth-small-note">Pick a username and enter your age so we can link your profile.</p>
    <input class="auth-input" id="complete_username" placeholder="Username (public)">
    <div style="height:8px"></div>
    <input class="auth-input" id="complete_age" placeholder="Age" type="number">
    <div style="display:flex; flex-direction:column; gap:12px; margin-top:12px;">
      <div style="height:8px"></div>
      <label for="stateInput" style="font-weight:600; margin-top:6px;">State</label>
      <select id="stateInput" class="auth-input" name="state" required>
        <option value="">Select state</option>
        <option>Andhra Pradesh</option>
        <option>Arunachal Pradesh</option>
        <option>Assam</option>
        <option>Bihar</option>
        <option>Chhattisgarh</option>
        <option>Goa</option>
        <option>Gujarat</option>
        <option>Haryana</option>
        <option>Himachal Pradesh</option>
        <option>Jammu and Kashmir</option>
        <option>Jharkhand</option>
        <option>Karnataka</option>
        <option>Kerala</option>
        <option>Madhya Pradesh</option>
        <option>Maharashtra</option>
        <option>Manipur</option>
        <option>Meghalaya</option>
        <option>Mizoram</option>
        <option>Nagaland</option>
        <option>Odisha</option>
        <option>Punjab</option>
        <option>Rajasthan</option>
        <option>Sikkim</option>
        <option>Tamil Nadu</option>
        <option>Telangana</option>
        <option>Tripura</option>
        <option>Uttar Pradesh</option>
        <option>Uttarakhand</option>
        <option>West Bengal</option>
        <option>Other</option>
      </select>
      <div style="height:8px"></div>
      <label for="districtInput" style="font-weight:600; margin-top:6px;">District</label>
      <input id="districtInput" class="auth-input" name="district" type="text" placeholder=\"Enter district\" required />

      <div style="height:8px"></div>
<label for="cityInput" style="font-weight:600; margin-top:6px;">City</label>
<input id="cityInput" class="auth-input" name="city" type="text" placeholder="Enter city" required />

<button class="auth-primary" id="completeSaveBtn">Save &amp; Continue</button>
    </div>
    <div class="auth-small-note" id="completeAccountStatus"></div>
  </div>
</div>
<script>
/* Robust auth helpers: DOM-ready, fallbacks for auth/db, modal fixes, and proper binding of profile data.
   Functions are assigned to window so the HTML onclicks continue to work.
*/


(function(){
  // helpers to get firebase auth / firestore instances (don't override if app already set)
  function _getAuth(){
    if(typeof auth !== 'undefined' && auth) return auth;
    if(typeof firebase !== 'undefined' && firebase.auth) return firebase.auth();
    return null;
  }
  function _getDb(){
    if(typeof db !== 'undefined' && db) return db;
    if(typeof firebase !== 'undefined' && firebase.firestore) return firebase.firestore();
    return null;
  }

  function showAuthStatus(msg){
    const el = document.getElementById('authStatus');
    if(el) el.textContent = msg || '';
  }

  // Global state
  window.pendingNewUserUid = null;
  window.confirmationResult = null;
  window.authMode = 'register'; // 'register' or 'login'

  // Exposed functions (use firebase instances at call-time)
  window.emailRegister = async function(){
    const authInst = _getAuth();
    if(!authInst){ showAuthStatus('Auth not initialized'); return; }
    const email = (document.getElementById('emailInput').value || '').trim();
    const pass = (document.getElementById('passwordInput').value || '').trim();
    if(!email || !pass){ showAuthStatus('Enter email and password'); return; }
    try{
      const result = await authInst.createUserWithEmailAndPassword(email, pass);
      const user = result && result.user ? result.user : null;
      if(user && user.uid){
        window.pendingNewUserUid = String(user.uid);
        showCompleteAccountModal(user.uid, user);
      } else {
        showAuthStatus('Registration succeeded but no user returned');
      }
    }catch(err){
      if(err && err.code === 'auth/email-already-in-use'){
        showAuthStatus('Email already in use. Attempting sign-in to merge local profile...');
        try{
          await authInst.signInWithEmailAndPassword(email, pass);
          const uid = (authInst.currentUser && authInst.currentUser.uid) ? authInst.currentUser.uid : null;
          if(uid){
            localStorage.setItem('profiles_my_uid_v1', String(uid));
            window.myUID = String(uid);
            try{ await bindUserProfile(uid); }catch(e){}
            showPage && typeof showPage === 'function' && showPage('home');
            showAuthStatus('');
          }
        }catch(e2){
          showAuthStatus(e2 && e2.message ? e2.message : String(e2));
        }
      } else {
        showAuthStatus(err && err.message ? err.message : String(err));
      }
    }
  };

  window.emailLogin = async function(){
    const authInst = _getAuth();
    if(!authInst){ showAuthStatus('Auth not initialized'); return; }
    const email = (document.getElementById('emailInput').value || '').trim();
    const pass = (document.getElementById('passwordInput').value || '').trim();
    if(!email || !pass){ showAuthStatus('Enter email and password'); return; }
    try{
      const res = await authInst.signInWithEmailAndPassword(email, pass);
      const uid = res && res.user && res.user.uid ? res.user.uid : (authInst.currentUser && authInst.currentUser.uid ? authInst.currentUser.uid : null);
      if(uid){
        localStorage.setItem('profiles_my_uid_v1', String(uid));
        window.myUID = String(uid);
        await bindUserProfile(uid);
        showPage && typeof showPage === 'function' && showPage('home');
        showAuthStatus('');
      }
    }catch(e){
      showAuthStatus(e && e.message ? e.message : String(e));
    }
  };

  window.googleLogin = async function(){
    const authInst = _getAuth();
    if(!authInst){ showAuthStatus('Auth not initialized'); return; }
    try{
      const provider = new (window.firebase && window.firebase.auth && window.firebase.auth.GoogleAuthProvider ? firebase.auth.GoogleAuthProvider : window.googleProviderConstructor || (function(){return null})())();
      // fallback: use firebase.auth.GoogleAuthProvider directly if available
      const prov = (typeof firebase !== 'undefined' && firebase.auth && firebase.auth.GoogleAuthProvider) ? new firebase.auth.GoogleAuthProvider() : null;
      const chosenProvider = prov || provider;
      if(!chosenProvider){ showAuthStatus('Google Auth provider not available'); return; }
      const result = await authInst.signInWithPopup(chosenProvider);
      const user = result && result.user ? result.user : null;
      if(user && user.uid){
        window.pendingNewUserUid = String(user.uid);
        // Check if users/{uid} exists, else ask for completion
        const dbInst = _getDb();
        if(dbInst){
          try{
            const doc = await dbInst.collection('users').doc(String(user.uid)).get();
            if(doc.exists){
              localStorage.setItem('profiles_my_uid_v1', String(user.uid));
              window.myUID = String(user.uid);
              await bindUserProfile(user.uid);
              showPage && typeof showPage === 'function' && showPage('home');
            } else {
              showCompleteAccountModal(user.uid, user);
            }
          }catch(e){
            console.warn('googleLogin db check', e);
            showCompleteAccountModal(user.uid, user);
          }
        } else {
          showCompleteAccountModal(user.uid, user);
        }
      }
    }catch(e){ showAuthStatus(e && e.message ? e.message : String(e)); }
  };

  window.phoneLogin = async function(){
    const authInst = _getAuth();
    if(!authInst){ showAuthStatus('Auth not initialized'); return; }
    const phoneNumber = (document.getElementById('phoneInput').value || '').trim();
    if(!phoneNumber){ showAuthStatus('Enter phone number'); return; }
    try{
      // initialize reCAPTCHA if not exists
      if(!window.recaptchaVerifier && firebase && firebase.auth){
        try{
          window.recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container', { 'size': 'invisible' });
        }catch(e){}
      }
      const confirmation = await authInst.signInWithPhoneNumber(phoneNumber, window.recaptchaVerifier);
      window.confirmationResult = confirmation;
      showAuthStatus('OTP sent');
    }catch(e){ showAuthStatus(e && e.message ? e.message : String(e)); }
  };

  window.verifyOTP = async function(){
    const authInst = _getAuth();
    if(!authInst){ showAuthStatus('Auth not initialized'); return; }
    const code = (document.getElementById('otpInput').value || '').trim();
    if(!window.confirmationResult){ showAuthStatus('No OTP sent'); return; }
    try{
      const res = await window.confirmationResult.confirm(code);
      const uid = res && res.user && res.user.uid ? res.user.uid : null;
      if(uid){
        localStorage.setItem('profiles_my_uid_v1', String(uid));
        window.myUID = String(uid);
        window.pendingNewUserUid = String(uid);
        showCompleteAccountModal(uid, res.user);
      }
    }catch(e){ showAuthStatus(e && e.message ? e.message : String(e)); }
  };

  // Modal functions
  window.showCompleteAccountModal = function(uid, firebaseUser){
    const modal = document.getElementById('completeAccountModal');
    if(!modal) return;
    modal.classList.add('open');
    window.pendingNewUserUid = String(uid);
    // prefill username if google displayName exists
    const uname = (firebaseUser && firebaseUser.displayName) ? firebaseUser.displayName : '';
    const nameField = document.getElementById('complete_username');
    const ageField = document.getElementById('complete_age');
    if(nameField) nameField.value = uname;
    if(ageField) ageField.value = '';
    const status = document.getElementById('completeAccountStatus');
    if(status) status.textContent = '';
  };
  window.closeCompleteAccountModal = function(){
    const modal = document.getElementById('completeAccountModal');
    if(!modal) return;
    modal.classList.remove('open');
  };

  // Save after modal: persist to users/{uid} and link/create profile
  window.saveCompleteAccount = async function(){
    const username = (document.getElementById('complete_username').value || '').trim();
    const age = Number(document.getElementById('complete_age').value || 0);
    const statusEl = document.getElementById('completeAccountStatus');
    if(!window.pendingNewUserUid){ if(statusEl) statusEl.textContent = 'No pending user'; return; }
    if(!username){ if(statusEl) statusEl.textContent = 'Username required'; return; }
    if(statusEl) statusEl.textContent = 'Saving‚Ä¶';
    const uid = String(window.pendingNewUserUid);
    const dbInst = _getDb();
    try{
      if(dbInst){
        // read state/district fields from modal
        const stateVal = (document.getElementById('stateInput') ? (document.getElementById('stateInput').value||'') : '');
        const districtVal = (document.getElementById('districtInput') ? (document.getElementById('districtInput').value||'') : '');
        await dbInst.collection('users').doc(String(uid)).set({
          displayName: username,
          age: (age > 0 ? Number(age) : null),
          email: (_getAuth() && _getAuth().currentUser && _getAuth().currentUser.email) ? _getAuth().currentUser.email : null,
          state: stateVal,
          district: districtVal,
          city: (document.getElementById('cityInput')?.value || ''),
          updatedAt: new Date().toISOString()
        }, { merge: true });
      }
      // Link or create profile
      try{
        if(typeof window.myProfile !== 'undefined' && window.myProfile && window.myProfile.uid){
          const profileUid = String(window.myProfile.uid);
          if(dbInst){
            await dbInst.collection('profiles').doc(String(profileUid)).set({ ownerUid: String(uid) }, { merge: true });
            await dbInst.collection('users').doc(String(uid)).set({ profileUid: String(profileUid) }, { merge: true });
          }
        } else {
          // IMPORTANT: Do NOT auto-create a profile here.
          // The user explicitly asked that profile creation be manual ‚Äî so skip creating profiles/{uid}.
          // The user can create a profile later via the "Create Your Profile" form.
          console.log('No existing profile linked for uid', uid, '- skipping automatic profile creation.');
        }
      }catch(e){ console.warn('profile linking failed', e); }
      localStorage.setItem('profiles_my_uid_v1', String(uid));
      window.myUID = String(uid);
      try{ await bindUserProfile(uid); }catch(e){}
      if(statusEl) statusEl.textContent = 'Saved ‚Äî redirecting‚Ä¶';
      setTimeout(()=>{ closeCompleteAccountModal(); showPage && typeof showPage === 'function' && showPage('home'); showAuthStatus(''); }, 400);
    }catch(err){
      console.warn('saveCompleteAccount err', err);
      if(statusEl) statusEl.textContent = String(err && err.message ? err.message : err);
    }
  };

  window.skipCompleteAccount = function(){
    if(window.pendingNewUserUid){
      localStorage.setItem('profiles_my_uid_v1', String(window.pendingNewUserUid));
      window.myUID = String(window.pendingNewUserUid);
      bindUserProfile(window.pendingNewUserUid).catch(()=>{});
    }
    closeCompleteAccountModal();
    showPage && typeof showPage === 'function' && showPage('home');
  };

  // Merge local profile into account
  window.mergeLocalProfileIntoAccount = async function(uid){
    try{
      if(!uid) return;
      if(typeof window.myProfile !== 'undefined' && window.myProfile && window.myProfile.uid){
        const profileUid = String(window.myProfile.uid);
        const dbInst = _getDb();
        if(dbInst){
          await dbInst.collection('profiles').doc(String(profileUid)).set({ ownerUid: String(uid) }, { merge: true });
          await dbInst.collection('users').doc(String(uid)).set({ profileUid: String(profileUid) }, { merge: true });
        }
        localStorage.setItem('profiles_my_uid_v1', String(uid));
        window.myUID = String(uid);
        try{ if(typeof loadUserData === 'function') await loadUserData(uid); } catch(e){ console.warn('loadUserData after merge failed', e); }
        alert('Local profile merged into your Firebase account.');
      }
    }catch(e){ console.warn('mergeLocalProfileIntoAccount', e); }
  };

  // Bind user profile: read users/{uid} and profiles/{profileUid} then call loadUserData
  window.bindUserProfile = async function(uid){
    try{
      if(!uid) return;
      const dbInst = _getDb();
      const authInst = _getAuth();
      // If no Firestore, fall back to loadUserData only
      if(!dbInst){
        try{ if(typeof loadUserData === 'function') await loadUserData(uid); }catch(e){ console.warn('loadUserData fallback failed', e); }
        return;
      }
      const userRef = dbInst.collection('users').doc(String(uid));
      const userDocSnap = await userRef.get();
      let profileUid = null;
      let userDocData = null;
      if(userDocSnap.exists){
        userDocData = userDocSnap.data();
        if(userDocData && userDocData.profileUid){
          profileUid = String(userDocData.profileUid);
        }
      }

      // If no profileUid on user doc, try to find a profile owned by uid
      if(!profileUid){
        try{
          const q = await dbInst.collection('profiles').where('ownerUid','==',String(uid)).limit(1).get();
          if(!q.empty){
            profileUid = q.docs[0].id;
          }
        }catch(e1){
          console.warn('profile ownerUid query failed', e1);
        }
      }

      // If still no profileUid, try to match by contact/email/phone on profiles
      if(!profileUid && authInst && authInst.currentUser){
        try{
          const cu = authInst.currentUser;
          const email = cu.email || (userDocData && userDocData.email) || null;
          const phone = cu.phoneNumber || null;
          if(email){
            const q2 = await dbInst.collection('profiles').where('contact','==',email).limit(1).get();
            if(!q2.empty) profileUid = q2.docs[0].id;
          }
          if(!profileUid && phone){
            const q3 = await dbInst.collection('profiles').where('contact','==',phone).limit(1).get();
            if(!q3.empty) profileUid = q3.docs[0].id;
          }
        }catch(e2){
          console.warn('profile contact search failed', e2);
        }
      }

      // If still not found, DO NOT auto-create a profile ‚Äî allow the user to create it manually later.
      if(!profileUid){
        // Do not create a fallback profile automatically. Leave profileUid null and myProfile unset.
        window.myProfile = null;
        // (When the user creates a profile via the Create Profile form, saveProfileToFirebase will link it.)
      } else {
        // If found, fetch and set to window.myProfile
        try{
          const profSnap = await dbInst.collection('profiles').doc(String(profileUid)).get();
          if(profSnap.exists){
            const pdata = profSnap.data();
            window.myProfile = pdata || {};
            window.myProfile.uid = String(profileUid);
            localStorage.setItem('profiles_my_uid_v1', String(profileUid));
          }
        }catch(e4){
          console.warn('fetching profile doc failed', e4);
        }
      }

      // Ensure user doc has profileUid set (write-back if we discovered profile)
      try{
        if(profileUid){
          await userRef.set({ profileUid: String(profileUid) }, { merge: true });
        }
      }catch(e5){
        console.warn('writing profileUid to user doc failed', e5);
      }

      // Finally call loadUserData to populate savedProfiles/notifications/chats
      try{ if(typeof loadUserData === 'function') await loadUserData(uid); }catch(e){ console.warn('loadUserData failed', e); }

    }catch(e){
      console.warn('bindUserProfile failed', e);
      try{ if(typeof loadUserData === 'function') await loadUserData(uid); }catch(_){}
    }
  };

  // DOM ready: wire up toggle buttons and UI behaviors
  document.addEventListener('DOMContentLoaded', function(){
    const useContactToggle = document.getElementById('useContactToggle');
    const useContactSwitch = document.getElementById('useContactSwitch');
    const emailArea = document.getElementById('emailFormArea');
    const phoneArea = document.getElementById('phoneFormArea');
    const primaryBtn = document.getElementById('primaryAuthBtn');
    const secondaryBtn = document.getElementById('secondaryAuthBtn');
    const googleBtn = document.getElementById('googleBtn');
    const sendOtpBtn = document.getElementById('sendOtpBtn');
    const verifyOtpBtn = document.getElementById('verifyOtpBtn');
    const authToggleLink = document.getElementById('authToggleLink');
    const completeSaveBtn = document.getElementById('completeSaveBtn');
    const completeSkipBtn = document.getElementById('completeSkipBtn');

    if(useContactToggle){
      useContactToggle.addEventListener('click', function(){
        useContactSwitch.checked = !useContactSwitch.checked;
        useContactToggle.classList.toggle('on', useContactSwitch.checked);
        if(useContactSwitch.checked){
          emailArea.style.display = 'none';
          phoneArea.style.display = 'block';
        } else {
          emailArea.style.display = 'block';
          phoneArea.style.display = 'none';
        }
      });
    }

    // Buttons: primary -> register, secondary -> login
    if(primaryBtn) primaryBtn.addEventListener('click', function(){ window.emailRegister && window.emailRegister(); });
    if(secondaryBtn) secondaryBtn.addEventListener('click', function(){ window.emailLogin && window.emailLogin(); });

    if(googleBtn) googleBtn.addEventListener('click', function(){ window.googleLogin && window.googleLogin(); });
    if(sendOtpBtn) sendOtpBtn.addEventListener('click', function(){ window.phoneLogin && window.phoneLogin(); });
    if(verifyOtpBtn) verifyOtpBtn.addEventListener('click', function(){ window.verifyOTP && window.verifyOTP(); });
    if(authToggleLink){
      authToggleLink.addEventListener('click', function(){
        // toggle between login / register
        if(window.authMode === 'register'){
          window.authMode = 'login';
          if(primaryBtn) primaryBtn.style.display = 'none';
          if(secondaryBtn) secondaryBtn.style.display = 'inline-block';
          authToggleLink.textContent = 'Create account';
        } else {
          window.authMode = 'register';
          if(primaryBtn) primaryBtn.style.display = 'inline-block';
          if(secondaryBtn) secondaryBtn.style.display = 'none';
          authToggleLink.textContent = 'Already have an account? Login';
        }
        showAuthStatus('');
      });
    }
    if(completeSaveBtn) completeSaveBtn.addEventListener('click', function(){ window.saveCompleteAccount && window.saveCompleteAccount(); });
    if(completeSkipBtn) completeSkipBtn.addEventListener('click', function(){ window.skipCompleteAccount && window.skipCompleteAccount(); });

    // initialize UI
    window.authMode = 'register';
    if(primaryBtn) primaryBtn.style.display = 'inline-block';
    if(secondaryBtn) secondaryBtn.style.display = 'none';
    if(useContactToggle) useContactToggle.classList.remove('on');
  });

})();
</script>
<!-- ===== end upgraded auth patch ===== -->
<!-- Main menu -->
<div class="page" id="home">
<div class="menu-container">
<button class="menu-btn view-btn" onclick="showPage('categoriesPage')">View Profiles</button>
<button class="menu-btn profile-btn" id="profileBtn" onclick="openProfileForm()">Create a Profile</button>
</div>
</div>
<!-- Create Profile -->
<div class="page" id="createProfilePage">
<h2 id="formTitle">Create Your Profile</h2>
<form id="profileForm">
<input id="name" placeholder="Your Name" required="" type="text"/>
<input id="age" placeholder="Your Age" required="" type="number"/>
<select id="skill" required="">
<option value="">-- Select Skill --</option>
<option value="Plumber">Plumber</option>
<option value="Mechanic">Mechanic</option>
<option value="Electrician">Electrician</option>
<option value="Painter">Painter</option>
<option value="Tutor">Tutor</option>
<option value="Mistri">Mistri</option>
<option value="Carpenter">Carpenter</option>
<option value="Welder">Welder</option>
</select>
<input id="address" placeholder="Your Address" required="" type="text"/>
<input id="city" placeholder="Your City" required type="text"/>
<input id="contact" placeholder="Contact No." required="" type="text"/>
<input id="language" placeholder="Languages Spoken" type="text"/>
<textarea id="description" placeholder="Short description about you (will show under your name)" rows="3"></textarea>
<div id="statusSection" style="display:none;">
<label for="status">Profile Status:</label>
<select id="status">
<option selected="" value="Free">Free</option>
<option value="Busy">Busy</option>
</select>
<p class="note">Free means your profile is visible in the app. Busy will hide it, letting you rest.</p>
</div>
<button id="submitBtn" type="submit">‚Çπ250</button>
</form>
<button class="back-btn" onclick="showPage('home')">Back</button>
</div>
<!-- View Profiles -->
<div class="page" id="categoriesPage">
<h2>View Profiles</h2>
<div class="categories" id="categoryFilter">
<div class="category" onclick="filterSkill('All')">All</div>
<div class="category" onclick="filterSkill('Plumber')">Plumber</div>
<div class="category" onclick="filterSkill('Mechanic')">Mechanic</div>
<div class="category" onclick="filterSkill('Electrician')">Electrician</div>
<div class="category" onclick="filterSkill('Painter')">Painter</div>
<div class="category" onclick="filterSkill('Tutor')">Tutor</div>
<div class="category" onclick="filterSkill('Mistri')">Mistri</div>
<div class="category" onclick="filterSkill('Carpenter')">Carpenter</div>
<div class="category" onclick="filterSkill('Welder')">Welder</div>
</div>
<div class="search-bar">
<input id="searchInput" oninput="displayProfiles()" placeholder="Search by Name or UID" type="text"/>
</div>
<div class="profile-list" id="profileList"></div>
<button class="back-btn" onclick="showPage('home')">Back</button>
</div>
<!-- Open Profile (redesigned) -->
<div class="page" id="openProfilePage">
<div class="open-profile">
<button class="close-btn" onclick="closeProfile()">‚úï</button>
<div class="profile-header">
<div class="avatar" id="profileAvatar">P</div>
<div class="profile-head-info">
<h3 id="profileName">Name</h3>
<div id="profileDescription" style="margin-top:6px; color:#d6e9ff;"></div>
<div class="profile-meta">
<div class="skill-badge" id="profileSkill">Skill</div>
<div class="status-badge" id="profileStatus">Status</div>
</div>
</div>
</div>
<div class="profile-body">
<div>
<strong>UID</strong>
<div id="profileUID">‚Äî</div>
</div>
<div>
<strong>Age</strong>
<div id="profileAge">‚Äî</div>
</div>
<div>
<strong>Address</strong>
<div id="profileAddress">‚Äî</div>
</div>
<div>
<strong>Languages Spoken</strong>
<div id="profileLanguage">‚Äî</div>
</div>
</div>
<div class="profile-actions">
<button class="hire-btn" id="hireBtn" onclick="openHireModal()">Hire</button>
<button class="save-small" id="saveBtn" onclick="toggleSaveFromOpen()">‚≠ê Save</button>
</div>
<p class="privacy-note">Contact is hidden by default. Click <strong>Hire ‚Üí Contact</strong> to view the number. </p>
</div>
</div>
<!-- Hire modal -->
<div class="modal" id="hireModal" onclick="modalBackgroundClick(event)">
<div aria-labelledby="hireTitle" aria-modal="true" class="modal-content" role="dialog">
<button class="modal-close" onclick="closeHireModal()">‚úï</button>
<h4 id="hireTitle">Hire Options</h4>
<p class="note">Choose how you'd like to proceed with this profile.</p>
<div class="modal-buttons">
<button id="modalContactBtn" onclick="showContact()">Contact</button>
</div>
<div aria-live="polite" class="modal-result" id="modalResult"></div>
</div>
</div>
<!-- Notifications -->
<div class="page" id="notificationsPage">
<h2>Notifications</h2>
<div class="tabs">
<button class="active" id="tab-unread" onclick="switchTab('unread')">Unread</button>
<button id="tab-read" onclick="switchTab('read')">Read</button>
<button id="tab-hire" onclick="switchTab('hire')">Hire Requests</button>
</div>
<div id="notificationContent"></div>
<button class="back-btn" onclick="showPage('home')">Back</button>
</div>
<!-- Leaderboards Page -->
<div class="page" id="leaderboardPage">
  <h2 style="text-align:center;">Leaderboards</h2>
  <div class="leaderboard-tabs">
    <button class="active" onclick="switchLeaderboard('hired')">Top 10 Most Hired</button>
    <button onclick="switchLeaderboard('alltime')">Top 10 Workers of All Time</button>
    <button onclick="switchLeaderboard('rated')">Top 10 Most Rated</button>
  </div>
  <div class="leaderboard-list" id="leaderboardList"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<!-- Saved Profiles -->
<div class="page" id="savedProfilesPage">
<h2>Saved Profiles</h2>
<div class="categories" id="savedCategoryFilter">
<div class="category" onclick="savedSkill='All';displaySaved()">All</div>
<div class="category" onclick="savedSkill='Plumber';displaySaved()">Plumber</div>
<div class="category" onclick="savedSkill='Mechanic';displaySaved()">Mechanic</div>
<div class="category" onclick="savedSkill='Electrician';displaySaved()">Electrician</div>
<div class="category" onclick="savedSkill='Painter';displaySaved()">Painter</div>
<div class="category" onclick="savedSkill='Tutor';displaySaved()">Tutor</div>
<div class="category" onclick="savedSkill='Mistri';displaySaved()">Mistri</div>
<div class="category" onclick="savedSkill='Carpenter';displaySaved()">Carpenter</div>
<div class="category" onclick="savedSkill='Welder';displaySaved()">Welder</div>
</div>
<div class="search-bar">
<input id="savedSearchInput" oninput="displaySaved()" placeholder="Search in Saved" type="text"/>
</div>
<div class="profile-list" id="savedList"></div>
<button class="back-btn" onclick="showPage('home')">Back</button>
</div>
<script>
let profiles=[];
let savedProfiles=[];
let currentSkill='All';
let savedSkill='All';
let myProfile=null;
let currentOpenProfile=null;

function generateUID(){ return Date.now()+Math.floor(Math.random()*1000); }

function showPage(id){
  document.querySelectorAll('.page').forEach(p=>p.style.display='none');
  document.getElementById(id).style.display='block';

  if(id==='categoriesPage') displayProfiles();

  if(id==='savedProfilesPage') {
    displaySaved();
    // close 3-dots menu if open
    const dd = document.getElementById("menuDropdown");
    if(dd) {
      dd.style.display = "none";
      dd.style.removeProperty("display");
    }
  }

  if(id==='notificationsPage') {
    // restore the last active notifications tab (keeps user's previous context)
    switchTab(lastNotificationTab || 'unread');
  }
}


function filterSkill(skill){ currentSkill=skill; displayProfiles(); }

function openProfileForm(){
  showPage('createProfilePage');
  if(myProfile){
    document.getElementById('formTitle').textContent="Manage Your Profile";
    document.getElementById('submitBtn').textContent="Save";
    document.getElementById('statusSection').style.display="block";
    document.getElementById('name').value=myProfile.name;
    document.getElementById('age').value=myProfile.age;
    document.getElementById('skill').value=myProfile.skill;
    document.getElementById('address').value=myProfile.address;
    document.getElementById('city').value=myProfile.city || '';
    document.getElementById('contact').value=myProfile.contact;
    document.getElementById('language').value=myProfile.language;
    document.getElementById('description').value = myProfile.description || '';
    document.getElementById('status').value=myProfile.status;
  } else {
    document.getElementById('formTitle').textContent="Create Your Profile";
    document.getElementById('submitBtn').textContent="‚Çπ250";
    document.getElementById('statusSection').style.display="none";
    document.getElementById('profileForm').reset();
  }
}

document.getElementById("profileForm").addEventListener("submit",function(e){
  e.preventDefault();
  const profile={
    uid: myProfile ? myProfile.uid : generateUID(),
    name:document.getElementById("name").value.trim(),
    age:document.getElementById("age").value,
    skill:document.getElementById("skill").value,
    address:document.getElementById("address").value,
    city:document.getElementById("city").value,
    contact:document.getElementById("contact").value.trim(),
    language:document.getElementById("language").value,
    description: document.getElementById("description").value.trim(),
    status: myProfile ? document.getElementById("status").value : "Free"
  };
  if(myProfile){
    const idx=profiles.findIndex(p=>p.uid===myProfile.uid);
    if(idx!==-1) profiles[idx]=profile;
  } else {
    profiles.push(profile);
  }
  myProfile=profile;
  document.getElementById("profileBtn").textContent="Manage Profile";
  alert("Profile saved successfully!");
  showPage('home');
});

function saveProfile(p){
  const index = savedProfiles.findIndex(sp=>sp.uid===p.uid);
  if(index===-1){
    savedProfiles.push(p);
    alert("Profile saved!");
  } else {
    savedProfiles.splice(index,1);
    alert("Removed from saved!");
  }
  displayProfiles();
  if(document.getElementById("savedProfilesPage").style.display==='block'){
    displaySaved();
  }
}


function displayProfiles(){
  const container=document.getElementById("profileList");
  container.innerHTML='';
  const search=document.getElementById("searchInput")?document.getElementById("searchInput").value.toLowerCase():"";
  const cityVal=document.getElementById("change_city")?document.getElementById("change_city").value.trim().toLowerCase():"";
  const districtVal=document.getElementById("change_district")?document.getElementById("change_district").value.trim().toLowerCase():"";
  const stateVal=document.getElementById("change_state")?document.getElementById("change_state").value.trim().toLowerCase():"";

  let filtered = profiles.filter(p=>{
    const statusMatch=p.status==="Free";
    const skillMatch=currentSkill==='All'||p.skill===currentSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return statusMatch&&skillMatch&&searchMatch;
  });

  // Priority: city > district > state > others
  let cityMatches = [], districtMatches = [], stateMatches = [], others = [];
  filtered.forEach(p=>{
    const city = (p.city||"").toLowerCase();
    const district = (p.district||"").toLowerCase();
    const state = (p.state||"").toLowerCase();
    if(cityVal && city === cityVal){ cityMatches.push(p); }
    else if(districtVal && district === districtVal){ districtMatches.push(p); }
    else if(stateVal && state === stateVal){ stateMatches.push(p); }
    else { others.push(p); }
  });

  let ordered = [...cityMatches, ...districtMatches, ...stateMatches, ...others];

  ordered.forEach(p=>{
    const box=document.createElement('div'); box.className='profile-box';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    const locSpan=document.createElement('div'); locSpan.style.fontSize='12px'; locSpan.style.color='#374151'; locSpan.textContent = buildLocationString(p); nameContainer.appendChild(locSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê'; 
    if(savedProfiles.some(sp=>sp.uid===p.uid)) saveBtn.classList.add("saved");
    saveBtn.className='save-btn';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    container.appendChild(box);
  });
}

function openProfile(p){
  showPage('openProfilePage');
  currentOpenProfile = p;
  document.getElementById('profileName').textContent=p.name;
  document.getElementById('profileDescription').textContent = p.description || '';
  (function(){
  let displayUid = p.uid;
  if(typeof displayUid === 'string' && /[a-zA-Z]/.test(displayUid)){
    const digits = displayUid.replace(/\D/g,'');
    displayUid = digits || displayUid.slice(0,12); // show digits if present, else a short preview
  }
  document.getElementById('profileUID').textContent = displayUid;
})();
  document.getElementById('profileAge').textContent=p.age;
  document.getElementById('profileSkill').textContent=p.skill;
  {
  let parts = [];
  if (p.address) parts.push(p.address);
  if (p.city && (!p.address || !p.address.toLowerCase().includes(p.city.toLowerCase()))) {
    parts.push(p.city);
  }
  if (p.district) parts.push(p.district);
  if (p.state) parts.push(p.state);
  {
  let parts = [];
  if (p.address) parts.push(p.address);
  if (p.city && (!p.address || !p.address.toLowerCase().includes(p.city.toLowerCase()))) {
    parts.push(p.city);
  }
  if (p.district) parts.push(p.district);
  if (p.state) parts.push(p.state);
  document.getElementById('profileAddress').textContent = parts.join(', ');
}
}
  document.getElementById('profileLanguage').textContent=p.language;
  document.getElementById('profileStatus').textContent = p.status ? p.status : 'Free';

  // avatar initials
  const initials = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
  const avatar = document.getElementById('profileAvatar');
  avatar.textContent = initials;

  // update save button label/state
  updateSaveButtonState();
}

function closeProfile(){ showPage('categoriesPage'); currentOpenProfile=null; }

function toggleMenu(){
  const dd=document.getElementById("menuDropdown");
  dd.style.display = dd.style.display==="flex"?"none":"flex";
}

function displaySaved(){
  const c=document.getElementById("savedList");
  c.innerHTML="";
  const search=document.getElementById("savedSearchInput")?document.getElementById("savedSearchInput").value.toLowerCase():"";
  savedProfiles.filter(p=>{
    const skillMatch=savedSkill==='All'||p.skill===savedSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return skillMatch&&searchMatch;
  }).forEach(p=>{
    const box=document.createElement('div'); box.className="profile-box";
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    const locSpan=document.createElement('div'); locSpan.style.fontSize='12px'; locSpan.style.color='#374151'; locSpan.textContent = buildLocationString(p); nameContainer.appendChild(locSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê'; saveBtn.className='save-btn saved';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    c.appendChild(box);
  });
}

/* HIRE modal logic */
function openHireModal(){
  if(!currentOpenProfile){ alert('No profile selected.'); return; }
  const modal=document.getElementById('hireModal');
  modal.classList.add('open');
  document.getElementById('modalResult').innerHTML = '';
}

function closeHireModal(){
  const modal=document.getElementById('hireModal');
  modal.classList.remove('open');
  document.getElementById('modalResult').innerHTML = '';
}

function modalBackgroundClick(e){
  if(e.target && e.target.id === 'hireModal') closeHireModal();
}

function showContact(){
  if(!currentOpenProfile) return;
  const modalResult = document.getElementById('modalResult');
  // show contact with gentle privacy warning
  modalResult.innerHTML = `
    <div><strong>Contact No.:</strong> <span id="visibleContact">${escapeHtml(currentOpenProfile.contact)}</span></div>
    <div class="note">Click 'Hire ‚Üí Contact' to view the number.</div>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button class="contact-btn copy-btn" onclick="copyToClipboard('${escapeJs(currentOpenProfile.contact)}')">üìã Copy</button>
      <button class="contact-btn close-btn" onclick="closeHireModal()">‚úñ Close</button>
    </div>
  `;
}

function showMessage(){
  // Open the chat page for the profile selected in the Hire modal
  if(!currentOpenProfile) return;
  try{ closeHireModal(); }catch(e){}
  try{ openChat(currentOpenProfile); }catch(e){}
}
/* Copy helper (uses Clipboard API when available) */
function copyToClipboard(text){
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(()=> {
      alert('Contact copied to clipboard.');
    }, ()=> {
      fallbackCopy(text);
    });
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text){
  const ta = document.createElement('textarea');
  ta.value=text; document.body.appendChild(ta);
  ta.select();
  try { document.execCommand('copy'); alert('Contact copied to clipboard.'); } catch(e){ alert('Copy failed ‚Äî please copy manually: '+text); }
  ta.remove();
}

/* Save toggle from open profile */
function toggleSaveFromOpen(){
  if(!currentOpenProfile) return;
  saveProfile(currentOpenProfile);
  updateSaveButtonState();
}

function updateSaveButtonState(){
  const btn=document.getElementById('saveBtn');
  if(!currentOpenProfile){ btn.textContent='‚≠ê Save'; return; }
  if(savedProfiles.some(sp=>sp.uid===currentOpenProfile.uid)){
    btn.textContent='‚≠ê Saved';
    btn.style.background='linear-gradient(90deg,#fde68a,#f97316)';
    btn.style.color='#111';
  } else {
    btn.textContent='‚≠ê Save';
    btn.style.background='transparent';
    btn.style.color='#fff';
  }
}





/* ===== Leaderboards Logic (final clean with animations) ===== */
function switchLeaderboard(type){
  const tabs=document.querySelectorAll('.leaderboard-tabs button');
  tabs.forEach(btn=>btn.classList.remove('active'));
  if(type==='hired') tabs[0].classList.add('active');
  if(type==='alltime') tabs[1].classList.add('active');
  if(type==='rated') tabs[2].classList.add('active');

  const container=document.getElementById('leaderboardList');
  if(container){
    container.classList.add('fade-out');
    setTimeout(()=>{
      renderLeaderboard(type);
      container.classList.remove('fade-out');
    },300);
  } else {
    renderLeaderboard(type);
  }
}


/* --- normalize ratings across different possible field names and compute averages/percent --- */
function normalizeRatingsForProfiles(){
  try{
    (window.profiles || []).forEach(function(p){
      p.ratingsSum = Number(p.ratingsSum || p.ratings || p.rating || 0);
      p.ratingsCount = Number(p.ratingsCount || p.ratings_count || p.votes || 0);
      p.ratingsAvg = p.ratingsCount ? (p.ratingsSum / p.ratingsCount) : 0;
      p.ratingPct = p.ratingsCount ? Math.round((p.ratingsAvg / 5) * 100) : 0;
      // keep legacy `ratings` field as a readable average (1 decimal)
      p.ratings = Math.round(p.ratingsAvg * 10) / 10;
    });
  }catch(e){
    console.warn('normalizeRatingsForProfiles failed', e);
  }
}



function renderLeaderboard(type){
  try{ normalizeRatingsForProfiles(); }catch(e){ console.warn('normalizeRatingsForProfiles failed', e); }

  const container=document.getElementById('leaderboardList');
  if(!container) return;
  container.innerHTML='';

  if(!profiles || profiles.length===0){
    container.innerHTML='<div style="text-align:center;color:#6b7280;font-weight:600;">No profiles to show yet</div>';
    return;
  }

  // make a shallow copy and ensure numeric fields
  const list = (profiles || []).map(function(p){
    p = Object.assign({}, p);
    p.hireCount = Number(p.hireCount || p.hires || 0);
    p.allTimeHires = Number(p.allTimeHires || p.allTime || p.hireCount || 0);
    p.ratingsSum = Number(p.ratingsSum || p.ratings || p.rating || 0);
    p.ratingsCount = Number(p.ratingsCount || p.ratings_count || p.votes || 0);
    p.ratingsAvg = p.ratingsCount ? (p.ratingsSum / p.ratingsCount) : 0;
    p.ratingPct = p.ratingsCount ? Math.round((p.ratingsAvg / 5) * 100) : 0;
    return p;
  });

  // sort depending on type
  if(type==='hired'){ list.sort((a,b)=> (b.hireCount - a.hireCount) || (b.ratingPct - a.ratingPct)); }
  else if(type==='alltime'){ list.sort((a,b)=> (b.allTimeHires - a.allTimeHires) || (b.ratingPct - a.ratingPct)); }
  else { // rated
    list.sort((a,b)=> (b.ratingPct - a.ratingPct) || (b.hireCount - a.hireCount));
  }

  list.slice(0,10).forEach(function(p,i){
    const rank = i+1;
    const card = document.createElement('div'); card.className = 'leader-card';
    if(i===0) card.classList.add('top1');
    if(i===1) card.classList.add('top2');
    if(i===2) card.classList.add('top3');
    card.style.animationDelay = (i*0.08) + 's';

    const rankBox = document.createElement('div'); rankBox.className = 'leader-rank';
    if(rank===1) rankBox.classList.add('leader-gold');
    else if(rank===2) rankBox.classList.add('leader-silver');
    else if(rank===3) rankBox.classList.add('leader-bronze');
    rankBox.innerHTML = '<span style="font-weight:900; font-size:22px;">' + rank + '</span>';

    const info = document.createElement('div'); info.className = 'leader-info';
    const nameEl = document.createElement('strong'); nameEl.textContent = p.name || ('UID ' + (p.uid || '‚Äî'));
    info.appendChild(nameEl);
    const uidEl = document.createElement('div'); uidEl.className = 'uid'; uidEl.textContent = 'UID: ' + (p.uid || '‚Äî');
    info.appendChild(uidEl);

    // compute display values safely
    const totalVotes = Number(p.ratingsCount || 0);
    const avgNum = totalVotes > 0 ? Number(p.ratingsAvg || (p.ratingsSum / totalVotes) || 0) : 0;
    const avg = totalVotes > 0 ? (Math.round(avgNum*10)/10).toFixed(1) : '0';
    const pct = totalVotes > 0 ? Math.round((avgNum/5) * 100) : 0;

    const meta = document.createElement('div'); meta.className = 'meta';
    let metaText = '';
    if(type==='hired'){
      metaText = 'Hires: ' + (p.hireCount||0) + ' ¬∑ Avg: ' + avg + ' /5 (' + pct + '%) ¬∑ ' + totalVotes + ' votes';
    } else if(type==='alltime'){
      metaText = 'All-Time Hires: ' + (p.allTimeHires||0) + ' ¬∑ Avg: ' + avg + ' /5 ¬∑ ' + totalVotes + ' votes (' + pct + '%)';
    } else {
      metaText = 'Avg: ' + avg + ' /5 ¬∑ ' + totalVotes + ' votes (' + pct + '%)';
    }
    meta.textContent = metaText;
    info.appendChild(meta);

    card.appendChild(rankBox);
    card.appendChild(info);
    container.appendChild(card);
  });

  // ensure leaderboard page is visible
  try{ /* leaderboard showPage removed on purpose */ }catch(e){}
}


// Auto-load Most Hired when opening leaderboard page
document.addEventListener('DOMContentLoaded', ()=>{
  const lbPage=document.getElementById('leaderboardPage');
  if(lbPage){ switchLeaderboard('hired'); }
});


/* small helper to escape content inserted into HTML */
function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
}
/* escape for JS single-quoted string insertion */
function escapeJs(str){
  if(!str) return '';
  return String(str).replace(/\\/g,'\\\').replace(/'/g,"\'");
}



/* ===== Chat + Messaging System (fixed + improvements) ===== */
// Persistent storage keys
const STORAGE_KEYS = {
  MESSAGES: 'profiles_messages_v1',
  UNREAD: 'profiles_unread_notifications_v1',
  READ: 'profiles_read_notifications_v1'
};

// Data structures
let messages = {}; // { uid: [ {from:'me'|'them', text, time, seen:boolean}, ... ] }
let unreadNotifications = []; // [{uid,name,lastMessage,time}, ...]
let readNotifications = [];
let currentChatUID = null;
let lastNotificationTab = 'unread'; // remember last notifications tab so we can return to it
let notificationTabBeforeChat = null; // stores which tab the user was on BEFORE opening chat

// Load from localStorage
function loadMessagingState() {
  try {
    const rawMsgs = localStorage.getItem(STORAGE_KEYS.MESSAGES);
    messages = rawMsgs ? JSON.parse(rawMsgs) : {};
  } catch(e) { messages = {}; }
  try {
    const rawUnread = localStorage.getItem(STORAGE_KEYS.UNREAD);
    unreadNotifications = rawUnread ? JSON.parse(rawUnread) : [];
  } catch(e){ unreadNotifications = []; }
  try {
    const rawRead = localStorage.getItem(STORAGE_KEYS.READ);
    readNotifications = rawRead ? JSON.parse(rawRead) : [];
  } catch(e){ readNotifications = []; }
  updateNotificationBadge();
}

// Save to localStorage
function saveMessagingState() {
  try { localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(messages)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.UNREAD, JSON.stringify(unreadNotifications)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.READ, JSON.stringify(readNotifications)); } catch(e){}
  updateNotificationBadge();
}

// Utility to truncate preview
function previewText(t, len=80){
  if(!t) return '';
  return t.length>len ? t.slice(0,len-1)+'‚Ä¶' : t;
}

// Update bell badge (red circle)
function updateNotificationBadge() {
  const bellWrap = document.getElementById("bellWrap");
  if (!bellWrap) return;
  let count = unreadNotifications.length;
  let badge = bellWrap.querySelector(".bell-badge");
  if (count > 0) {
    if (!badge) {
      badge = document.createElement("span");
      badge.className = "bell-badge";
      bellWrap.appendChild(badge);
    }
    badge.textContent = count;
  } else {
    if (badge) badge.remove();
  }
}

let lastOpenedProfile = null; // store the profile you came from

// Open chat with a profile object {uid,name}
function openChat(profile) {
  if (!profile) return;

  // remember which profile you were viewing
  lastOpenedProfile = profile;

  // remember the notifications tab the user was on before opening chat
  notificationTabBeforeChat = lastNotificationTab || 'unread';
  currentChatUID = profile.uid;
  // load conversation messages from Firestore and attach realtime listener
  try{ if(typeof db !== 'undefined' && typeof myUID !== 'undefined' && myUID){ listenToChatMessages(myUID, profile.uid); loadChatMessagesOnce(myUID, profile.uid); } }catch(e){}

  const nameEl = document.getElementById("chatWithName");
  if (nameEl) nameEl.textContent = profile.name || "Chat";

  // Hide top icons while chatting
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "none";
  if (bellWrap) bellWrap.style.display = "none";

  showPage("chatPage");
  renderChat();
updateChatHireButton();
  }

// Back from chat
function backFromChat() {
  // restore top icons
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "inline-block";
  if (bellWrap) bellWrap.style.display = "inline-block";

  // If a profile was open before chat ‚Üí go back there
  if (lastOpenedProfile) {
    openProfile(lastOpenedProfile); 
  } else {
    // fallback ‚Üí go to notifications (like your old logic)
    showPage('notificationsPage');
    switchTab(lastNotificationTab || 'unread');
  }
}

// Render chat messages for currentChatUID
function renderChat() {
  const container = document.getElementById("chatMessages");
  if (!container) return;
  container.innerHTML = "";
  if (!currentChatUID) {
    container.textContent = "No conversation selected.";
    return;
  }
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].forEach(m => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.marginBottom = "8px";
    row.style.alignItems = "flex-end";
    // bubble
    const bubble = document.createElement("div");
    bubble.textContent = m.text;
    bubble.style.maxWidth = "70%";
    bubble.style.padding = "10px 14px";
    bubble.style.borderRadius = "14px";
    bubble.style.wordBreak = "break-word";
    bubble.style.boxShadow = "0 6px 18px rgba(2,6,23,0.06)";
    // time small
    const timeSpan = document.createElement("div");
    timeSpan.textContent = m.time || "";
    timeSpan.style.fontSize = "11px";
    timeSpan.style.marginTop = "6px";
    timeSpan.style.opacity = "0.8";
    timeSpan.style.fontWeight = "600";
    if (m.from === "me") {
      row.style.justifyContent = "flex-end";
      bubble.style.background = "linear-gradient(90deg,#0077ff,#2aa0ff)";
      bubble.style.color = "#fff";
      // seen indicator
      const wrapper = document.createElement("div");
      wrapper.style.textAlign = "right";
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.display = "flex";
      meta.style.justifyContent = "flex-end";
      meta.style.gap = "8px";
      meta.style.alignItems = "center";
      const seenSpan = document.createElement("span");
      seenSpan.style.fontSize = "12px";
      seenSpan.style.opacity = m.seen ? "1" : "0.35";
      seenSpan.style.color = m.seen ? "#34d399" : "#e2e8f0"; // green when seen
      seenSpan.textContent = m.seen ? "‚úì‚úì Seen" : "‚úì Sent";
      meta.appendChild(timeSpan);
      meta.appendChild(seenSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    } else {
      row.style.justifyContent = "flex-start";
      bubble.style.background = "#e5e7eb";
      bubble.style.color = "#111";
      const wrapper = document.createElement("div");
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.marginTop = "6px";
      meta.appendChild(timeSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    }
    container.appendChild(row);
  });
  // scroll to bottom
  container.scrollTop = container.scrollHeight;
}

// Send a message from "me" to the currently opened profile
function sendMessage() {
  const input = document.getElementById("chatInput");
  if (!input) return;
  const text = input.value.trim();
  if (!text || !currentChatUID) return;
  const time = (new Date()).toLocaleString();
  const msg = {from: "me", text, time, seen: false};
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].push(msg);
  // Update / create unread notification for this profile (it represents the message waiting to be read)
  const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
  const existing = unreadNotifications.find(n => n.uid === currentChatUID);
  if (existing) {
    existing.lastMessage = text;
    existing.time = time;
  } else {
    unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
  }
  saveMessagingState();
  input.value = "";
  renderChat();
  // don't force switch to 'unread' ‚Äî keep user's current context (requested change)
}

// Helper to get profile name by UID from profiles array
function getProfileNameByUID(uid) {
  try {
    const p = profiles.find(x => x.uid === uid);
    return p ? p.name : null;
  } catch(e){ return null; }
}

// Mark a notification as read (move to readNotifications) and mark messages as seen
function markAsReadByUID(uid) {
  const idx = unreadNotifications.findIndex(n => n.uid === uid);
  if (idx === -1) return;
  const n = unreadNotifications.splice(idx,1)[0];
  readNotifications.unshift(n);
  // mark 'me' messages as seen for that conversation
  if (messages[uid]) {
    messages[uid].forEach(m => { if (m.from === "me") m.seen = true; });
  }
  saveMessagingState();
  // after marking read, show the Read tab (so user can use Delete / Reply)
  switchTab('read');
}

// Delete a notification from the read list
function deleteReadNotification(uid){
  const i = readNotifications.findIndex(x => x.uid === uid);
  if(i === -1) return;
  if(!confirm('Delete this read notification?')) return;
  readNotifications.splice(i,1);
  saveMessagingState();
  switchTab('read');
}

// Render notifications for current tab (unread/read)
function switchTab(tab){
  // remember last selected tab so we can return to it after opening chat
  lastNotificationTab = tab;
  document.querySelectorAll(".tabs button").forEach(btn=>btn.classList.remove("active"));
  const tabBtn = document.getElementById("tab-"+tab);
  if (tabBtn) tabBtn.classList.add("active");
  const content=document.getElementById("notificationContent");
  if (!content) return;
  content.innerHTML="";
  if(tab==="unread"){
    if(unreadNotifications.length===0){ content.textContent="No unread notifications."; updateNotificationBadge(); return; }
    unreadNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.08)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const readBtn = document.createElement("button"); readBtn.className = "notif-btn read-btn"; readBtn.textContent = "Mark as Read";
      readBtn.onclick = function(){ markAsReadByUID(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(readBtn);
      box.appendChild(actions);
      content.appendChild(box);
    });
  } else if(tab==="read"){
    if(readNotifications.length===0){ content.textContent="No read notifications."; return; }
    readNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.06)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);

      // add Reply + Delete buttons for read items (new: user requested)
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const delBtn = document.createElement("button"); delBtn.className = "notif-btn"; delBtn.style.background = "linear-gradient(90deg,#ef4444,#f97316)"; delBtn.style.color = "#fff"; delBtn.textContent = "Delete";
      delBtn.onclick = function(){ deleteReadNotification(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(delBtn);
      box.appendChild(actions);

      content.appendChild(box);
    });
  } else if(tab==="hire") {
    content.textContent = "No hire notifications.";
  } else {
    content.textContent="No "+tab+" notifications.";
  }
  updateNotificationBadge();
}

// Overwrite showMessage to open chat from Hire modal
function showMessage(){
  // Open the chat page for the profile selected in the Hire modal
  if(!currentOpenProfile) return;
  try{ closeHireModal(); }catch(e){}
  try{ openChat(currentOpenProfile); }catch(e){}
}
// Initialize on load
loadMessagingState();
/* ===== End Chat System ===== */
/* Start on home */
showPage('home');

</script>
<!-- BEGIN: Added script ‚Äî Simulate Profile-Owner Replies & Improved Notification Routing -->
<script>
/* Enhancements: profile-owner reply simulation and improved notification routing */


/* ===== UID migration & safety patch (ensures profile UID stays numeric-only; separates account UID) ===== */
(function(){
  // helpers to store account vs profile ids separately
  window.setAccountUID = function(uid){
    try{ localStorage.setItem('profiles_account_uid_v1', String(uid)); window.myAccountUID = String(uid); }catch(e){}
  };
  window.setProfileUID = function(uid){
    try{ localStorage.setItem('profiles_my_uid_v1', String(uid)); window.myUID = isNaN(uid) ? String(uid) : Number(uid); }catch(e){}
  };

  try{
    // If older versions accidentally stored a Firebase (alphanumeric) auth UID in the profile key,
    // migrate it to the dedicated account key so the profile key remains numeric-only.
    const raw = localStorage.getItem('profiles_my_uid_v1');
    if(raw && /[a-zA-Z]/.test(raw)){
      localStorage.setItem('profiles_account_uid_v1', raw);
      localStorage.removeItem('profiles_my_uid_v1');
      window.myAccountUID = raw;
      console.info('UID patch: migrated auth id from profiles_my_uid_v1 to profiles_account_uid_v1');
    }
    // expose both values at runtime
    window.myAccountUID = window.myAccountUID || localStorage.getItem('profiles_account_uid_v1') || null;
    const storedProfile = localStorage.getItem('profiles_my_uid_v1');
    window.myUID = (typeof window.myUID !== 'undefined' && window.myUID) ? window.myUID : (storedProfile ? (isNaN(storedProfile) ? storedProfile : Number(storedProfile)) : null);
  }catch(e){ console.warn('UID migration patch failed', e); }

  // Monkeypatch setItem to avoid accidental future writes of alphanumeric auth UIDs into the profile key.
  try{
    const _orig = localStorage.setItem.bind(localStorage);
    localStorage.setItem = function(k,v){
      try{
        if(k==='profiles_my_uid_v1' && /[a-zA-Z]/.test(String(v))){
          // redirect to account key instead
          _orig('profiles_account_uid_v1', String(v));
          window.myAccountUID = String(v);
          console.warn('UID patch: redirected write to profiles_account_uid_v1 because value contained letters.');
          return;
        }
      }catch(e){/* ignore and fall through */}
      return _orig(k, v);
    };
  }catch(e){ /* if monkeypatching fails, don't break the app */ }
})();
/* ===== end UID migration & safety patch ===== */
/* persist/remember a "myUID" for the current browser user (set when profile is saved) */
let myUID = null;
try {
  const s = localStorage.getItem('profiles_my_uid_v1');
  if (s) myUID = isNaN(s) ? s : Number(s);
} catch(e){ myUID = null; }

/* ensure we capture the profile save action and store myUID after the existing profile form runs */
(function(){
  const form = document.getElementById('profileForm');
  if (!form) return;
  form.addEventListener('submit', function(){
    // after the original submit handler runs it sets myProfile ‚Äî wait a bit and capture it
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          setProfileUID(myProfile.uid);
        }
      } catch(e){}
    }, 60);
  });
})();

/* override sendMessage so messages include fromUid/toUid and notifications go to the recipient */
(function(){
  const originalSend = window.sendMessage;
  window.sendMessage = function(){
    const input = document.getElementById("chatInput");
    if (!input) return;
    const text = input.value.trim();
    if (!text || !currentChatUID) return;
    const time = (new Date()).toLocaleString();
    if (!messages[currentChatUID]) messages[currentChatUID] = [];
    const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
    const msg = {from: "me", text: text, time: time, seen: false, fromUid: fromUid, toUid: currentChatUID};
    messages[currentChatUID].push(msg);

    // Update / create unread notification FOR THE RECIPIENT (simulate that the recipient has an unread)
    const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
    const existing = unreadNotifications.find(n => n.uid === currentChatUID);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
    }
    saveMessagingState();
    input.value = "";
    renderChat();
  };
})();

/* Function to simulate a reply originating from the profile owner (this will add a message 'from them' and create
   a simulated unread notification FOR THE SENDER ‚Äî stored in localStorage under 'profiles_unread_for_others_v1') */
function simulateProfileOwnerReply(uid, name) {
  const text = prompt('Type reply from profile owner to send to ' + (name || uid) + ':');
  if (!text) return;
  const time = (new Date()).toLocaleString();
  if (!messages[uid]) messages[uid] = [];
  const ownerUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'owner';
  const msg = {from: "them", text: text, time: time, seen: false, fromUid: ownerUid, toUid: uid};
  messages[uid].push(msg);

  // create/update the simulated unread for the sender (stored separately so it represents "the other user's unread")
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    const existing = otherUnread.find(n => n.uid === uid);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      otherUnread.push({uid: uid, name: name || getProfileNameByUID(uid) || 'Unknown', lastMessage: text, time});
    }
    localStorage.setItem(key, JSON.stringify(otherUnread));
  } catch(e){ console.warn('simulateProfileOwnerReply storage failed', e); }

  saveMessagingState();
  alert('Reply sent as profile owner. Simulated unread for the sender created (localStorage key: profiles_unread_for_others_v1).');
}

/* Optional helper: show the simulated "other users' unread" (useful for debugging/testing)
   This does not modify the original UI but can be called from the console:
   window.showSimulatedOtherUnread();
*/
function showSimulatedOtherUnread(){
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    if (!otherUnread.length) { alert('No simulated unread entries for other users.'); return; }
    let out = 'Simulated unread entries for OTHER users:\\n\\n';
    otherUnread.forEach(n => { out += `${n.name} (uid: ${n.uid}) ‚Äî ${n.lastMessage} ‚Äî ${n.time}\\n`; });
    alert(out);
  } catch(e){ alert('Unable to read simulated unread storage.'); }
}

/* end added script */
</script>
<!-- END: Added script -->
<!-- BEGIN: Assistant-added: Hire Complete + OTP verification + Hire count -->
<script>
(function(){

const OTP_STORAGE_KEY = 'profiles_pending_otp_v1';
const PROFILES_PERSIST_KEY = 'profiles_data_v1';

// load profiles from storage if present (merge with in-memory 'profiles' variable)
try {
  const raw = localStorage.getItem(PROFILES_PERSIST_KEY);
  if (raw) {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      // merge without overwriting existing in-memory profiles (keep latest by uid)
      parsed.forEach(storedP => {
        const idx = profiles.findIndex(p => String(p.uid) === String(storedP.uid));
        if (idx === -1) profiles.push(storedP);
        else profiles[idx] = Object.assign({}, profiles[idx], storedP);
      });
    }
  }
} catch(e){ console.warn('Failed to load persisted profiles:', e); }

function saveProfilesToStorage() {
  try { localStorage.setItem(PROFILES_PERSIST_KEY, JSON.stringify(profiles)); } catch(e){ console.warn(e); }
}

// ensure hireCount exists for all profiles
(function ensureHireCounts(){
  let changed = false;
  profiles.forEach(p => { if (typeof p.hireCount === 'undefined') { p.hireCount = 0; changed = true; } });
  if (changed) saveProfilesToStorage();
})();

// after profile form submit (original script writes myProfile), make sure myProfile has hireCount and persist
const profileForm = document.getElementById('profileForm');
if (profileForm) {
  profileForm.addEventListener('submit', function(){
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          if (typeof myProfile.hireCount === 'undefined') myProfile.hireCount = 0;
          const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
          if (idx !== -1) profiles[idx] = myProfile;
          else profiles.push(myProfile);
          saveProfilesToStorage();
          localStorage.setItem('profiles_my_uid_v1', String(myProfile.uid));
          myUID = myProfile.uid;
        }
      } catch(e){ console.warn(e); }
    }, 80);
  });
}

// override openProfile to display hires count (decorate existing function)
if (window.openProfile) {
  const origOpenProfile = window.openProfile;
  window.openProfile = function(p){
    try { origOpenProfile(p); } catch(e){ console.warn('orig openProfile failed', e); }
    // ensure profile object has hireCount
    const stored = profiles.find(x => String(x.uid) === String(p.uid)) || p;
    if (typeof stored.hireCount === 'undefined') stored.hireCount = 0;
    // create or update hires element
    let el = document.getElementById('profileHireCount');
    const container = document.querySelector('.profile-header .profile-head-info');
    if (!container) return;
    if (!el) {
      el = document.createElement('div');
      el.id = 'profileHireCount';
      el.style.marginTop = '8px';
      el.style.fontWeight = '800';
      el.style.color = '#ffd6e0';
      container.appendChild(el);
    }
    el.textContent = 'Hires: ' + (stored.hireCount || 0);
  };
}


// Conditional chat "Hire Complete" button: shown ONLY when current user is the profile owner (and chatting with someone else)
function updateChatHireButton(){
  const header = document.querySelector('#chatPage > div');
  if (!header) return;
  const existing = header.querySelector('.hire-complete-chat-btn');
  // Show only when: myUID exists, myProfile exists and matches myUID, and currentChatUID is set and != myUID
  const canShow = (typeof myUID !== 'undefined' && myUID !== null) 
                   && (typeof myProfile !== 'undefined' && myProfile && String(myProfile.uid) === String(myUID))
                   && (typeof currentChatUID !== 'undefined' && currentChatUID && String(currentChatUID) !== String(myUID));
  if (canShow) {
    if (existing) return;
    const hireBtn = document.createElement('button');
    hireBtn.textContent = 'Hire Complete';
    hireBtn.className = 'hire-complete-chat-btn';
    hireBtn.style.marginLeft = '8px';
    hireBtn.style.padding = '8px 12px';
    hireBtn.style.borderRadius = '8px';
    hireBtn.style.border = 'none';
    hireBtn.style.cursor = 'pointer';
    hireBtn.style.fontWeight = '800';
    hireBtn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
    hireBtn.style.color = '#fff';
    hireBtn.onclick = function(){
      if (!currentChatUID) { alert('Open a chat first.'); return; }
      const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
      const toUid = currentChatUID;
      const toName = document.getElementById('chatWithName')?.textContent || '';
      // send OTP to the other user
      try { sendHireOTP(fromUid, toUid, toName); } catch(e){ console.warn('sendHireOTP failed', e); alert('Failed to send OTP'); }
    };
    header.appendChild(hireBtn);
  } else {
    if (existing) existing.remove();
  }
}
// sendHireOTP: create pending OTP record in localStorage and notify

// sendHireOTP: create pending OTP record in localStorage, notify via event, and persist to Firestore (users/{toUid}/notifications) for the recipient.
function sendHireOTP(fromUid, toUid, toName) {
  try {
    const otp = String(Math.floor(100000 + Math.random()*900000));
    const time = (new Date()).toISOString();
    const rec = { otp: otp, fromUid: String(fromUid), toUid: String(toUid), time: time, toName: toName || '' };
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    arr.push(rec);
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));

    // For local testing: create a simulated unread entry for the recipient so they can see the OTP event when they open their app.
    try {
      const key = 'profiles_unread_for_others_v1';
      const raw2 = localStorage.getItem(key);
      const otherUnread = raw2 ? JSON.parse(raw2) : [];
      otherUnread.push({ uid: String(toUid), name: toName || getProfileNameByUID(toUid) || ('UID '+String(toUid)), lastMessage: 'Hire OTP sent', time: (new Date()).toLocaleString() });
      localStorage.setItem(key, JSON.stringify(otherUnread));
    } catch(e){ console.warn('failed to write simulated other-unread', e); }

    // Also attempt to persist a notification record for the recipient in Firestore (so other devices/tabs can pick it up)
    try {
      if (typeof db !== 'undefined' && db && toUid) {
        const notif = { fromUid: String(fromUid), name: toName || getProfileNameByUID(fromUid) || '', lastMessage: 'Hire OTP sent', time: new Date().toISOString(), type: 'otp', otp: otp };
        db.collection('users').doc(String(toUid)).collection('notifications').add(notif).then(()=> {
          try{ if(typeof setFBStatus === 'function') setFBStatus('OTP notif saved'); }catch(e){}
        }).catch(e=> { console.warn('OTP notif save failed', e); });
      }
    } catch(e){ console.warn('firestore write for OTP failed', e); }

    // dispatch a same-tab event so a listening recipient tab (if present) will show the OTP modal
    window.dispatchEvent(new CustomEvent('profiles-otp-sent', {detail: rec}));

    // For developer/testing we show OTP to the sender in a small non-blocking box (remove in production)
    try{ document.getElementById('otpSentBox')?.remove(); }catch(e){}
    const otpBox = document.createElement('div');
    otpBox.id = 'otpSentBox';
    otpBox.className = 'otp-card';
    otpBox.style.position = 'fixed';
    otpBox.style.right = '20px';
    otpBox.style.bottom = '20px';
    otpBox.style.zIndex = 100000;
    otpBox.innerHTML = `
      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
        <div>
          <div style="font-weight:800">OTP sent to ${escapeHtml(toName || toUid)}</div>
          <div style="margin-top:6px;font-weight:900;font-family:monospace;">Code (testing): ${otp}</div>
        </div>
        <div>
          <button onclick="document.getElementById('otpSentBox')?.remove()" style="padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:800;background:linear-gradient(90deg,#ef4444,#f97316);color:#fff;">Close</button>
        </div>
      </div>`;
    document.body.appendChild(otpBox);

    // If the local session is the recipient, also add to the local unreadNotifications and show OTP modal
    try {
      if (typeof myUID !== 'undefined' && myUID !== null && String(myUID) === String(toUid)) {
        const existing = unreadNotifications.find(n => String(n.uid) === String(toUid));
        if (existing) {
          existing.lastMessage = 'Hire OTP sent';
          existing.time = (new Date()).toLocaleString();
        } else {
          unreadNotifications.push({ uid: String(toUid), name: toName || getProfileNameByUID(toUid) || ('UID '+String(toUid)), lastMessage: 'Hire OTP sent', time: (new Date()).toLocaleString() });
        }
        saveMessagingState();
        // trigger OTP modal for me
        setTimeout(()=> showPendingOTPModalForMe(), 80);
      }
    } catch(e){ console.warn('local unread update failed', e); }

  } catch(e){ console.warn('sendHireOTP failed', e); alert('Failed to send OTP'); }
}


// showPendingOTPModalForMe: if there's a pending OTP for myUID, prompt to verify
function showPendingOTPModalForMe() {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  let arr = [];
  try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
  const pending = arr.find(r => String(r.toUid) === String(myuid));
  if (!pending) return;
  // avoid duplicate modal
  if (document.getElementById('otpVerifyModal')) return;
  // build modal
  const modal = document.createElement('div');
  modal.id = 'otpVerifyModal';
  modal.className = 'modal open';
  modal.style.zIndex = 99998;
  modal.innerHTML = `
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="otpTitle">
      <button class="modal-close" onclick="document.getElementById('otpVerifyModal')?.remove()">‚úï</button>
      <h4 id="otpTitle">Verify Hire OTP</h4>
      <p class="note">Someone marked a hire complete for your profile. Enter the 6-digit OTP sent to you to confirm.</p>
      <div style="margin-top:8px;">
        <input id="otpInputField" placeholder="Enter 6-digit OTP" style="width:100%; padding:10px; font-size:16px; border-radius:8px; border:1px solid #e8eefb;">
      </div>
      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="otpVerifyBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff;">Verify</button>
        <button id="otpCancelBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:#eef2ff; color:#111;">Cancel</button>
      </div>
      <div id="otpNote" class="note"></div>
    </div>
  `;
  document.body.appendChild(modal);
  document.getElementById('otpCancelBtn').onclick = function(){ modal.remove(); };
  document.getElementById('otpVerifyBtn').onclick = function(){ verifyOTPForMe(document.getElementById('otpInputField').value.trim()); };
}

// verifyOTPForMe: check localStorage pending and validate; if OK increment hire count and remove pending otp
function verifyOTPForMe(value) {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  try {
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    const idx = arr.findIndex(r => String(r.toUid) === String(myuid) && String(r.otp) === String(value));
    if (idx === -1) {
      const note = document.getElementById('otpNote');
      if (note) note.textContent = 'Incorrect OTP. Please try again.';
      return;
    }
    const rec = arr.splice(idx,1)[0];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));
    // increment hireCount on associated profile (the owner)
    const pidx = profiles.findIndex(p => String(p.uid) === String(myuid));
    if (pidx !== -1) {
      profiles[pidx].hireCount = (profiles[pidx].hireCount || 0) + 1;
    } else {
      profiles.push({ uid: myuid, name: rec.toName || 'Profile', hireCount: 1 });
    }
    saveProfilesToStorage();
    // update UI if open profile is the same user
    const el = document.getElementById('profileHireCount');
    if (el) {
      const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
      el.textContent = 'Hires: ' + cnt;
    }
    // feedback
    alert('OTP verified. Hire marked complete ‚Äî hire count incremented.');
    // remove modal
    document.getElementById('otpVerifyModal')?.remove();
    // push a small read notification for record
    readNotifications.unshift({ uid: myuid, name: getProfileNameByUID(myuid) || 'Profile', lastMessage: 'Hire completed (verified)', time: new Date().toLocaleString() });
    saveMessagingState();
    switchTab('read');
  } catch(e){ console.warn(e); }
}

// react to storage events (other tabs)
window.addEventListener('storage', function(e){
  if (e.key === OTP_STORAGE_KEY) setTimeout(()=> showPendingOTPModalForMe(), 60);
});

// react to same-tab custom event
window.addEventListener('profiles-otp-sent', function(ev){ setTimeout(()=> showPendingOTPModalForMe(), 60); });

// run on load (in case OTP was stored while tab was inactive)
setTimeout(()=> showPendingOTPModalForMe(), 120);


// Ensure chat header hire button reflects current user state
try{ updateChatHireButton(); }catch(e){}
})(); // end wrapper
</script>
<!-- END: Assistant-added: Hire Complete + OTP verification + Hire count -->
<!-- BEGIN: Leaderboard, Ratings & UID Integration -->
<div class="page" id="leaderboardPage" style="display:none; padding-top:28px;">
<h2 style="text-align:center; margin-top:0;">Leaderboards</h2>
<div aria-label="Leaderboards" class="leaderboard-tabs" role="tablist">
<button class="active" id="lb-tab-hired" onclick="displayLeaderboard('hired')">Top 10 Most Hired</button>
<button id="lb-tab-alltime" onclick="displayLeaderboard('alltime')">Top 10 All Time</button>
<button id="lb-tab-rated" onclick="displayLeaderboard('rated')">Top 10 Most Rated</button>
</div>
<div aria-live="polite" class="leaderboard-list" id="leaderboardList"></div>
<button class="back-btn" onclick="showPage('home')">Back</button>
</div>
<script>

(function(){
  // safety: ensure global profiles exists
  if(typeof profiles === 'undefined') window.profiles = window.profiles || [];
  // helper: ensure fields
  function ensureFields(){
    profiles.forEach(p=>{
      if(typeof p.hireCount === 'undefined') p.hireCount = 0;
      if(typeof p.allTimeHires === 'undefined') p.allTimeHires = p.hireCount || 0;
      if(typeof p.ratingsSum === 'undefined') p.ratingsSum = 0;
      if(typeof p.ratingsCount === 'undefined') p.ratingsCount = 0;
    });
  }
  // compute rating %
  function ratingPctOf(p){ return p.ratingsCount ? Math.round((p.ratingsSum / (p.ratingsCount * 5)) * 100) : 0; }

  // create menu item in 3-dots dropdown
  try{
    const dd = document.getElementById('menuDropdown');

      const el = document.createElement('div');


      el.style.cursor = 'pointer';

      dd.appendChild(el);
    }
  }catch(e){ console.warn('menuDropdown append failed',e); }

  // display leaderboard

    ensureFields();
    // tab active classes
    document.querySelectorAll('.leaderboard-tabs button').forEach(b=>b.classList.remove('active'));
    if(type==='hired') document.getElementById('lb-tab-hired').classList.add('active');
    if(type==='alltime') document.getElementById('lb-tab-alltime').classList.add('active');
    if(type==='rated') document.getElementById('lb-tab-rated').classList.add('active');

    const list = document.getElementById('leaderboardList');
    list.innerHTML = '';
    // compute rating pct for sorting
    const arr = profiles.map(p=>{
      return Object.assign({}, p, { ratingPct: ratingPctOf(p) });
    });
    if(type === 'hired'){
      arr.sort((a,b)=> (b.hireCount - a.hireCount) || (b.ratingPct - a.ratingPct) );
    } else if(type === 'alltime'){
      // All-time uses allTimeHires (cumulative) then rating%
      arr.sort((a,b)=> (b.allTimeHires - a.allTimeHires) || (b.ratingPct - a.ratingPct) );
    } else {
      // rated
      arr.sort((a,b)=> (b.ratingPct - a.ratingPct) || (b.hireCount - a.hireCount) );
    }
    const top = arr.slice(0,10);

    // compute rank numbers but keep same rank for ties (primary + secondary equal)
    let lastPrimary = null, lastSecondary = null, lastRank = 0;
    top.forEach((p, i)=>{
  const rank = i + 1;
  const card = document.createElement('div'); card.className = 'leader-card';

  const rankBox = document.createElement('div'); rankBox.className = 'leader-rank';
  if(rank===1) rankBox.classList.add('leader-gold');
  else if(rank===2) rankBox.classList.add('leader-silver');
  else if(rank===3) rankBox.classList.add('leader-bronze');

  const medal = rank===1 ? ' ü•á' : rank===2 ? ' ü•à' : rank===3 ? ' ü•â' : '';
  rankBox.innerHTML = `<span style="font-weight:900; font-size:22px;">${rank}</span>${medal}`;

  const info = document.createElement('div'); info.className = 'leader-info';
  const nameHtml = document.createElement('div');
  const strong = document.createElement('strong'); strong.textContent = p.name || ('UID ' + (p.uid || '‚Äî'));
  nameHtml.appendChild(strong);
  const uid = document.createElement('div'); uid.className='uid'; uid.textContent = 'UID: ' + (p.uid || '‚Äî');
  nameHtml.appendChild(uid);
  const meta = document.createElement('div'); meta.className='meta';
  if(type==='hired'){
    meta.textContent = 'Hires: ' + (p.hireCount||0);
  } else if(type==='alltime'){
    meta.textContent = 'All-Time Hires: ' + (p.allTimeHires||0) + ' ¬∑ Rating: ' + (p.ratingPct||0) + '%';
  } else {
    meta.textContent = 'Rating: ' + (p.ratingPct||0) + '%';
  }
  info.appendChild(nameHtml);
  info.appendChild(meta);

  card.appendChild(rankBox);
  card.appendChild(info);
  list.appendChild(card);
});
    // ensure we are on leaderboard page
    
  };

  // Override openProfile to inject rating UI (preserve original behavior)
  if(window.openProfile){
    const origOpen = window.openProfile;
    window.openProfile = function(p){
      try{ origOpen(p); } catch(e){ console.warn('orig openProfile error', e); }
      try{
        ensureFields();
        const container = document.querySelector('.profile-header .profile-head-info');
        if(!container) return;
        // remove previous rating container if exists
        const prev = document.getElementById('profileRatingContainer');
        if(prev) prev.remove();

        const rc = document.createElement('div'); rc.id='profileRatingContainer'; rc.className='profile-rating';
        // star row (select-only, no auto submit)
        const starRow = document.createElement('div'); starRow.className='rating-stars';
        const selected = {value:0};
        for(let i=1;i<=5;i++){
          const s = document.createElement('span');
          s.innerHTML = '‚òÖ';
          s.dataset.value = i;
          s.style.userSelect = 'none';
          s.onclick = function(){
            // highlight up to this star
            selected.value = Number(this.dataset.value);
            const stars = starRow.querySelectorAll('span');
            stars.forEach(st => {
              if(Number(st.dataset.value) <= selected.value) st.classList.add('active');
              else st.classList.remove('active');
            });
            // enable submit
            submitBtn.disabled = false;
          };
          starRow.appendChild(s);
        }
        rc.appendChild(starRow);

        // submit button (disabled until selection)
        const submitBtn = document.createElement('button');
        submitBtn.textContent = 'Submit Rating';
        submitBtn.style.marginTop = '8px';
        submitBtn.style.padding = '8px 12px';
        submitBtn.style.borderRadius = '8px';
        submitBtn.style.border = 'none';
        submitBtn.style.cursor = 'pointer';
        submitBtn.style.fontWeight = '800';
        submitBtn.style.background = 'linear-gradient(90deg,#06b6d4,#0ea5a6)';
        submitBtn.style.color = '#fff';
        submitBtn.disabled = true;
        rc.appendChild(submitBtn);

        // rating bar container (hidden until after submit or if already voted)
        const barWrap = document.createElement('div');
        barWrap.style.marginTop = '10px';
        barWrap.style.display = 'block';
        const barOuter = document.createElement('div');
        barOuter.style.width = '100%';
        barOuter.style.height = '14px';
        barOuter.style.background = '#e6eefc';
        barOuter.style.borderRadius = '10px';
        barOuter.style.overflow = 'hidden';
        const barInner = document.createElement('div');
        barInner.style.height = '100%';
        barInner.style.width = '0%';
        barInner.style.transition = 'width 450ms ease';
        barInner.style.background = 'linear-gradient(90deg,#fbbf24,#f97316)';
        barOuter.appendChild(barInner);
        const pctText = document.createElement('div');
        pctText.style.marginTop = '8px';
        pctText.style.fontWeight = '800';
        pctText.style.color = '#0077ff';
        barWrap.appendChild(barOuter);
        barWrap.appendChild(pctText);
        rc.appendChild(barWrap);

        container.appendChild(rc);

        // helper to render rating bar based on profile
        function renderRatingResult(profileObj, hideControls){
          const idx = profiles.findIndex(x=>String(x.uid)===String(profileObj.uid));
          const pct = idx===-1 ? 0 : Math.round(((profiles[idx].ratingsSum || 0) / ((profiles[idx].ratingsCount||0) * 5)) * 100) || 0;
          // show or hide the selection controls depending on whether the user already voted
          if (hideControls) {
            starRow.style.display = 'none';
            submitBtn.style.display = 'none';
          } else {
            starRow.style.display = '';
            submitBtn.style.display = '';
          }
          // rating bar always visible
          barWrap.style.display = 'block';
          // animate bar
          setTimeout(()=>{ barInner.style.width = pct + '%'; }, 50);
          pctText.textContent = 'Ratings: ' + pct + '%';
        }

        // handle submit click
        submitBtn.onclick = function(){
          const score = Number(selected.value || 0);
          if(!score || !p || typeof p.uid === 'undefined'){ alert('Select stars to submit.'); return; }
          // find or create profile entry
          const idx = profiles.findIndex(x=>String(x.uid)===String(p.uid));
          if(idx===-1){
            const newP = { uid: p.uid, name: p.name || ('UID '+p.uid), hireCount: p.hireCount||0, allTimeHires: p.allTimeHires||0, ratingsSum: score, ratingsCount: 1 };
            profiles.push(newP);
          } else {
            profiles[idx].ratingsSum = (profiles[idx].ratingsSum || 0) + score;
            profiles[idx].ratingsCount = (profiles[idx].ratingsCount || 0) + 1;
          }
          // persist profiles
          try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
          // mark voted locally to prevent re-vote
          const votedKey = 'profiles_votes_v1';
          let voted = [];
          try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
          voted.push(String(p.uid)); localStorage.setItem(votedKey, JSON.stringify(voted));
          // show result bar
          renderRatingResult(p, true);
          // refresh leaderboards if visible

        };

        // If already voted -> show bar immediately
        const votedKey = 'profiles_votes_v1';
        let voted = [];
        try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
        renderRatingResult(p, voted.includes(String(p.uid)));}catch(e){ console.warn('rating widget error', e); }
    };
  }  // Wrap verifyOTPForMe to also increment allTimeHires (keeps original behavior)
  if(window.verifyOTPForMe){
    const origVerify = window.verifyOTPForMe;
    window.verifyOTPForMe = function(val){
      try{ origVerify(val); } catch(e){ console.warn('orig verifyOTP failed',e); }
      try{
        const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
        if(!myuid) return;
        ensureFields();
        const idx = profiles.findIndex(p=> String(p.uid) === String(myuid));
        if(idx !== -1){
          profiles[idx].allTimeHires = (profiles[idx].allTimeHires || 0) + 1;
        } else {
          // if profile not present, create minimal entry
          profiles.push({ uid: myuid, name: ('UID '+myuid), hireCount: 0, allTimeHires: 1, ratingsSum:0, ratingsCount:0 });
        }
        // persist
        try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
        // update open profile UI if it's the same profile
        try{
          const el = document.getElementById('profileHireCount');
          if(el){
            const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
            el.textContent = 'Hires: ' + cnt;
          }
        }catch(e){}
      }catch(e){ console.warn('post-verify wrapper error', e); }
    };
  }

  // Expose a helper to force refresh leaderboards externally


  // run an initial ensure
  ensureFields();
})();
</script>
<!-- END: Leaderboard, Ratings & UID Integration -->
<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script>
// Firebase config (from user)
const firebaseConfig = {
  apiKey: "AIzaSyAByLACmttf6BY6r0hEmZKYontfVqnDNpM",
  authDomain: "mndpschoolrspura.firebaseapp.com",
  projectId: "mndpschoolrspura",
  storageBucket: "mndpschoolrspura.firebasestorage.app",
  messagingSenderId: "810534224714",
  appId: "1:810534224714:web:a3055b4a6b3bca507337b3",
  measurementId: "G-2610K130EN"
};

// Init Firebase
const appFB = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// --- Assistant-injected chat sync helpers: load existing messages and add realtime listeners ---
const chatListeners = {};
async function loadChatMessagesOnce(myUid, otherUid){
  try{
    if(!myUid || !otherUid || !db) return;
    const chatId = chatIdFor(myUid, otherUid);
    if(!chatId) return;
    const msgs = [];
    const snap = await db.collection('chats').doc(chatId).collection('messages').orderBy('time').get();
    snap.forEach(doc=>{
      const d = doc.data();
      const fromIsMe = String(d.fromUid) === String(myUid);
      msgs.push({
        from: fromIsMe ? 'me' : 'them',
        text: d.text || d.lastMessage || '',
        time: d.time ? (new Date(d.time)).toLocaleString() : (d.timeString || ''),
        fromUid: d.fromUid,
        toUid: d.toUid,
        seen: !!d.seen
      });
    });
    // store using the other user's id as key (so UI code that uses messages[otherUid] works)
    messages[String(otherUid)] = msgs;
    saveMessagingState();
    if (String(currentChatUID) === String(otherUid)) try{ renderChat(); }catch(e){}
  }catch(e){ console.warn('loadChatMessagesOnce failed', e); }
}

function listenToChatMessages(myUid, otherUid){
  try{
    if(!myUid || !otherUid || !db) return;
    const chatId = chatIdFor(myUid, otherUid);
    if(!chatId) return;
    if(chatListeners[chatId]) return; // already listening
    const ref = db.collection('chats').doc(chatId).collection('messages').orderBy('time');
    chatListeners[chatId] = ref.onSnapshot(snapshot=>{
      const msgs = [];
      snapshot.forEach(doc=>{
        const d = doc.data();
        const fromIsMe = String(d.fromUid) === String(myUid);
        msgs.push({
          from: fromIsMe ? 'me' : 'them',
          text: d.text || d.lastMessage || '',
          time: d.time ? (new Date(d.time)).toLocaleString() : (d.timeString || ''),
          fromUid: d.fromUid,
          toUid: d.toUid,
          seen: !!d.seen
        });
      });
      messages[String(otherUid)] = msgs;
      saveMessagingState();
      if (String(currentChatUID) === String(otherUid)) try{ renderChat(); }catch(e){}
      try{ updateNotificationBadge(); }catch(e){}
    }, err => { console.warn('chat onSnapshot err', err); });
  }catch(e){ console.warn('listenToChatMessages failed', e); }
}
// --- end injection ---

// Status box (black box)
const statusBox = document.createElement('div');
statusBox.id = "firebaseStatusBox";
statusBox.style.position = "fixed";
statusBox.style.bottom = "10px";
statusBox.style.left = "10px";
statusBox.style.padding = "8px 12px";
statusBox.style.background = "#000";
statusBox.style.color = "#0f0";
statusBox.style.fontSize = "12px";
statusBox.style.fontFamily = "monospace";
statusBox.style.borderRadius = "6px";
statusBox.style.zIndex = 99999;
statusBox.textContent = "Firebase: Initializing...";
document.addEventListener("DOMContentLoaded", ()=>document.body.appendChild(statusBox));

function setFBStatus(msg, color="#0f0") {
  const box = document.getElementById("firebaseStatusBox");
  if(box) { box.textContent = "Firebase: " + msg; box.style.color = color; }



// --- BEGIN: Ensure Manage Profile loads the user's profile for editing ---
async function loadMyProfileIfExists() {
  try {
    const storedMy = localStorage.getItem('profiles_my_uid_v1');
    if (!storedMy) return null;
    myUID = String(storedMy);
    // First try users/{myUID} doc to get linked profileUid
    try {
      const userDoc = await db.collection('users').doc(String(myUID)).get();
      if (userDoc.exists) {
        const data = userDoc.data();
        const profileUid = data && data.profileUid ? String(data.profileUid) : null;
        if (profileUid) {
          const profDoc = await db.collection('profiles').doc(String(profileUid)).get();
          if (profDoc.exists) {
            myProfile = profDoc.data();
          }
        }
      }
    } catch(e){ console.warn('loadMyProfile: users lookup failed', e); }
    // Fallback: try find profile in loaded profiles array by myUID
    if (!myProfile) {
      const found = profiles.find(p => String(p.uid) === String(myUID));
      if (found) myProfile = found;
    }
    // If we found a profile, update UI/text
    if (myProfile) {
      const btn = document.getElementById('profileBtn');
      if (btn) btn.textContent = 'Manage Profile';
      // ensure profile is present in profiles array
      const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
      if (idx === -1) profiles.push(myProfile); else profiles[idx] = myProfile;
      setFBStatus('My profile loaded');
      return myProfile;
    }
    return null;
  } catch(err){
    console.warn('loadMyProfileIfExists error', err);
    setFBStatus('MyProfile load err','red');
    return null;
  }
}

// Replace profileBtn click to guarantee we attempt to load myProfile before opening the form
(function patchProfileBtnClick(){
  const btn = document.getElementById('profileBtn');
  if (!btn) return;
  // remove inline onclick if present and add safer async handler
  try { btn.removeAttribute('onclick'); } catch(e){}
  btn.addEventListener('click', async function(evt){
    // if myProfile not yet loaded, try to load it
    if (typeof myProfile === 'undefined' || myProfile === null) {
      await loadMyProfileIfExists();
    }
    // open the form (openProfileForm will detect myProfile and prefill)
    try { openProfileForm(); } catch(e){ console.warn('openProfileForm error', e); }
  });
})();
// --- END manage profile patch ---


}

// Basic profile save/load (will be augmented later)
async function saveProfileToFirebase(profile) {
  try {
    // If the user is authenticated (window.myUID), prefer using that UID for the profile doc id so it's linked.
    const authUid = (typeof window.myUID !== 'undefined' && window.myUID) ? String(window.myUID) : null;
    const profileId = authUid ? authUid : (profile.uid ? String(profile.uid) : String(Date.now()));
    profile.uid = String(profileId);
    // ensure ownerUid is set for traceability
    if(!profile.ownerUid) profile.ownerUid = authUid ? authUid : profile.uid;
    // write profile (merge to avoid overwriting unexpected fields)
    await db.collection("profiles").doc(String(profile.uid)).set(profile, { merge: true });
    setFBStatus("Profile saved ("+profile.uid+")");
    // If we have an authenticated user, link the users/{authUid}.profileUid to this profile
    try {
      if(authUid){
        await db.collection('users').doc(String(authUid)).set({ profileUid: String(profile.uid) }, { merge: true });
        localStorage.setItem('profiles_my_uid_v1', String(profile.uid));
      } else {
        // For anonymous/local users, keep the profile id in localStorage so the UI can find it later
        localStorage.setItem('profiles_my_uid_v1', String(profile.uid));
      }
    }catch(e){ console.warn('linking profile to user failed', e); }
    return profile;
  } catch(e) {
    console.error("Firebase save error", e);
    setFBStatus("Save error: "+(e.message||e), "red");
    throw e;
  }
}

// Load all profiles from Firestore
async function loadProfilesFromFirebase() {
  try {
    const snapshot = await db.collection("profiles").get();
    profiles = [];
    snapshot.forEach(doc => { profiles.push(doc.data()); });
    setFBStatus("Profiles loaded: "+profiles.length);
    displayProfiles();
  } catch(e) {
    console.error("Firebase load error", e);
    setFBStatus("Load error: "+e.message, "red");
  }
}

// Hook profile save event to Firestore (existing form will call saveProfileToFirebase after submit)
(function(){
  const form = document.getElementById('profileForm');
  if(form){
    form.addEventListener('submit', function(){
      setTimeout(()=>{ if(myProfile) saveProfileToFirebase(myProfile); }, 150);
    });
  }
})();

document.addEventListener("DOMContentLoaded", ()=>{
  loadProfilesFromFirebase();
});
</script>
<script>
(function(){
  const db = firebase.firestore();
  const FieldValue = firebase.firestore.FieldValue;

  function chatIdFor(a,b){
    if(a===undefined||b===undefined) return null;
    const sa = String(a), sb = String(b);
    return 'chat_' + (sa < sb ? sa + '_' + sb : sb + '_' + sa);
  }

  async function writeMessageToFirestore(msgObj){
    try{
      const chatId = chatIdFor(msgObj.fromUid, msgObj.toUid);
      if(!chatId) return;
      const chatRef = db.collection('chats').doc(chatId);
      await chatRef.set({ participants: [String(msgObj.fromUid), String(msgObj.toUid)], lastMessage: msgObj.text, lastTime: new Date().toISOString() }, { merge: true });
      await chatRef.collection('messages').add(Object.assign({}, msgObj, { time: new Date().toISOString() }));
      setFBStatus('Message saved');
    }catch(e){ console.warn('writeMessageToFirestore failed', e); setFBStatus('Msg save err','red'); }
  }

  // Wrap existing sendMessage to also persist to Firestore and update recipient notifications
  const origSend = window.sendMessage || function(){};
  window.sendMessage = function(){
    try{ origSend(); }catch(e){ console.warn('origSend failed', e); }
    try{
      if(!currentChatUID) return;
      const arr = messages[currentChatUID] || [];
      const last = arr[arr.length - 1];
      if(last && last.fromUid){
        writeMessageToFirestore(last);
        // create a notification for recipient in users/{toUid}/notifications
        if(last.toUid){
          const notif = { fromUid: String(last.fromUid), name: getProfileNameByUID(last.fromUid) || 'Sender', lastMessage: last.text, time: new Date().toISOString(), read: false };
          db.collection('users').doc(String(last.toUid)).collection('notifications').add(notif).then(()=> setFBStatus('Notif saved')).catch(e=> setFBStatus('Notif save err','red'));
        }
      }
    }catch(e){ console.warn('sendMessage wrapper failed', e); }
  };

  // Wrap existing saveProfile to also update user's savedProfiles on Firestore
  if(window.saveProfile){
    const origSaveProfile = window.saveProfile;
    window.saveProfile = function(p){
      try{ origSaveProfile(p); }catch(e){ console.warn('origSaveProfile failed', e); }
      try{
        if(typeof myUID !== 'undefined' && myUID !== null){
          const userRef = db.collection('users').doc(String(myUID));
          const isSaved = savedProfiles.some(sp => String(sp.uid) === String(p.uid));
          if(isSaved){
            userRef.set({ savedProfiles: firebase.firestore.FieldValue.arrayUnion(String(p.uid)) }, { merge: true });
            setFBStatus('Saved profile synced');
          } else {
            // remove by arrayRemove
            userRef.update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(String(p.uid)) }).then(()=> setFBStatus('Unsaved synced')).catch(()=>{});
          }
        }
      }catch(e){ console.warn('saveProfile-firestore sync failed', e); }
    };
  }

  // Load user-specific document (saved profiles + notifications) and mirror to local app state
  async function loadUserData(uid){
    if(!uid) return;
    try{
      const userDoc = await db.collection('users').doc(String(uid)).get();
      if(userDoc.exists){
        const data = userDoc.data();
        // sync savedProfiles
        if(Array.isArray(data.savedProfiles)){
          savedProfiles = [];
          data.savedProfiles.forEach(pid => {
            const p = profiles.find(x => String(x.uid) === String(pid));
            if(p) savedProfiles.push(p);
          });
          displaySaved();
          updateSaveButtonState();
        }
      }
      // load notifications subcollection for the user
      const notifSnap = await db.collection('users').doc(String(uid)).collection('notifications').get();
      unreadNotifications = [];
      readNotifications = [];
      notifSnap.forEach(doc=>{
        const d = doc.data();
        const obj = { uid: d.fromUid || doc.id, name: d.name || 'Unknown', lastMessage: d.lastMessage || '', time: d.time || '', _docId: doc.id, read: !!d.read };
        if(d.read) readNotifications.push(obj); else unreadNotifications.push(obj);
      });
      saveMessagingState();
      // optionally, load chats where participants contain uid (only metadata to start)
      const chatsSnap = await db.collection('chats').where('participants','array-contains',String(uid)).get();

      // preload messages and attach listeners for chats involving this user (so other devices will sync)
      try{
        chatsSnap.forEach(doc=>{
          try{
            const participants = doc.data().participants || [];
            const other = participants.find(p => String(p) !== String(uid));
            if(other){
              try{ listenToChatMessages(uid, other); }catch(e){}
              try{ loadChatMessagesOnce(uid, other); }catch(e){}
            }
          }catch(e){}
        });
      }catch(e){}

      setFBStatus('User data loaded');
    }catch(e){ console.warn('loadUserData failed', e); setFBStatus('User load err','red'); }
  }

  // On startup, set Manage/Create button depending on stored myUID and Firestore data
  document.addEventListener('DOMContentLoaded', async function(){
    try{
      const storedMy = localStorage.getItem('profiles_my_uid_v1');
      if(storedMy){
        myUID = storedMy;
        const btn = document.getElementById('profileBtn');
        if(btn) btn.textContent = 'Manage Profile';
        await loadUserData(myUID);
        setFBStatus('Ready (user '+String(myUID)+')');
      } else {
        setFBStatus('Ready (no user)');
      }
    }catch(e){ console.warn(e); }
  });

  // Extend saveProfileToFirebase to also create/merge a users/{myUID} doc for saved state & link profile
  if(window.saveProfileToFirebase){
    const origSaveFB = window.saveProfileToFirebase;
    window.saveProfileToFirebase = async function(profile){
      try{ await origSaveFB(profile); }catch(e){ console.warn('origSaveFB failed', e); }
      try{
        const authUid = (typeof window.myUID !== 'undefined' && window.myUID) ? String(window.myUID) : null;
        // If authenticated, link users/{authUid}.profileUid to this profile.
        if(authUid){
          localStorage.setItem('profiles_my_uid_v1', String(profile.uid));
          const userRef = db.collection('users').doc(String(authUid));
          await userRef.set({ profileUid: String(profile.uid) }, { merge: true });
          // ensure profile doc has hireCount & rating fields set
          const profRef = db.collection('profiles').doc(String(profile.uid));
          await profRef.set({ hireCount: Number(profile.hireCount || 0), ratingsCount: Number(profile.ratingsCount || 0) }, { merge: true });
          const btn = document.getElementById('profileBtn'); if(btn) btn.textContent = 'Manage Profile';
          await loadUserData(authUid);
          setFBStatus('Profile & user linked');
        } else {
          // Anonymous/local flows: keep profile id locally and set counts on profile doc.
          localStorage.setItem('profiles_my_uid_v1', String(profile.uid));
          const profRef = db.collection('profiles').doc(String(profile.uid));
          await profRef.set({ hireCount: Number(profile.hireCount || 0), ratingsCount: Number(profile.ratingsCount || 0) }, { merge: true });
          const btn = document.getElementById('profileBtn'); if(btn) btn.textContent = 'Manage Profile';
          try{ await loadUserData(String(profile.uid)); }catch(e){ /* best-effort */ }
          setFBStatus('Profile saved (local) & linked to UI');
        }
      }catch(e){ console.warn('post-saveProfileToFirebase failed', e); setFBStatus('Post-save err','red'); }
    };
  }

  // Rating UI injection into openProfile
  function ensureRatingUI(){
    const container = document.querySelector('.open-profile .profile-actions');
    if(!container) return;
    if(document.getElementById('ratingStars')) return;
    const wrap = document.createElement('div');
    wrap.className = 'profile-rating';
    wrap.style.marginLeft = '12px';
    wrap.innerHTML = '<div style="font-weight:800;color:#fff">Rate this profile</div><div class="rating-stars" id="ratingStars"></div><div class="rating-result" id="ratingResult"></div>';
    container.appendChild(wrap);
    const stars = document.getElementById('ratingStars');
    for(let i=1;i<=5;i++){
      const sp = document.createElement('span');
      sp.textContent = '‚òÖ';
      sp.dataset.value = i;
      sp.onclick = function(){
        const val = Number(this.dataset.value);
        submitRating(currentOpenProfile.uid, val);
      };
      stars.appendChild(sp);
    }
  }
  if(window.openProfile){
    const origOpen = window.openProfile;
    window.openProfile = function(p){
      try{ origOpen(p); }catch(e){ console.warn('origOpenProfile failed', e); }
      ensureRatingUI();
      const rr = document.getElementById('ratingResult');
      const avg = (p.ratingsCount && p.ratingsCount>0) ? (p.ratingsSum / p.ratingsCount).toFixed(1) : 'No ratings';
      if(rr) rr.textContent = avg==='No ratings' ? avg : 'Average: '+avg+' ('+(p.ratingsCount||0)+' votes)';
    };
  }

  async function submitRating(uid, rating){
    if(!uid) return;
    try{
      const profRef = db.collection('profiles').doc(String(uid));
      await db.runTransaction(async (tx) => {
        const doc = await tx.get(profRef);
        if(!doc.exists){
          tx.set(profRef, { ratingsSum: rating, ratingsCount: 1 }, { merge: true });
        } else {
          const data = doc.data();
          const sum = (data.ratingsSum || 0) + rating;
          const cnt = (data.ratingsCount || 0) + 1;
          tx.update(profRef, { ratingsSum: sum, ratingsCount: cnt });
        }
      });
      setFBStatus('Rating saved');
      // update local copy and UI
      const idx = profiles.findIndex(x=>String(x.uid)===String(uid));
      if(idx!==-1){
        profiles[idx].ratingsSum = (profiles[idx].ratingsSum||0) + rating;
        profiles[idx].ratingsCount = (profiles[idx].ratingsCount||0) + 1;
      }
      displayProfiles();
      if(currentOpenProfile && String(currentOpenProfile.uid) === String(uid)){
        openProfile(profiles.find(x=>String(x.uid)===String(uid)));
      }
    }catch(e){ console.warn('submitRating failed', e); setFBStatus('Rating err','red'); }
  }

  // increment hireCount on profile when OTP verification succeeds
  async function confirmHireAndIncrement(toUid){
    try{
      const profRef = db.collection('profiles').doc(String(toUid));
      await profRef.update({ hireCount: firebase.firestore.FieldValue.increment(1) });
      setFBStatus('Hire incremented');
      // update local
      const idx = profiles.findIndex(x=>String(x.uid)===String(toUid));
      if(idx!==-1){ profiles[idx].hireCount = (profiles[idx].hireCount||0) + 1; }
      if(currentOpenProfile && String(currentOpenProfile.uid)===String(toUid)){
        openProfile(profiles.find(x=>String(x.uid)===String(toUid)));
      }
    }catch(e){ console.warn('confirmHireAndIncrement failed', e); setFBStatus('Hire inc err','red'); }
  }

  // Wrap sendHireOTP to also write OTP to Firestore
  if(window.sendHireOTP){
    const origSendHire = window.sendHireOTP;
    window.sendHireOTP = function(fromUid, toUid, toName){
      try{ origSendHire(fromUid, toUid, toName); }catch(e){ console.warn('origSendHire failed', e); }
      try{
        const rec = { otp: String(Math.floor(100000 + Math.random()*900000)), fromUid: String(fromUid), toUid: String(toUid), time: new Date().toISOString(), used: false };
        db.collection('hireOtps').add(rec).then(()=> setFBStatus('OTP stored in Firestore'));
      }catch(e){ console.warn('sendHireOTP firestore write failed', e); setFBStatus('OTP save err','red'); }
    };
  }

  // Expose verifyHireOTP to validate OTPs stored in Firestore and increment hire counter
  window.verifyHireOTP = async function(otpCode){
    try{
      const q = await db.collection('hireOtps').where('otp','==',String(otpCode)).where('used','==',false).get();
      if(q.empty){ alert('Invalid or used OTP'); return; }
      const doc = q.docs[0];
      const data = doc.data();
      await db.collection('hireOtps').doc(doc.id).update({ used: true, usedAt: new Date().toISOString() });
      await confirmHireAndIncrement(data.toUid);
      alert('OTP verified ‚Äî hire counted.');
    }catch(e){ console.warn('verifyHireOTP failed', e); alert('OTP verification failed'); }
  };



    try{
      const arr = profiles.map(p=>{
        const avg = p.ratingsCount && p.ratingsCount>0 ? (p.ratingsSum / p.ratingsCount) : 0;
        const score = avg*10 + (p.hireCount||0)*5;
        return Object.assign({}, p, { score });
      });
      arr.sort((a,b)=>b.score - a.score);
      const lbArea = document.querySelector('.leaderboard-list');
      if(lbArea){
        lbArea.innerHTML = '';
        arr.forEach((p,i)=>{
          const card = document.createElement('div'); card.className='leader-card';
          const rank = document.createElement('div'); rank.className='leader-rank'; rank.textContent = (i+1);
          if(i===0) rank.classList.add('leader-gold');
          else if(i===1) rank.classList.add('leader-silver');
          else if(i===2) rank.classList.add('leader-bronze');
          const info = document.createElement('div'); info.className='leader-info';
          info.innerHTML = `<strong>${p.name}</strong><div class="uid">UID: ${p.uid}</div><div class="meta">Score: ${Math.round(p.score)}</div>`;
          card.appendChild(rank); card.appendChild(info);
          lbArea.appendChild(card);
        });
      }

  };

  // Hook into existing loadProfilesFromFirebase to refresh leaderboard afterwards
  if(window.loadProfilesFromFirebase){
    const origLoad = window.loadProfilesFromFirebase;
    window.loadProfilesFromFirebase = async function(){
      try{ await origLoad(); }catch(e){ console.warn('origLoadProfiles failed', e); }

    };
  }

  // Mark notification as read and reflect to Firestore (if doc id stored)
  const origMarkAsRead = window.markAsReadByUID || function(){};
  window.markAsReadByUID = function(uid){
    try{ origMarkAsRead(uid); }catch(e){ console.warn('origMarkAsRead failed', e); }
    try{
      // find the local unreadNotifications entry and update Firestore doc if we have _docId
      const idx = unreadNotifications.findIndex(n => String(n.uid) === String(uid));
      if(idx !== -1){
        const n = unreadNotifications[idx];
        if(n._docId && myUID){
          db.collection('users').doc(String(myUID)).collection('notifications').doc(n._docId).update({ read: true }).then(()=> setFBStatus('Notif marked read')).catch(()=>{});
        }
      }
    }catch(e){ console.warn('markAsRead Firestore update failed', e); }
  };

  // Small connectivity check
  db.collection('profiles').limit(1).get().then(()=> setFBStatus('Connected')).catch(e=> setFBStatus('Conn error','red'));

})(); // closure
</script>
<script>
// --- BEGIN: Delete profile button + status sync ---
(function(){
  // Create delete button and insert after the submit button in profile form
  function createDeleteButtonIfMissing(){
    const form = document.getElementById('profileForm');
    if(!form) return;
    if(document.getElementById('deleteProfileBtn')) return;
    const del = document.createElement('button');
    del.type = 'button';
    del.id = 'deleteProfileBtn';
    del.textContent = 'Delete Profile';
    // style similar to back-btn but smaller and placed near submit
    del.style.marginTop = '6px';
    del.style.background = '#ff3333';
    del.style.color = '#fff';
    del.style.border = 'none';
    del.style.padding = '10px 14px';
    del.style.borderRadius = '10px';
    del.style.cursor = 'pointer';
    del.style.fontWeight = '800';
    del.onclick = function(){ confirmAndDelete(); };
    // insert at end of form
    form.appendChild(del);
    updateDeleteBtnVisibility();
  }

  function updateDeleteBtnVisibility(){
    const del = document.getElementById('deleteProfileBtn');
    if(!del) return;
    if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid){
      del.style.display = 'inline-block';
    } else {
      del.style.display = 'none';
    }
  }

  async function confirmAndDelete(){
    if(!myProfile || !myProfile.uid){
      alert('No profile to delete.');
      return;
    }
    if(!confirm('Delete your profile permanently? This cannot be undone.')) return;
    await deleteMyProfile();
  }

  async function deleteMyProfile(){
    try{
      const uid = String(myProfile.uid);
      // delete profile doc
      await db.collection('profiles').doc(uid).delete();
      // remove reference from users/{myUID}
      if(typeof myUID !== 'undefined' && myUID){
        try {
          await db.collection('users').doc(String(myUID)).set({ profileUid: firebase.firestore.FieldValue.delete() }, { merge: true });
          // remove from savedProfiles array if present
          await db.collection('users').doc(String(myUID)).update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(String(uid)) }).catch(()=>{});
        } catch(e){ console.warn('failed to update user doc on delete', e); }
      }
      // local cleanup
      profiles = profiles.filter(p => String(p.uid) !== uid);
      savedProfiles = savedProfiles.filter(p => String(p.uid) !== uid);
      localStorage.removeItem('profiles_my_uid_v1');
      myProfile = null;
      myUID = null;
      const btn = document.getElementById('profileBtn'); if(btn) btn.textContent = 'Create a Profile';
      displayProfiles(); displaySaved();
      updateDeleteBtnVisibility();
      setFBStatus('Profile deleted');
      alert('Profile deleted successfully.');
    }catch(e){
      console.error('deleteMyProfile error', e);
      setFBStatus('Delete err','red');
      alert('Delete failed: ' + (e && e.message ? e.message : String(e)));
    }
  }

  // Ensure delete button is created on DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    createDeleteButtonIfMissing();
    // create observer to update visibility when myProfile changes (naive approach: poll)
    setInterval(updateDeleteBtnVisibility, 800);
  });

  // Make sure saveProfileToFirebase writes profile.status (patch existing function)
  if(window.saveProfileToFirebase){
    const orig = window.saveProfileToFirebase;
    window.saveProfileToFirebase = async function(profile){
      try{
        // ensure status field present
        if(typeof profile.status === 'undefined' && document.getElementById('status')){
          profile.status = document.getElementById('status').value || 'Free';
        }
        // call original (which writes profile doc)
        await orig(profile);
        // additionally, ensure profile doc merge includes status explicitly
        try{
          await db.collection('profiles').doc(String(profile.uid)).set({ status: profile.status }, { merge: true });
          setFBStatus('Status synced');
        }catch(e){ console.warn('status set failed', e); }
      }catch(e){ console.warn('patched saveProfileToFirebase failed', e); }
    };
  }
})(); 
// --- END: Delete profile button + status sync ---
</script>
<script>
// === Improved Delete button handler and Wipe All Profiles (safe dev tool) ===
(function(){
  // helper to safely get myProfile or try to load it
  async function ensureMyProfileLoaded() {
    try {
      if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) return myProfile;
      if (typeof loadMyProfileIfExists === 'function') {
        const p = await loadMyProfileIfExists();
        if (p) return p;
      }
      // fallback: try localStorage or profiles array
      const stored = localStorage.getItem('profiles_my_uid_v1');
      if (stored) {
        const found = profiles.find(x => String(x.uid) === String(stored));
        if (found) { myProfile = found; return myProfile; }
        try {
          const prof = await db.collection('profiles').doc(String(stored)).get();
          if (prof.exists) { myProfile = prof.data(); return myProfile; }
        } catch(e){ console.warn('ensureMyProfileLoaded db fetch failed', e); }
      }
      return null;
    } catch(e){ console.warn('ensureMyProfileLoaded failed', e); return null; }
  }

  // Main delete handler wired to the Delete button
  async function handleDeleteClick(e) {
    try {
      const btn = document.getElementById('deleteProfileBtn');
      if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; }
      const p = await ensureMyProfileLoaded();
      if (!p || !p.uid) {
        alert('No profile found to delete.');
        if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
        return;
      }
      const confirmText = prompt('Type DELETE to permanently remove your profile (this cannot be undone):');
      if (String(confirmText).toUpperCase() !== 'DELETE') {
        alert('Delete cancelled.');
        if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
        return;
      }
      // perform deletion
      const uid = String(p.uid);
      try {
        await db.collection('profiles').doc(uid).delete();
      } catch(e) { console.warn('Firestore profile delete failed', e); }
      // remove references from users collection (if myUID exists)
      try {
        const userId = (typeof myUID !== 'undefined' && myUID) ? String(myUID) : null;
        if (userId) {
          await db.collection('users').doc(userId).update({ profileUid: firebase.firestore.FieldValue.delete() }).catch(()=>{});
          await db.collection('users').doc(userId).update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(uid) }).catch(()=>{});
        }
      } catch(e){ console.warn('cleanup user doc failed', e); }
      // local cleanup
      profiles = profiles.filter(x => String(x.uid) !== uid);
      savedProfiles = savedProfiles.filter(x => String(x.uid) !== uid);
      // remove any simulated unread etc
      try { localStorage.removeItem('profiles_my_uid_v1'); } catch(e){}
      myProfile = null; myUID = null;
      // update UI
      displayProfiles(); displaySaved();
      updateSaveButtonState();
      setFBStatus('Profile deleted');
      alert('Profile deleted successfully.');
    } catch(err) {
      console.error('handleDeleteClick error', err);
      setFBStatus('Delete err','red');
      alert('Delete failed: ' + (err && err.message ? err.message : String(err)));
    } finally {
      const btn = document.getElementById('deleteProfileBtn');
      if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
    }
  }

  // Wipe all profiles (dangerous) - requires typing DELETE ALL
  async function wipeAllProfiles() {
    try {
      const confirmText = prompt('Type DELETE ALL to remove ALL profiles from Firestore and clear local data (irreversible):');
      if (String(confirmText).toUpperCase() !== 'DELETE ALL') {
        alert('Wipe cancelled.');
        return;
      }
      setFBStatus('Wiping all profiles...','yellow');
      // fetch profiles docs
      const snap = await db.collection('profiles').get();
      const docs = snap.docs || [];
      for (let i = 0; i < docs.length; i++) {
        try { await db.collection('profiles').doc(docs[i].id).delete(); } catch(e){ console.warn('delete profile doc failed', docs[i].id, e); }
      }
      // Optionally clear users' profileUid fields (best-effort)
      const usersSnap = await db.collection('users').get();
      for (let u = 0; u < usersSnap.docs.length; u++) {
        const uid = usersSnap.docs[u].id;
        try { await db.collection('users').doc(uid).update({ profileUid: firebase.firestore.FieldValue.delete(), savedProfiles: [] }); } catch(e){ /* ignore */ }
      }
      // Clear local state
      profiles = []; savedProfiles = []; myProfile = null; myUID = null;
      try { localStorage.removeItem('profiles_my_uid_v1'); } catch(e){}
      displayProfiles(); displaySaved(); updateSaveButtonState();
      setFBStatus('All profiles wiped');
      alert('All profiles removed from Firestore and local app.');
    } catch(e) {
      console.error('wipeAllProfiles failed', e);
      setFBStatus('Wipe err','red');
      alert('Wipe failed: ' + (e && e.message ? e.message : String(e)));
    }
  }

  // Attach handlers and add menu item for wipe
  document.addEventListener('DOMContentLoaded', function(){
    // wire delete button (if exists) to our handler; otherwise create it
    let del = document.getElementById('deleteProfileBtn');
    if (!del) {
      const form = document.getElementById('profileForm');
      if (form) {
        del = document.createElement('button');
        del.type = 'button';
        del.id = 'deleteProfileBtn';
        del.textContent = 'Delete Profile';
        del.style.marginTop = '6px';
        del.style.background = '#ff3333';
        del.style.color = '#fff';
        del.style.border = 'none';
        del.style.padding = '10px 14px';
        del.style.borderRadius = '10px';
        del.style.cursor = 'pointer';
        del.style.fontWeight = '800';
        form.appendChild(del);
      }
    }
    if (del) {
      del.removeEventListener('click', handleDeleteClick);
      del.addEventListener('click', handleDeleteClick);
      // visibility update
      const show = (typeof myProfile !== 'undefined' && myProfile && myProfile.uid);
      del.style.display = show ? 'inline-block' : 'none';
    }

    // add "Wipe All Profiles" to dropdown menu for dev use
    const menu = document.getElementById('menuDropdown');
    if (menu && !menu.querySelector('.wipe-all-item')) {
      const item = document.createElement('div');
      item.className = 'wipe-all-item';
      item.textContent = 'Wipe All Profiles (dev)';
      item.style.color = '#ff3333';
      item.onclick = function(){ wipeAllProfiles(); };
      menu.appendChild(item);
    }
  });

  // Also expose wipe function globally for console testing
  window.wipeAllProfiles = wipeAllProfiles;
})(); 
</script>
<!-- Assistant-inserted: Override chat hire button + Owner OTP entry modal (adds sender alert, owner OTP verify, firestore update) -->
<script>
(function(){
  // fallback keys if original script used block-scoped consts
  var _OTP_KEY = (typeof OTP_STORAGE_KEY !== 'undefined') ? OTP_STORAGE_KEY : 'profiles_pending_otp_v1';
  var _PROFILES_KEY = (typeof PROFILES_PERSIST_KEY !== 'undefined') ? PROFILES_PERSIST_KEY : 'profiles_data_v1';

  function ownerCanAct(){
    return (typeof myUID !== 'undefined' && myUID !== null) 
      && (typeof myProfile !== 'undefined' && myProfile && String(myProfile.uid) === String(myUID));
  }

  // Override / redefine updateChatHireButton so button is visible to both parties.
  window.updateChatHireButton = function(){
    try{
      const header = document.querySelector('#chatPage > div');
      if (!header) return;
      // remove any existing instance (recreate to reflect state changes)
      const existing = header.querySelector('.hire-complete-chat-btn');
      if (existing) existing.remove();

      const hireBtn = document.createElement('button');
      hireBtn.textContent = 'Hire Complete';
      hireBtn.className = 'hire-complete-chat-btn';
      hireBtn.style.marginLeft = '8px';
      hireBtn.style.padding = '8px 12px';
      hireBtn.style.borderRadius = '8px';
      hireBtn.style.border = 'none';
      hireBtn.style.cursor = 'pointer';
      hireBtn.style.fontWeight = '800';
      hireBtn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
      hireBtn.style.color = '#fff';

      hireBtn.onclick = function(){
        if (!currentChatUID) { alert('Open a chat first.'); return; }
        const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : null;
        const toUid = currentChatUID;
        const toName = document.getElementById('chatWithName')?.textContent || '';
        const isOwner = ownerCanAct();
        if (!isOwner) {
          // Sender clicked ‚Äî show friendly denial
          alert('You can only mark a hire complete from the profile owner account.');
          return;
        }
        // Owner clicked: send OTP to the other user and open owner entry modal
        try {
          sendHireOTP(fromUid, toUid, toName);
        } catch(e){ console.warn('sendHireOTP failed', e); alert('Failed to send OTP'); return; }
        // small delay so storage/event handlers run first
        setTimeout(()=> showOwnerOTPEntryModal(fromUid, toUid, toName), 250);
      };

      header.appendChild(hireBtn);
    } catch(e){ console.warn('updateChatHireButton override failed', e); }
  };

  // Owner OTP entry modal (owner asks recipient for the OTP they received and enters it here)
  window.showOwnerOTPEntryModal = function(fromUid, toUid, toName){
    if (document.getElementById('ownerOtpModal')) return;
    const modal = document.createElement('div');
    modal.id = 'ownerOtpModal';
    modal.className = 'modal open';
    modal.style.zIndex = 99999;
    modal.innerHTML = `
      <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="ownerOtpTitle">
        <button class="modal-close" onclick="document.getElementById('ownerOtpModal')?.remove()">‚úï</button>
        <h4 id="ownerOtpTitle">Enter OTP from ${escapeHtml(toName || toUid)}</h4>
        <p class="note">A 6-digit OTP was sent to the other user in their unread notifications. Ask them for the code and enter it here to confirm the hire.</p>
        <div style="margin-top:8px;"><input id="ownerOtpInput" placeholder="6-digit OTP" style="width:100%; padding:10px; font-size:16px; border-radius:8px; border:1px solid #e8eefb;"></div>
        <div style="margin-top:10px; display:flex; gap:8px;">
          <button id="ownerOtpVerify" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff;">Verify OTP</button>
          <button id="ownerOtpCancel" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:#eef2ff; color:#111;">Cancel</button>
        </div>
        <div id="ownerOtpNote" class="note"></div>
      </div>`;
    document.body.appendChild(modal);
    document.getElementById('ownerOtpCancel').onclick = function(){ modal.remove(); };
    document.getElementById('ownerOtpVerify').onclick = function(){
       const v = document.getElementById('ownerOtpInput').value.trim();
       verifyOwnerOTP(v, fromUid, toUid);
    };
  };

  // Verify OTP entered by owner (looks up OTP record previously sent by owner to recipient)
  window.verifyOwnerOTP = function(value, fromUid, toUid){
    const OTP_KEY = _OTP_KEY;
    const PROFILES_KEY = _PROFILES_KEY;
    if (!value) { try{ document.getElementById('ownerOtpNote').textContent = 'Enter the 6-digit OTP.' }catch(e){}; return; }
    try {
      let arr = [];
      try { const raw = localStorage.getItem(OTP_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
      // The record created by sendHireOTP has {otp, fromUid, toUid, time, toName}
      const idx = arr.findIndex(r => String(r.fromUid) === String(fromUid) && String(r.toUid) === String(toUid) && String(r.otp) === String(value));
      if (idx === -1) {
        const note = document.getElementById('ownerOtpNote');
        if (note) note.textContent = 'Incorrect OTP. Ask the other user to re-check their unread notifications.';
        return;
      }
      const rec = arr.splice(idx,1)[0];
      localStorage.setItem(OTP_KEY, JSON.stringify(arr));
      // Increment hireCount for owner (fromUid)
      const ownerUid = String(fromUid);
      const pidx = profiles.findIndex(p => String(p.uid) === ownerUid);
      if (pidx !== -1) {
        profiles[pidx].hireCount = (profiles[pidx].hireCount || 0) + 1;
      } else {
        // create a minimal profile entry and set hireCount
        profiles.push({ uid: ownerUid, name: (myProfile && String(myProfile.uid) === ownerUid) ? myProfile.name : (rec.toName || ('UID '+ownerUid)), hireCount: 1 });
      }
      // persist profiles
      try { if (typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem(PROFILES_KEY, JSON.stringify(profiles)); } catch(e){ console.warn('profiles persist failed', e); }
      // Update Firestore if available
      try {
        if (typeof db !== 'undefined' && db && ownerUid) {
          try {
            db.collection('profiles').doc(String(ownerUid)).set({ hireCount: firebase.firestore.FieldValue.increment(1) }, { merge: true }).then(()=> {/*ok*/}).catch(()=>{/*ignore*/});
          } catch(e){ console.warn('firestore increment failed', e); }
        }
      } catch(e){ console.warn(e); }
      // Update UI
      try {
        const el = document.getElementById('profileHireCount');
        if (el) {
          const cnt = (profiles.find(p => String(p.uid) === ownerUid) || {}).hireCount || 0;
          el.textContent = 'Hires: ' + cnt;
        }
      } catch(e){}
      alert('OTP verified ‚Äî hire completed. Hire count incremented.');
      document.getElementById('ownerOtpModal')?.remove();
      // add a small read notification for record keeping
      try { readNotifications.unshift({ uid: ownerUid, name: getProfileNameByUID(ownerUid) || 'Profile', lastMessage: 'Hire completed (owner verified)', time: new Date().toLocaleString() }); saveMessagingState(); switchTab('read'); } catch(e){}
      // refresh leaderboards if any

    } catch(e){ console.warn('verifyOwnerOTP failed', e); alert('Verification failed.'); }
  };

  // React to OTP sent event and keep header state fresh
  try { window.addEventListener('profiles-otp-sent', function(){ setTimeout(()=> { try{ updateChatHireButton(); }catch(e){} }, 60); }); } catch(e){}
  try { updateChatHireButton(); } catch(e){}
})();
</script>
<!-- End Assistant-inserted -->
<script>

const auth = firebase.auth();

(function(){
  // Delayed auth display: ensures auth screen is not forced immediately when no user.
  // A single timer is used so the auth page only shows after 60s of the app being open.
  if(!window.__authDelayTimer) window.__authDelayTimer = null;

  function showHomeNow(){
    try{
      if(typeof showPage === 'function'){
        showPage('home');
      } else {
        document.querySelectorAll('.page').forEach(p => p.style.display='none');
        var homeEl = document.getElementById('home');
        if(homeEl) homeEl.style.display = 'block';
      }
    }catch(e){}
  }

  auth.onAuthStateChanged(user => {
    if (user) {
      try{ if(window.__authDelayTimer){ clearTimeout(window.__authDelayTimer); window.__authDelayTimer = null; } }catch(e){}
      try{ var a = document.getElementById('authPage'); if(a) a.style.display = 'none'; }catch(e){}
      showHomeNow();
    } else {
      // Show home while waiting, do NOT immediately show auth.
      try{
        document.querySelectorAll('.page').forEach(p => p.style.display='none');
      }catch(e){}
      showHomeNow();

      if(!window.__authDelayTimer){
        window.__authDelayTimer = 
    var ap = document.getElementById('authPage');
    if(ap){
      ap.style.display = 'flex';
      ap.style.position = 'fixed';
      ap.style.top = '0';
      ap.style.left = '0';
      ap.style.width = '100%';
      ap.style.height = '100%';
      ap.style.alignItems = 'center';
      ap.style.justifyContent = 'center';
      ap.style.background = '#f9fafb';
    }

            if(typeof showPage === 'function') showPage('authPage');
          }catch(e){}
          window.__authDelayTimer = null;
        }, 10000);
      }
    }
  });

  // Helper: force show auth immediately
  window.forceShowAuthNow = function(){
    try{ if(window.__authDelayTimer){ clearTimeout(window.__authDelayTimer); window.__authDelayTimer = null; } }catch(e){}
    try{
      document.querySelectorAll('.page').forEach(p => p.style.display='none');
      var styleEl = document.getElementById('authDelayStyle'); if(styleEl && styleEl.parentNode) styleEl.parentNode.removeChild(styleEl);
      var ap = document.getElementById('authPage');
      if(ap) ap.style.display = 'flex';
      if(typeof showPage === 'function') showPage('authPage');
    }catch(e){}
  };
})();


function emailRegister(){
  const email = document.getElementById('emailInput').value;
  const pass = document.getElementById('passwordInput').value;
  auth.createUserWithEmailAndPassword(email, pass)
    .catch(e=>document.getElementById('authStatus').textContent=e.message);
}

function emailLogin(){
  const email = document.getElementById('emailInput').value;
  const pass = document.getElementById('passwordInput').value;
  auth.signInWithEmailAndPassword(email, pass)
    .catch(e=>document.getElementById('authStatus').textContent=e.message);
}

function googleLogin(){
  const provider = new firebase.auth.GoogleAuthProvider();
  auth.signInWithPopup(provider)
    .catch(e=>document.getElementById('authStatus').textContent=e.message);
}

let confirmationResult;
function phoneLogin(){
  const phoneNumber = document.getElementById('phoneInput').value;
  window.recaptchaVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container');
  auth.signInWithPhoneNumber(phoneNumber, window.recaptchaVerifier)
    .then(result => {
      confirmationResult = result;
      document.getElementById('authStatus').textContent = 'OTP sent';
    })
    .catch(e => document.getElementById('authStatus').textContent = e.message);
}
function verifyOTP(){
  const code = document.getElementById('otpInput').value;
  if(confirmationResult){
    confirmationResult.confirm(code)
      .then(()=> document.getElementById('authStatus').textContent = 'Phone login successful')
      .catch(e=>document.getElementById('authStatus').textContent = e.message);
  }
}
</script>
<script>

(function(){
  const STATES = ['Andhra Pradesh','Arunachal Pradesh','Assam','Bihar','Chhattisgarh','Goa','Gujarat','Haryana','Himachal Pradesh','Jammu and Kashmir','Jharkhand','Karnataka','Kerala','Madhya Pradesh','Maharashtra','Manipur','Meghalaya','Mizoram','Nagaland','Odisha','Punjab','Rajasthan','Sikkim','Tamil Nadu','Telangana','Tripura','Uttar Pradesh','Uttarakhand','West Bengal','Delhi','Puducherry','Ladakh','Andaman and Nicobar','Other'];

function createChangeModal(){
  if(document.getElementById('onboardModal')) return;
  const modal = document.createElement('div');
  modal.id = 'onboardModal';
  modal.className = 'modal open';
  modal.style.zIndex='99999';
  modal.innerHTML = `
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="onboardTitle">
      <button class="modal-close" onclick="document.getElementById('onboardModal')?.remove()">‚úï</button>
      <h4 id="onboardTitle">Choose your location</h4>
      <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
        <select id="onboard_state" style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
          <option value="">-- Select State --</option>
        </select>
        <input id="onboard_district" placeholder=" Your District " style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
        <input id="onboard_city" placeholder=" Your City " style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="onboardSave" style="flex:1;padding:10px;border-radius:8px;border:none;background:linear-gradient(90deg,#06b6d4,#0ea5a6);color:#fff;font-weight:800;">Save</button>
          <button id="onboardSkip" style="flex:1;padding:10px;border-radius:8px;border:none;background:#eef2ff;color:#111;font-weight:700;">Skip</button>
        </div>
      </div>
    </div>`;
  document.body.appendChild(modal);

  // Fill states
  const sel = modal.querySelector('#onboard_state');
  STATES.forEach(s => { 
    const o = document.createElement('option'); 
    o.value = s; 
    o.textContent = s; 
    sel.appendChild(o); 
  });

  // Save button
  modal.querySelector('#onboardSave').onclick = function(){
    const state = modal.querySelector('#onboard_state').value;
    const district = modal.querySelector('#onboard_district').value.trim();
    const city = modal.querySelector('#onboard_city').value.trim();
    const info = { state, district, city };
    if(state) localStorage.setItem('profiles_user_state_v1', state);
    localStorage.setItem('profiles_user_info_v1', JSON.stringify(info));
    try{
      if(document.getElementById('state')) document.getElementById('state').value = state;
      if(document.getElementById('district')) document.getElementById('district').value = district;
      if(document.getElementById('city')) document.getElementById('city').value = city;
    }catch(e){}
    document.getElementById('onboardModal')?.remove();
    renderStateFilterBadge();
    if(typeof displayProfiles === 'function') displayProfiles();
  };

  // Skip button
  modal.querySelector('#onboardSkip').onclick = function(){ 
    document.getElementById('onboardModal')?.remove(); 
  };
}


  function showOnboardingIfNeeded(){
    try{
      if(window.firebase && firebase.auth){
        firebase.auth().onAuthStateChanged(user=>{
          if(user){
            const has = localStorage.getItem('profiles_user_state_v1') || localStorage.getItem('profiles_user_info_v1');
            if(!has){
              createChangeModal();
            } else {
              renderStateFilterBadge();
              injectStateDistrictFieldsIntoProfileForm();
              if(typeof displayProfiles === 'function') displayProfiles();
            }
          }
        });
      } else {
        // fallback behaviour for non-Firebase preview/testing
        if(!localStorage.getItem('profiles_user_state_v1') && !sessionStorage.getItem('onboard_shown_once')){
          createChangeModal();
          sessionStorage.setItem('onboard_shown_once','1');
        } else {
          renderStateFilterBadge();
          injectStateDistrictFieldsIntoProfileForm();
        }
      }
    }catch(e){ console.warn('onboarding check failed', e); }
  }

  function injectStateDistrictFieldsIntoProfileForm(){
    const form = document.getElementById('profileForm');
    if(!form) return;
    if(document.getElementById('state')) return;
    const address = document.getElementById('address');
    if(!address) return;
    const container = document.createElement('div');
    container.style.display='flex';
    container.style.flexDirection='column';
    container.style.gap='8px';
    container.style.marginTop='6px';
    const stateSel = document.createElement('select');
    stateSel.id = 'state';
    stateSel.style.padding='10px';
    stateSel.style.borderRadius='8px';
    stateSel.style.border='1px solid #e8eefb';
    const first = document.createElement('option'); first.value=''; first.textContent='-- Select State --'; stateSel.appendChild(first);
    STATES.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; stateSel.appendChild(o); });
    const districtInp = document.createElement('input');
    districtInp.type='text'; districtInp.id='district'; districtInp.placeholder='District (type)';
    districtInp.style.padding='10px'; districtInp.style.borderRadius='8px'; districtInp.style.border='1px solid #e8eefb';
    container.appendChild(stateSel); container.appendChild(districtInp);
    address.insertAdjacentElement('afterend', container);
    try{
      const infoRaw = localStorage.getItem('profiles_user_info_v1');
      if(infoRaw){
        const info = JSON.parse(infoRaw);
        if(info.name && document.getElementById('name').value==='') document.getElementById('name').value = info.name;
        if(info.age && document.getElementById('age').value==='') document.getElementById('age').value = info.age;
        if(info.state) stateSel.value = info.state;
        if(info.district) districtInp.value = info.district;
      } else if(typeof myProfile !== 'undefined' && myProfile){
        if(myProfile.state) stateSel.value = myProfile.state;
        if(myProfile.district) districtInp.value = myProfile.district;
      }
    }catch(e){}
  }

  function saveProfilesToStorageIfAvailable(){
    try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    const form = document.getElementById('profileForm');
    if(form){
      form.addEventListener('submit', function(){
        setTimeout(()=>{
          try{
            const st = document.getElementById('state') ? document.getElementById('state').value : (localStorage.getItem('profiles_user_state_v1') || '');
            const dist = document.getElementById('district') ? document.getElementById('district').value : '';
            if(myProfile){
              myProfile.state = st || myProfile.state || '';
              myProfile.district = dist || myProfile.district || '';
              const idx = profiles.findIndex(p=>String(p.uid)===String(myProfile.uid));
              if(idx!==-1) profiles[idx] = myProfile;
              saveProfilesToStorageIfAvailable();
              if(st) localStorage.setItem('profiles_user_state_v1', st);
            }
            renderStateFilterBadge();
            if(typeof displayProfiles === 'function') displayProfiles();
          }catch(e){ console.warn('profile form patch failed', e); }
        }, 80);
      });
    }
    injectStateDistrictFieldsIntoProfileForm();
    showOnboardingIfNeeded();
  });

  
function buildLocationString(p) {
  // if full address is given, just return that
  if (p.address && p.address.trim() !== "") {
    return p.address;
  }

  // else build from parts
  let parts = [];
  if (p.city) parts.push(p.city);
  if (p.district) parts.push(p.district);
  if (p.state) parts.push(p.state);
  if (p.country) parts.push(p.country);

  return parts.join(', ');
}


window.displayProfiles = function(){
    const container=document.getElementById("profileList");
    if(!container) return;
    container.innerHTML='';
    const search=document.getElementById("searchInput")?document.getElementById("searchInput").value.toLowerCase():"";
    const userState = localStorage.getItem('profiles_user_state_v1') || '';
    (profiles||[]).filter(p=>{
      const statusMatch = p.status==="Free";
      const skillMatch = currentSkill==='All'||p.skill===currentSkill;
      const searchMatch = p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
      const stateMatch = userState ? String((p.state||'')).toLowerCase() === String(userState).toLowerCase() : true;
      return statusMatch&&skillMatch&&searchMatch&&stateMatch;
    }).forEach(p=>{
      const box=document.createElement('div'); box.className='profile-box';
      const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
      const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
      const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
      const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
      const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? (p.description.length>50 ? p.description.slice(0,49)+'‚Ä¶' : p.description) : '';
      const metaSmall = document.createElement('div'); metaSmall.style.fontSize='12px'; metaSmall.style.color='#6b7280'; metaSmall.textContent = p.state ? ((p.city||'') + (p.district ? ', '+p.district : '') + (p.state ? ', '+p.state : '')) : '';
      nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    const locSpan=document.createElement('div'); locSpan.style.fontSize='12px'; locSpan.style.color='#374151'; locSpan.textContent = buildLocationString(p); nameContainer.appendChild(locSpan); if(metaSmall.textContent) nameContainer.appendChild(metaSmall);
      left.appendChild(tag); left.appendChild(nameContainer);
      const actions=document.createElement('div'); actions.className='profile-actions';
      const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
      const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê';
      if((savedProfiles||[]).some(sp=>sp.uid===p.uid)) saveBtn.classList.add("saved");
      saveBtn.className='save-btn';
      saveBtn.onclick=()=>saveProfile(p);
      actions.appendChild(openBtn); actions.appendChild(saveBtn);
      box.appendChild(left); box.appendChild(actions);
      container.appendChild(box);
    });
  };

  function renderStateFilterBadge(){
    const wrap = document.getElementById('categoryFilter');
    if(!wrap) return;
    let badge = document.getElementById('stateFilterBadge');
    if(!badge){
      badge = document.createElement('div');
      badge.id = 'stateFilterBadge';
      badge.style.margin='12px auto';
      badge.style.textAlign='center';
      badge.style.fontWeight='800';
      badge.style.color='#374151';
      wrap.parentNode.insertBefore(badge, wrap.nextSibling);
    }
    const userState = localStorage.getItem('profiles_user_state_v1') || '';
    badge.innerHTML = userState ? `Showing profiles from: <strong>${userState}</strong> ¬∑ <a href="#" id="changeStateLink">Change</a>` : `No state filter set ¬∑ <a href="#" id="setStateLink">Set preferred state</a>`;
    document.getElementById('changeStateLink')?.addEventListener('click', function(e){ e.preventDefault(); createChangeModal(); });
    document.getElementById('setStateLink')?.addEventListener('click', function(e){ e.preventDefault(); createChangeModal(); });
  }

  window.clearStateFilter = function(){ localStorage.removeItem('profiles_user_state_v1'); localStorage.removeItem('profiles_user_info_v1'); renderStateFilterBadge(); if(typeof displayProfiles==='function') displayProfiles(); };

  try{ renderStateFilterBadge(); }catch(e){}
})();

</script>
<script>

(function(){
  const STATES = ['Andhra Pradesh','Arunachal Pradesh','Assam','Bihar','Chhattisgarh','Goa','Gujarat','Haryana','Himachal Pradesh','Jammu and Kashmir','Jharkhand','Karnataka','Kerala','Madhya Pradesh','Maharashtra','Manipur','Meghalaya','Mizoram','Nagaland','Odisha','Punjab','Rajasthan','Sikkim','Tamil Nadu','Telangana','Tripura','Uttar Pradesh','Uttarakhand','West Bengal','Delhi','Puducherry','Ladakh','Andaman and Nicobar','Other'];

function createChangeModal(){
  if(document.getElementById('changeStateModal')) return;

  const modal = document.createElement('div');
  modal.id = 'changeStateModal';
  modal.className = 'modal open';
  modal.style.zIndex='99999';
  modal.innerHTML = `
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="changeTitle">
      <button class="modal-close" id="changeClose">‚úï</button>
      <h4 id="changeTitle">Filter by State, District & City</h4>
      <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px;">
        <select id="change_state" style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
          <option value="">-- Select State --</option>
        </select>
        <input id="change_city" placeholder="City (type exactly to match)" 
          style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
        <input id="change_district" placeholder="District (type exactly to match)" 
          style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
        <input id="change_age" placeholder="Your age (optional - will be saved to your profile)" 
          type="number" style="padding:10px;border-radius:8px;border:1px solid #e8eefb;">
        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="changeSave" 
            style="flex:1;padding:10px;border-radius:8px;border:none;background:linear-gradient(90deg,#06b6d4,#0ea5a6);color:#fff;font-weight:800;">
            Apply
          </button>
          <button id="changeClear" 
            style="flex:1;padding:10px;border-radius:8px;border:none;background:#eef2ff;color:#111;font-weight:700;">
            Clear
          </button>
        </div>
      </div>
    </div>`;

  document.body.appendChild(modal);

  // Populate states dropdown
  const sel = modal.querySelector('#change_state');
  STATES.forEach(s => {
    const o = document.createElement('option');
    o.value = s;
    o.textContent = s;
    sel.appendChild(o);
  });

  // Close button
  modal.querySelector('#changeClose').onclick = function(){ modal.remove(); };

  // Clear button
  modal.querySelector('#changeClear').onclick = function(){
    localStorage.removeItem('profiles_user_state_v1');
    localStorage.removeItem('profiles_user_district_v1');
    localStorage.removeItem('profiles_user_city_v1');
    localStorage.removeItem('profiles_user_age_v1');

    try{
      if(window.firebase && firebase.auth && firebase.auth().currentUser){
        const uid = firebase.auth().currentUser.uid;
        if(firebase.firestore){
          firebase.firestore().collection('users').doc(uid).update({
            state: firebase.firestore.FieldValue.delete(),
            district: firebase.firestore.FieldValue.delete(),
            city: firebase.firestore.FieldValue.delete(),
            age: firebase.firestore.FieldValue.delete()
          }).catch(()=>{});
        }
        if(firebase.database){
          firebase.database().ref('users/'+uid).update({
            state: null,
            district: null,
            city: null,
            age: null
          }).catch(()=>{});
        }
      }
    }catch(e){}

    renderStateFilterBadge();
    if(typeof displayProfiles==='function') displayProfiles();
    modal.remove();
  };

  // Save button
  modal.querySelector('#changeSave').onclick = function(){
    const state = modal.querySelector('#change_state').value;
    const city = modal.querySelector('#change_city').value.trim();
    const district = modal.querySelector('#change_district').value.trim();
    const age = modal.querySelector('#change_age').value.trim();

    if(!state){
      alert('Please select a state to apply the filter.');
      return;
    }

    localStorage.setItem('profiles_user_state_v1', state);
    localStorage.setItem('profiles_user_district_v1', district);
    localStorage.setItem('profiles_user_city_v1', city);
    if(age) localStorage.setItem('profiles_user_age_v1', age);

    try{
      if(window.firebase && firebase.auth && firebase.auth().currentUser){
        const uid = firebase.auth().currentUser.uid;
        const payload = { state };
        if(city) payload.city = city;
        if(district) payload.district = district;
        if(age) payload.age = Number(age);

        if(firebase.firestore){
          firebase.firestore().collection('users').doc(uid).set(payload, { merge: true })
            .catch(e=>console.warn('firestore save failed', e));
        }
        if(firebase.database){
          firebase.database().ref('users/'+uid).update(payload)
            .catch(e=>console.warn('realtime save failed', e));
        }
      }
    }catch(e){ console.warn('firebase save attempt failed', e); }

    renderStateFilterBadge();
    if(typeof displayProfiles==='function') displayProfiles();
    modal.remove();
  };

  // Prefill with existing values if present
  const existingState = localStorage.getItem('profiles_user_state_v1') || '';
  const existingCity = localStorage.getItem('profiles_user_city_v1') || '';
  const existingDistrict = localStorage.getItem('profiles_user_district_v1') || '';
  const existingAge = localStorage.getItem('profiles_user_age_v1') || '';

  if(existingState) modal.querySelector('#change_state').value = existingState;
  if(existingCity) modal.querySelector('#change_city').value = existingCity;
  if(existingDistrict) modal.querySelector('#change_district').value = existingDistrict;
  if(existingAge) modal.querySelector('#change_age').value = existingAge;
}

  function injectStateDistrictFieldsIntoProfileForm(){
    const form = document.getElementById('profileForm');
    if(!form) return;
    if(document.getElementById('state')) return;
    const address = document.getElementById('address');
    if(!address) return;
    const container = document.createElement('div');
    container.style.display='flex';
    container.style.flexDirection='column';
    container.style.gap='8px';
    container.style.marginTop='6px';
    const stateSel = document.createElement('select');
    stateSel.id = 'state';
    stateSel.style.padding='10px';
    stateSel.style.borderRadius='8px';
    stateSel.style.border='1px solid #e8eefb';
    const first = document.createElement('option'); first.value=''; first.textContent='-- Select State --'; stateSel.appendChild(first);
    STATES.forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; stateSel.appendChild(o); });
    const districtInp = document.createElement('input');
    districtInp.type='text'; districtInp.id='district'; districtInp.placeholder='District (type exactly to match)';
    districtInp.style.padding='10px'; districtInp.style.borderRadius='8px'; districtInp.style.border='1px solid #e8eefb';
    container.appendChild(stateSel); container.appendChild(districtInp);
    address.insertAdjacentElement('afterend', container);
    try{
      // Prefill from profile or localStorage
      const infoState = localStorage.getItem('profiles_user_state_v1');
      const infoDistrict = localStorage.getItem('profiles_user_district_v1');
      if(infoState) stateSel.value = infoState;
      if(infoDistrict) districtInp.value = infoDistrict;
      if(typeof myProfile !== 'undefined' && myProfile){
        if(myProfile.state) stateSel.value = myProfile.state;
        if(myProfile.district) districtInp.value = myProfile.district;
      }
    }catch(e){}
  }

  document.addEventListener('DOMContentLoaded', function(){
    injectStateDistrictFieldsIntoProfileForm();
    renderStateFilterBadge();
  });

  window.displayProfiles = function(){
    const container=document.getElementById("profileList");
    if(!container) return;
    container.innerHTML='';
    const search=document.getElementById("searchInput")?document.getElementById("searchInput").value.toLowerCase():"";
    const userState = (localStorage.getItem('profiles_user_state_v1') || '').toLowerCase();
    const userDistrict = (localStorage.getItem('profiles_user_district_v1') || '').toLowerCase();
    (profiles||[]).filter(p=>{
      const statusMatch = p.status==="Free";
      const skillMatch = currentSkill==='All'||p.skill===currentSkill;
      const searchMatch = p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
      // Filtering logic: if user selected state && district -> require both match (case-insensitive).
      // If user selected only state and left district blank -> require state match only.
      let stateMatch = true;
      let districtMatch = true;
      if(userState){
        stateMatch = String((p.state||'')).toLowerCase() === userState;
        if(userDistrict){
          districtMatch = String((p.district||'')).toLowerCase() === userDistrict;
        }
      }
      return statusMatch && skillMatch && searchMatch && stateMatch && districtMatch;
    }).forEach(p=>{
      const box=document.createElement('div'); box.className='profile-box';
      const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
      const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
      const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
      const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
      const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? (p.description.length>50 ? p.description.slice(0,49)+'‚Ä¶' : p.description) : '';
      const metaSmall = document.createElement('div'); metaSmall.style.fontSize='12px'; metaSmall.style.color='#6b7280'; metaSmall.textContent = p.state ? ((p.city||'') + (p.district ? ', '+p.district : '') + (p.state ? ', '+p.state : '')) : '';
      nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    const locSpan=document.createElement('div'); locSpan.style.fontSize='12px'; locSpan.style.color='#374151'; locSpan.textContent = buildLocationString(p); nameContainer.appendChild(locSpan); if(metaSmall.textContent) nameContainer.appendChild(metaSmall);
      left.appendChild(tag); left.appendChild(nameContainer);
      const actions=document.createElement('div'); actions.className='profile-actions';
      const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
      const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê';
      if((savedProfiles||[]).some(sp=>sp.uid===p.uid)) saveBtn.classList.add("saved");
      saveBtn.className='save-btn';
      saveBtn.onclick=()=>saveProfile(p);
      actions.appendChild(openBtn); actions.appendChild(saveBtn);
      box.appendChild(left); box.appendChild(actions);
      container.appendChild(box);
    });
  };

  function renderStateFilterBadge(){
    const wrap = document.getElementById('categoryFilter');
    if(!wrap) return;
    let badge = document.getElementById('stateFilterBadge');
    if(!badge){
      badge = document.createElement('div');
      badge.id = 'stateFilterBadge';
      badge.style.margin='12px auto';
      badge.style.textAlign='center';
      badge.style.fontWeight='800';
      badge.style.color='#374151';
      wrap.parentNode.insertBefore(badge, wrap.nextSibling);
    }
    const userState = localStorage.getItem('profiles_user_state_v1') || '';
    const userDistrict = localStorage.getItem('profiles_user_district_v1') || '';
    if(userState){
      badge.innerHTML = `Showing profiles from: <strong>${userState}${userDistrict ? ' ¬∑ '+userDistrict : ''}</strong> ¬∑ <a href="#" id="changeStateLink">Change</a> ¬∑ <a href="#" id="clearStateLink">Clear</a>`;
    } else {
      badge.innerHTML = `No state filter set ¬∑ <a href="#" id="changeStateLink">Set filter</a>`;
    }
    document.getElementById('changeStateLink')?.addEventListener('click', function(e){ e.preventDefault(); createChangeModal(); });
    document.getElementById('clearStateLink')?.addEventListener('click', function(e){ e.preventDefault(); localStorage.removeItem('profiles_user_state_v1'); localStorage.removeItem('profiles_user_district_v1'); localStorage.removeItem('profiles_user_age_v1'); renderStateFilterBadge(); if(typeof displayProfiles==='function') displayProfiles(); });
  }

})();
<script>
  const dbInst = (typeof db!=='undefined') ? db : (firebase && firebase.firestore ? firebase.firestore() : null);
  if(!dbInst) return;
  (async () => {
    let snap = await dbInst.collection('profiles').get();
    let arr = [];
    snap.forEach(doc => { arr.push(doc.data()); });

    // compute score
    arr.forEach(p => {
      p.hireCount = p.hireCount || 0;
      p.rating = p.rating || 0;
      p.alltimeScore = p.hireCount*10 + p.rating*2;
    });

    if(cat==='hired'){ arr.sort((a,b)=>b.hireCount-a.hireCount); }
    else if(cat==='rated'){ arr.sort((a,b)=>b.rating-a.rating); }
    else { arr.sort((a,b)=>b.alltimeScore-a.alltimeScore); }

    let html='';
    arr.forEach((p,i)=>{
      let rank=i+1;
      let cls='lb-card';
      if(rank===1) cls+=' lb-top1';
      else if(rank===2) cls+=' lb-top2';
      else if(rank===3) cls+=' lb-top3';
      html+=`<div class="${cls}"><span class="lb-rank">#${rank}</span><span class="lb-name">${p.name||'Unnamed'}</span><span>üë• ${p.hireCount} ‚≠ê ${p.rating}</span></div>`;
    });

    document.getElementById('leaderboardContent').innerHTML=html;
  })();
</script>

<!-- BEGIN: Profile-completion watcher (added by assistant) -->
<script>
(function(){
  function _getAuthAndDb(){
    return {
      auth: (typeof auth !== 'undefined' && auth) ? auth : ((typeof firebase !== 'undefined' && firebase.auth) ? firebase.auth() : null),
      db: (typeof db !== 'undefined' && db) ? db : ((typeof firebase !== 'undefined' && firebase.firestore) ? firebase.firestore() : null)
    };
  }

  async function checkAndPromptProfileCompletion(user){
    if(!user || !user.uid) return;
    const uid = String(user.uid);
    // if we've already recorded that the prompt was shown & handled, don't show again
    if(localStorage.getItem('profiles_complete_prompt_shown_' + uid) === '1') return;
    const {db, auth} = _getAuthAndDb();
    let needsPrompt = false;
    try{
      if(db){
        const snap = await db.collection('users').doc(uid).get();
        if(!snap.exists){
          needsPrompt = true;
        } else {
          const data = snap.data() || {};
          if(!data.displayName || !data.age) needsPrompt = true;
        }
      } else {
        // no Firestore available ‚Äî fall back to auth profile check
        if(!user.displayName) needsPrompt = true;
      }
    }catch(e){
      console.warn('checkAndPromptProfileCompletion failed', e);
      needsPrompt = true;
    }

    if(needsPrompt){
      try{
        window.pendingNewUserUid = uid;
        showCompleteAccountModal && showCompleteAccountModal(uid, user);
        // focus input for faster completion (small delay for modal animation)
        setTimeout(()=>{ const el = document.getElementById('complete_username'); if(el){ el.focus(); } }, 220);
      }catch(e){ console.warn(e); }
    }
  }

  function initAuthWatcher(){
    const { auth } = _getAuthAndDb();
    if(!auth || !auth.onAuthStateChanged) return;
    auth.onAuthStateChanged(function(user){
      if(user) checkAndPromptProfileCompletion(user).catch(()=>{});
    });
    // attempt immediate check if already signed-in
    if(auth && auth.currentUser) checkAndPromptProfileCompletion(auth.currentUser).catch(()=>{});
  }

  // Mark the prompt as shown/handled after successful save/skip.
  // We monkeypatch the existing functions (if present) so we don't change their internals.
  if(window.saveCompleteAccount){
    const orig = window.saveCompleteAccount;
    window.saveCompleteAccount = async function(){
      try{
        await orig.apply(this, arguments);
      } finally {
        try{
          const uid = window.pendingNewUserUid || (window.myUID ? window.myUID : null);
          if(uid) localStorage.setItem('profiles_complete_prompt_shown_' + String(uid), '1');
        }catch(e){ console.warn('mark prompt shown after save failed', e); }
      }
    };
  }
  if(window.skipCompleteAccount){
    const origSkip = window.skipCompleteAccount;
    window.skipCompleteAccount = function(){
      try{
        const uid = window.pendingNewUserUid || window.myUID;
        if(uid) localStorage.setItem('profiles_complete_prompt_shown_' + String(uid), '1');
      }catch(e){}
      return origSkip.apply(this, arguments);
    };
  }

  document.addEventListener('DOMContentLoaded', initAuthWatcher);
})();
</script>
<!-- END: Profile-completion watcher -->




<!-- BEGIN: Ratings - Robust Firestore-backed implementation (single patch) -->
<script>
(function(){
  if(window._ratingsPatched) return;
  window._ratingsPatched = true;

  // Helper: sleep
  function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

  // Get Firestore DB instance (works with window.db or firebase.firestore())
  function getDB(){
    if(window.db) return window.db;
    if(typeof firebase !== 'undefined' && firebase.firestore) return firebase.firestore();
    return null;
  }

  async function hasUserVoted(profileUid, voterUid){
    try{
      const db = getDB();
      if(!db || !voterUid) return false;
      const snap = await db.collection('profiles').doc(String(profileUid)).collection('votes').doc(String(voterUid)).get();
      return snap.exists;
    }catch(e){ console.warn('hasUserVoted err', e); return false; }
  }

  async function fetchProfileRatings(profileUid){
    try{
      const db = getDB();
      if(!db) return null;
      const doc = await db.collection('profiles').doc(String(profileUid)).get();
      return doc.exists ? doc.data() : null;
    }catch(e){ console.warn('fetchProfileRatings err', e); return null; }
  }

  async function submitRatingToFirestore(profileUid, score){
    const db = getDB();
    if(!db) throw new Error('Firestore not available');
    const voterUid = (window.myUID || localStorage.getItem('profiles_my_uid_v1'));
    if(!voterUid) { alert('Please sign in or create a profile to rate.'); throw new Error('No voter UID'); }

    const profRef = db.collection('profiles').doc(String(profileUid));
    const voteRef = profRef.collection('votes').doc(String(voterUid));
    // Prevent duplicate vote: if vote doc exists, bail out
    const existing = await voteRef.get();
    if(existing.exists){
      alert('You have already rated this profile.');
      return false;
    }

    // Use transaction to update ratings atomically
    await db.runTransaction(async tx => {
      const profSnap = await tx.get(profRef);
      const prev = profSnap.exists ? profSnap.data() : {};
      const ratingsSum = (prev.ratingsSum||0) + score;
      const ratingsCount = (prev.ratingsCount||0) + 1;
      const ratingsByStar = Object.assign({}, prev.ratingsByStar || {});
      ratingsByStar[String(score)] = (ratingsByStar[String(score)]||0) + 1;
      tx.set(profRef, { ratingsSum: ratingsSum, ratingsCount: ratingsCount, ratingsByStar: ratingsByStar }, { merge: true });
      tx.set(voteRef, { score: score, time: new Date().toISOString(), voterUid: String(voterUid) });
    });

    return true;
  }

  // Render rating bar + text (NO per-star breakdown)
  function renderRatingBarElements(container, ratingData){
    const sum = ratingData && ratingData.ratingsSum ? Number(ratingData.ratingsSum) : 0;
    const count = ratingData && ratingData.ratingsCount ? Number(ratingData.ratingsCount) : 0;
    const avg = count ? (sum / count) : 0;
    const pct = Math.round((avg / 5) * 100);

    let barWrap = container.querySelector('.rating-bar-wrap');
    if(!barWrap){
      barWrap = document.createElement('div'); barWrap.className='rating-bar-wrap';
      barWrap.style.marginTop='10px';
      container.appendChild(barWrap);
    }
    barWrap.innerHTML = '';

    const outer = document.createElement('div');
    outer.style.display='flex'; outer.style.gap='12px'; outer.style.alignItems='center';

    const barOuter = document.createElement('div');
    barOuter.style.width='220px';
    barOuter.style.height='14px';
    barOuter.style.background='#e6eefc';
    barOuter.style.borderRadius='10px';
    barOuter.style.overflow='hidden';
    const barInner = document.createElement('div');
    barInner.style.height='100%';
    barInner.style.width = pct + '%';
    barInner.style.transition='width 450ms ease';
    barInner.style.background='linear-gradient(90deg,#fbbf24,#f97316)';
    barOuter.appendChild(barInner);
    outer.appendChild(barOuter);

    const meta = document.createElement('div');
    meta.style.fontWeight='800';
    meta.style.color='#FFD700'; 
    meta.textContent = count ? ('Avg: ' + (Math.round(avg*10)/10) + ' / 5 (' + pct + '%) ‚Äî ' + count + ' rater' + (count>1?'s':'') ) : 'No ratings yet';
    outer.appendChild(meta);
    barWrap.appendChild(outer);
    return { avg, pct, count };
  }

  // Export helpers to window._ratingsHelpers (safe)
  window._ratingsHelpers = Object.assign(window._ratingsHelpers || {}, {
    getDB: getDB,
    fetchProfileRatings: fetchProfileRatings,
    submitRatingToFirestore: submitRatingToFirestore,
    hasUserVoted: hasUserVoted,
    renderRatingBarElements: renderRatingBarElements
  });

  // Override openProfile to attach Firestore-backed rating UI
  function overrideOpenProfile(){
    const orig = window.openProfile;
    window.openProfile = async function(p){
      try{ if(typeof orig === 'function') orig(p); }catch(e){ console.warn('orig openProfile failed', e); }

      try{
        const container = document.querySelector('.profile-header .profile-head-info');
        if(!container) return;
        const prev = document.getElementById('profileRatingContainer');
        if(prev) prev.remove();

        const rc = document.createElement('div'); rc.id = 'profileRatingContainer'; rc.className = 'profile-rating';
        rc.style.marginTop = '10px';

        // star row (select)
        const starRow = document.createElement('div'); starRow.className='rating-stars'; starRow.style.marginTop='6px';
        let selected = 0;
        for(let i=1;i<=5;i++){
          const s = document.createElement('span');
          s.innerHTML = '‚òÖ';
          s.dataset.value = i;
          s.style.userSelect = 'none';
          s.style.fontSize = '20px';
          s.style.cursor = 'pointer';
          s.onclick = function(){
            selected = Number(this.dataset.value);
            const stars = starRow.querySelectorAll('span');
            stars.forEach(st => {
              if(Number(st.dataset.value) <= selected) st.classList.add('active');
              else st.classList.remove('active');
            });
            submitBtn.disabled = false;
          };
          starRow.appendChild(s);
        }
        rc.appendChild(starRow);

        // submit button
        const submitBtn = document.createElement('button');
        submitBtn.textContent = 'Submit Rating';
        submitBtn.style.marginTop = '8px';
        submitBtn.style.padding = '8px 12px';
        submitBtn.style.borderRadius = '8px';
        submitBtn.style.border = 'none';
        submitBtn.style.cursor = 'pointer';
        submitBtn.style.fontWeight = '800';
        submitBtn.style.background = 'linear-gradient(90deg,#06b6d4,#0ea5a6)';
        submitBtn.style.color = '#fff';
        submitBtn.disabled = true;
        rc.appendChild(submitBtn);

        // attach to profile header
        container.appendChild(rc);

        // load rating data and whether current user has voted
        const profileUid = p && p.uid ? p.uid : (document.getElementById('profileUID') ? document.getElementById('profileUID').textContent : null);
        const db = getDB();
        const voterUid = (window.myUID || localStorage.getItem('profiles_my_uid_v1')) || null;
        const ratingData = profileUid && db ? await fetchProfileRatings(profileUid) : null;
        const alreadyVoted = profileUid && voterUid && db ? await hasUserVoted(profileUid, voterUid) : false;

        // render current results
        renderRatingBarElements(rc, ratingData || {});

        if(alreadyVoted){
          // hide controls
          starRow.style.display = 'none';
          submitBtn.style.display = 'none';
        }

        // submit handler (Firestore)
        submitBtn.onclick = async function(){
          if(!selected){ alert('Select a star rating first'); return; }
          if(!profileUid){ alert('Profile id missing'); return; }
          submitBtn.disabled = true;
          submitBtn.textContent = 'Saving‚Ä¶';
          try{
            const ok = await submitRatingToFirestore(profileUid, selected);
            if(ok){
              const latest = await fetchProfileRatings(profileUid);
              renderRatingBarElements(rc, latest || {});
              // hide controls after successful vote
              starRow.style.display = 'none';
              submitBtn.style.display = 'none';
              // merge into local profiles array (if present)
              try{
                const idx = (window.profiles||[]).findIndex(x => String(x.uid) === String(profileUid));
                if(idx !== -1){
                  window.profiles[idx].ratingsSum = (latest && latest.ratingsSum) || window.profiles[idx].ratingsSum || 0;
                  window.profiles[idx].ratingsCount = (latest && latest.ratingsCount) || window.profiles[idx].ratingsCount || 0;
                  window.profiles[idx].ratingsByStar = (latest && latest.ratingsByStar) || window.profiles[idx].ratingsByStar || {};
                } else {
                  (window.profiles = window.profiles || []).push({ uid: profileUid, name: (p && p.name) || ('UID '+profileUid), ratingsSum: (latest&&latest.ratingsSum)||0, ratingsCount: (latest&&latest.ratingsCount)||0, ratingsByStar: (latest&&latest.ratingsByStar)||{} });
                }
              }catch(e){ console.warn('merge local ratings failed', e); }
              try{ normalizeRatingsForProfiles(); }catch(_){}


              // refresh leaderboards (if function available)
              try{
                if(typeof loadProfilesFromFirebase === 'function') {
                  await loadProfilesFromFirebase();
                }
              }catch(e){ console.warn('refresh profiles after rating failed', e); }
              try{
                if(typeof displayLeaderboard === 'function') displayLeaderboard();
                // try common leaderboard keys
                if(typeof displayLeaderboard === 'function') { displayLeaderboard('mostRated'); displayLeaderboard('alltime'); displayLeaderboard('rated'); }
              }catch(e){ console.warn('displayLeaderboard calls failed', e); }
              alert('Rating submitted ‚Äî thanks!');
            }
          }catch(err){
            console.error('submitRating failure', err);
            alert('Failed to submit rating: ' + (err && err.message ? err.message : err));
            submitBtn.disabled = false;
            submitBtn.textContent = 'Submit Rating';
          }
        };
      }catch(e){ console.warn('openProfile rating injection error', e); }
    };
  }

  // Patch displayLeaderboard by polling until it's defined, then wrap it
  function patchDisplayLeaderboard(){
    let tries = 0;
    const maxTries = 40;
    const iv = setInterval(()=>{
      tries++;
      if(typeof displayLeaderboard === 'function'){
        clearInterval(iv);
        const orig = displayLeaderboard;
        window.displayLeaderboard = function(type){
          try{ orig(type); }catch(e){ console.warn('orig displayLeaderboard err', e); }
          // After original renders, attach rating info to items
          try{
            const profilesArr = window.profiles || []; try{ normalizeRatingsForProfiles(); }catch(e){}

            // find leaderboard container(s)
            const lists = document.querySelectorAll('.leaderboard-list, .leaderboard, #leaderboardList');
            lists.forEach(list => {
              const items = list.querySelectorAll('.leaderboard-item, li, .item');
              items.forEach(item => {
                // attempt to identify which profile this item represents
                let matched = null;
                // Prefer dataset uid if present
                if(item.dataset && item.dataset.uid){
                  matched = profilesArr.find(p => String(p.uid) === String(item.dataset.uid));
                }
                // fallback: match by name substring
                if(!matched){
                  const txt = (item.textContent||'').trim();
                  matched = profilesArr.find(p => p.name && txt.includes(p.name));
                }
                if(matched && matched.ratingsCount){
                  const avg = (matched.ratingsSum || 0) / (matched.ratingsCount || 1);
                  const pct = Math.round((avg/5)*100);
                  let el = item.querySelector('.rating-percent');
                  if(!el){
                    el = document.createElement('div');
                    el.className = 'rating-percent';
                    el.style.fontSize = '13px';
                    el.style.fontWeight = '600';
                    el.style.color = '#f97316';
                    el.style.marginTop = '6px';
                    item.appendChild(el);
                  }
                  el.textContent = 'Rating: ' + (Math.round(avg*10)/10) + '/5 ('+pct+'%)';
                }
              });
            });
          }catch(e){ console.warn('leaderboard patch err', e); }
        };
        return;
      }
      if(tries>maxTries) clearInterval(iv);
    }, 350);
  }

  // Initialize: override openProfile and patch leaderboard
  try{ overrideOpenProfile(); }catch(e){ console.warn('overrideOpenProfile failed', e); }
  try{ patchDisplayLeaderboard(); }catch(e){ console.warn('patchDisplayLeaderboard failed', e); }

  // Expose helpers for debugging
  window._ratingsHelpers = Object.assign(window._ratingsHelpers || {}, { getDB:getDB, fetchProfileRatings:fetchProfileRatings, submitRatingToFirestore:submitRatingToFirestore, hasUserVoted:hasUserVoted, renderRatingBarElements:renderRatingBarElements });

})();
</script>
<!-- END: Ratings - Robust Firestore-backed implementation -->




<script>
// --- Assistant: non-invasive safety & rating-percent enhancer ---
(function(){
  // Ensure globals exist so earlier scripts won't throw
  if (typeof window.profiles === 'undefined') window.profiles = window.profiles || [];
  if (typeof window.showPage === 'undefined') window.showPage = function(p){ console.warn('showPage missing. attempted to show',p); };
  if (typeof window.currentSkill === 'undefined') window.currentSkill = '';
  if (typeof window.myUID === 'undefined') window.myUID = null;

  function computeRatingPct(p){
    const sum = Number(p.ratingsSum ?? p.ratings ?? 0);
    const cnt = Number(p.ratingsCount ?? p.ratings_count ?? p.votes ?? 0);
    return (cnt && cnt>0) ? Math.round((sum / (cnt * 5)) * 100) : 0;
  }

  function addBadgeToProfileCard(cardElem, p){
    if(!cardElem) return;
    if(cardElem.querySelector('.rating-badge')) return; // already added
    const pct = computeRatingPct(p || {});
    const el = document.createElement('div');
    el.className = 'rating-badge';
    el.style.fontSize = '13px';
    el.style.color = '#FFD700';
    el.style.fontWeight = '800';
    el.style.marginTop = '6px';
    el.textContent = 'Rating: ' + pct + '%';
    // append to info/meta area if available
    const info = cardElem.querySelector('.info') || cardElem;
    info.appendChild(el);
  }

  // When DOM ready, try to enhance existing DOM nodes non-invasively.
  function enhanceOnce(){
    // compute ratingPct for in-memory profiles
    try{
      window.profiles.forEach(p => { p.ratingPct = computeRatingPct(p); });
    }catch(e){ /* ignore */ }

    // enhance leaderboard entries (.leader-card, .meta)
    try{
      const lb = document.getElementById('leaderboardList');
      if(lb){
        lb.querySelectorAll('.leader-card').forEach(card => {
          try{
            const name = card.querySelector('.name')?.textContent?.trim() || '';
            const meta = card.querySelector('.meta');
            // if meta already mentions Rating, skip
            if(meta && /Rating:/.test(meta.textContent)) return;
            // try to find uid from data-uid attribute or in text
            let uid = card.getAttribute('data-uid') || card.getAttribute('data-id') || '';
            let p = null;
            if(uid && window.profiles && window.profiles.length){
              p = window.profiles.find(x => String(x.uid) === String(uid));
            }
            // fallback: try match by name (best-effort)
            if(!p && name && window.profiles && window.profiles.length){
              p = window.profiles.find(x => (x.name||x.title||'').trim() === name);
            }
            if(p){
              const pct = p.ratingPct ?? computeRatingPct(p);
              const votes = Number(p.ratingsCount || p.votes || 0);
              const newMeta = (meta ? meta.textContent + ' ¬∑ ' : '') + 'Rating: ' + pct + '% (' + votes + ' votes)';
              if(meta) meta.textContent = newMeta;
              else {
                const md = document.createElement('div'); md.className='meta'; md.textContent=newMeta; card.querySelector('.info')?.appendChild(md);
              }
            }
          }catch(e){}
        });
      }
    }catch(e){}

    // enhance profile cards in profiles view: look for elements with class 'profile-card' or similar
    try{
      const cardSelectors = ['.profile-card', '.card.profile', '.pro-card', '.lead-card', '.leader-card', '.profile-item'];
      cardSelectors.forEach(sel => {
        document.querySelectorAll(sel).forEach(card => {
          // attempt to find uid or name from card, then lookup
          let uid = card.getAttribute('data-uid') || card.getAttribute('data-id') || '';
          let name = card.querySelector('.name')?.textContent?.trim() || card.querySelector('.profile-name')?.textContent?.trim() || '';
          let p = null;
          if(uid && window.profiles.length) p = window.profiles.find(x => String(x.uid) === String(uid));
          if(!p && name && window.profiles.length) p = window.profiles.find(x => (x.name||x.title||'').trim() === name);
          addBadgeToProfileCard(card, p);
        });
      });
    }catch(e){}

    // observe leaderboardList for further updates and enhance newly added nodes
    try{
      const lb = document.getElementById('leaderboardList');
      if(lb && typeof MutationObserver !== 'undefined'){
        const mo = new MutationObserver(muts => {
          muts.forEach(m => {
            m.addedNodes && m.addedNodes.forEach(node => {
              if(node.nodeType===1 && node.classList.contains('leader-card')){
                // enhance this card
                try{
                  const name = node.querySelector('.name')?.textContent?.trim() || '';
                  let p = null;
                  const uid = node.getAttribute('data-uid') || node.getAttribute('data-id') || '';
                  if(uid && window.profiles.length) p = window.profiles.find(x => String(x.uid) === String(uid));
                  if(!p && name && window.profiles.length) p = window.profiles.find(x => (x.name||x.title||'').trim() === name);
                  if(p){
                    const pct = p.ratingPct ?? computeRatingPct(p);
                    const votes = Number(p.ratingsCount || p.votes || 0);
                    const meta = node.querySelector('.meta');
                    const newMeta = (meta ? meta.textContent + ' ¬∑ ' : '') + 'Rating: ' + pct + '% (' + votes + ' votes)';
                    if(meta) meta.textContent = newMeta;
                    else node.querySelector('.info')?.appendChild(Object.assign(document.createElement('div'), { className:'meta', textContent:newMeta }));
                    addBadgeToProfileCard(node, p);
                  }
                }catch(e){}
              }
            });
          });
        });
        mo.observe(lb, { childList: true, subtree: true });
      }
    }catch(e){}

  } // enhanceOnce

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(enhanceOnce, 200);
  } else {
    document.addEventListener('DOMContentLoaded', () => setTimeout(enhanceOnce, 200));
  }

  // expose a helper to recompute later if needed
  window.__assistantEnhanceProfiles = enhanceOnce;

})(); 
</script>

<script>
// --- Assistant: enforce MIN_VOTES=1 and clean rating display ---
(function(){
  const MIN_VOTES = 1;
  function computeRatingPct(p){
    const sum = Number(p.ratingsSum ?? p.ratings ?? 0);
    const cnt = Number(p.ratingsCount ?? p.ratings_count ?? p.votes ?? 0);
    return (cnt && cnt>0) ? Math.round((sum / (cnt * 5)) * 100) : 0;
  }
  function enhanceLeaderboards(){
    try{
      const lb = document.getElementById('leaderboardList');
      if(!lb) return;
      lb.querySelectorAll('.leader-card').forEach(card => {
        const name = card.querySelector('.name')?.textContent?.trim() || '';
        let uid = card.getAttribute('data-uid') || card.getAttribute('data-id') || '';
        let p = null;
        if(uid && window.profiles && window.profiles.length){
          p = window.profiles.find(x => String(x.uid) === String(uid));
        }
        if(!p && name && window.profiles && window.profiles.length){
          p = window.profiles.find(x => (x.name||x.title||'').trim() === name);
        }
        if(p){
          const cnt = Number(p.ratingsCount || p.votes || 0);
          if(cnt < MIN_VOTES){
            card.style.display = 'none'; // hide entries with too few votes
            return;
          }
          p.ratingPct = computeRatingPct(p);
          const pct = p.ratingPct;
          const votes = cnt;
          const meta = card.querySelector('.meta');
          if(meta){
            meta.textContent = 'Rating: ' + pct + '% (' + votes + ' votes)';
          } else {
            const md = document.createElement('div');
            md.className='meta';
            md.textContent = 'Rating: ' + pct + '% (' + votes + ' votes)';
            card.querySelector('.info')?.appendChild(md);
          }
        }
      });
    }catch(e){ console.error(e); }
  }
  if(document.readyState==='complete' || document.readyState==='interactive'){
    setTimeout(enhanceLeaderboards, 300);
  } else {
    document.addEventListener('DOMContentLoaded', ()=> setTimeout(enhanceLeaderboards, 300));
  }
  window.__assistantEnhanceLeaderboards = enhanceLeaderboards;
})();
</script>

<script>
function refreshLeaderboards(type){
  try{ if(typeof normalizeRatingsForProfiles==='function') normalizeRatingsForProfiles(); }catch(e){}
  try{
    if(typeof renderLeaderboard==='function') renderLeaderboard(type||window._lastLeaderboardType||'hired');
    if(typeof displayLeaderboard==='function') displayLeaderboard(type||window._lastLeaderboardType||'hired');
    if(typeof switchLeaderboard==='function'){ window._lastLeaderboardType=type||window._lastLeaderboardType||'hired'; }
  }catch(e){}
}

(function patchRatingSubmission(){
  try{
    window.refreshLeaderboards=refreshLeaderboards;
    if(!window._ratingSubmitPatched){
      window._ratingSubmitPatched=true;
      if(typeof displayLeaderboard==='function'){
        const orig=displayLeaderboard;
        window.displayLeaderboard=function(t){
          try{ if(typeof normalizeRatingsForProfiles==='function') normalizeRatingsForProfiles(); }catch(e){}
          window._lastLeaderboardType=t||window._lastLeaderboardType||'hired';
          try{ orig(t); }catch(e){}
          try{ refreshLeaderboards(t); }catch(_){}
        };
      }
      if(typeof renderLeaderboard==='function'){
        const orig2=renderLeaderboard;
        window.renderLeaderboard=function(t){
          window._lastLeaderboardType=t||window._lastLeaderboardType||'hired';
          try{ orig2(t); }catch(e){}
        };
      }
    }
  }catch(e){}
})();

function downloadLeaderboard(){
  try{
    const data=(window.profiles&&window.profiles.length)?window.profiles:[];
    try{ if(typeof normalizeRatingsForProfiles==='function') normalizeRatingsForProfiles(); }catch(_){}
    const exportObj={
      exportedAt:(new Date()).toISOString(),
      count:data.length,
      profiles:data.map(p=>({
        uid:p.uid,name:p.name,
        hires:p.hires||p.hireCount||0,
        ratingsSum:p.ratingsSum||0,
        ratingsCount:p.ratingsCount||0,
        ratingsAvg:p.ratings||p.ratingsAvg||0,
        ratingPct:p.ratingPct||0,
        meta:p
      }))
    };
    const blob=new Blob([JSON.stringify(exportObj,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='leaderboard-'+(new Date().toISOString().slice(0,19)).replace(/[:T]/g,'-')+'.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }catch(e){ alert('Download failed: '+(e&&e.message?e.message:e)); }
}



<!-- RUNTIME PATCH: normalize ratings and fix leaderboard meta display (non-invasive) -->
<script>
(function(){
  function normalizeProfiles(){
    try{
      window.profiles = window.profiles || [];
      window.profiles.forEach(p => {
        p.ratingsSum = Number(p.ratingsSum ?? p.ratings ?? p.rating ?? 0) || 0;
        p.ratingsCount = Number(p.ratingsCount ?? p.ratings_count ?? p.votes ?? 0) || 0;
        p.ratingsAvg = p.ratingsCount ? (p.ratingsSum / p.ratingsCount) : 0;
        p.ratingPct = p.ratingsCount ? Math.round((p.ratingsAvg / 5) * 100) : 0;
        p.ratings = Math.round(p.ratingsAvg * 10) / 10;
        p.hireCount = Number(p.hireCount ?? p.hires ?? p.allTimeHires ?? 0) || 0;
        p.allTimeHires = Number(p.allTimeHires ?? p.hireCount ?? 0) || 0;
      });
    }catch(e){ console.warn('normalizeProfiles failed', e); }
  }

  function patchLeaderboards(){
    try{
      normalizeProfiles();
      // update any rendered leaderboard cards (.leader-card)
      document.querySelectorAll('.leader-card').forEach(card => {
        try{
          const info = card.querySelector('.leader-info, .info') || card;
          const strong = info.querySelector('strong');
          const uidNode = info.querySelector('.uid');
          let uid = '';
          if(uidNode) uid = uidNode.textContent.replace('UID:','').trim();
          if(!uid){
            // try data attribute
            uid = card.dataset && (card.dataset.uid || card.dataset.id) ? (card.dataset.uid || card.dataset.id) : '';
          }
          let p = null;
          if(uid && window.profiles && window.profiles.length){
            p = window.profiles.find(x => String(x.uid) === String(uid));
          }
          if(!p && strong){
            const name = strong.textContent.trim();
            p = window.profiles.find(x => (x.name || '').trim() === name);
          }
          if(!p) return;
          // detect active leaderboard type
          let activeBtn = document.querySelector('.leaderboard-tabs button.active') || document.querySelector('.leaderboard-tabs button[aria-pressed="true"]') || null;
          let type = 'hired';
          if(activeBtn){
            const t = (activeBtn.textContent || '').toLowerCase();
            if(t.includes('all')) type = 'alltime';
            else if(t.includes('rated')) type = 'rated';
            else if(t.includes('hired')) type = 'hired';
          } else {
            // fallback: infer by presence of keywords inside .meta
            const meta = info.querySelector('.meta');
            if(meta && /rating/i.test(meta.textContent)) type = 'hired';
          }
          const metaEl = info.querySelector('.meta') || info;
          if(!metaEl) return;
          let newMeta = '';
          if(type === 'hired'){
            newMeta = 'Hires: ' + (p.hireCount || 0) + ' ¬∑ Rating: ' + (p.ratingPct || 0) + '%';
          } else if(type === 'alltime'){
            newMeta = 'All-Time Hires: ' + (p.allTimeHires || 0) + ' ¬∑ Avg: ' + (p.ratingsCount ? p.ratingsAvg.toFixed(1) : '0') + ' /5 (' + (p.ratingPct || 0) + '%)';
          } else {
            newMeta = 'Avg: ' + (p.ratingsCount ? p.ratingsAvg.toFixed(1) : '0') + ' /5 ¬∑ ' + (p.ratingsCount || 0) + ' votes ¬∑ ' + (p.ratingPct || 0) + '%';
          }
          metaEl.textContent = newMeta;
        }catch(e){ /* per-card failure shouldn't stop others */ }
      });
    }catch(e){ console.warn('patchLeaderboards failed', e); }
  }

  // run after small delay on load and whenever leaderboard buttons are clicked
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(patchLeaderboards, 350);
  });
  // re-run when leaderboard controls are clicked
  document.addEventListener('click', function(ev){
    if(ev.target && ev.target.closest && ev.target.closest('.leaderboard-tabs')){
      setTimeout(patchLeaderboards, 250);
    }
  });
  // also expose for manual run
  window._patchLeaderboards = patchLeaderboards;
})();
</script>
<!-- END RUNTIME PATCH -->


<script>
document.addEventListener("DOMContentLoaded", () => {
  // Always land on Home when app opens
  showPage("home");
});
</script>


<!-- BEGIN: DevTools deterrent + detection (inserted by ChatGPT) -->
<style id="devtools-overlay-style">
#devtools-overlay {
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.94);
  color:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:2147483647;
  padding:24px;
  text-align:center;
  font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
  font-size:18px;
  line-height:1.4;
}
#devtools-overlay .box{
  max-width:760px;
  border-radius:12px;
  padding:22px;
  background: rgba(0,0,0,0.6);
  box-shadow: 0 12px 40px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.06);
}
#devtools-overlay.hidden { display:none !important; }
</style>

<script id="devtools-deterrent">
(function(){
  // ---- Config ----
  const dimensionThreshold = 160; // heuristic threshold for DevTools size detection
  const checkIntervalMs = 800;    // how often to check
  let overlayAdded = false;
  let overlayVisible = false;

  // Block common shortcuts & context menu (casual deterrent only)
  function blockShortcuts(e){
    // Normalize key
    const key = (e.key || "").toUpperCase();
    // F12
    if(e.key === "F12") { e.preventDefault(); e.stopPropagation(); return false; }
    // Ctrl+Shift+I / J / C
    if(e.ctrlKey && e.shiftKey && (key === "I" || key === "J" || key === "C")) { e.preventDefault(); e.stopPropagation(); return false; }
    // Ctrl+U (view-source)
    if(e.ctrlKey && key === "U") { e.preventDefault(); e.stopPropagation(); return false; }
    // Ctrl+S (save) optional block
    // if(e.ctrlKey && key === "S") { e.preventDefault(); e.stopPropagation(); return false; }
    return true;
  }

  function addShortcutListeners(){
    try {
      document.addEventListener('contextmenu', function(ev){ ev.preventDefault(); }, { passive:false });
      document.addEventListener('keydown', blockShortcuts, true);
    } catch(e){}
  }

  // Build and show overlay (only the first time)
  function ensureOverlay(){
    if(overlayAdded) return;
    overlayAdded = true;
    try{
      const div = document.createElement('div');
      div.id = 'devtools-overlay';
      div.className = 'hidden';
      div.innerHTML = '<div class="box"><h2 style="margin:0 0 8px 0; font-size:20px;">Developer tools detected</h2><div style="opacity:0.9">We detected that developer tools (or a similar inspector) is open. For security and privacy reasons, please close them to continue using this app normally.</div><div style="height:12px"></div><div style="opacity:0.9; font-size:13px">If this is a mistake, resize your window to a normal size and the overlay will disappear automatically.</div></div>';
      document.documentElement.appendChild(div);
    }catch(e){}
  }

  function showOverlay(){
    ensureOverlay();
    try{
      const el = document.getElementById('devtools-overlay');
      if(el){ el.classList.remove('hidden'); overlayVisible = true; }
    }catch(e){}
  }
  function hideOverlay(){
    try{
      const el = document.getElementById('devtools-overlay');
      if(el){ el.classList.add('hidden'); overlayVisible = false; }
    }catch(e){}
  }

  // Heuristic detection: compare outer vs inner dimensions
  function detectBySize(){
    try{
      const widthDiff = Math.abs(window.outerWidth - window.innerWidth);
      const heightDiff = Math.abs(window.outerHeight - window.innerHeight);
      return (widthDiff > dimensionThreshold) || (heightDiff > dimensionThreshold);
    }catch(e){ return false; }
  }

  // Secondary detection: timing side-effect (pauses when devtools open with debugger)
  // Use a high-resolution timer and measure if setTimeout gets delayed significantly.
  function detectByTimer(cb){
    const start = performance.now();
    setTimeout(function(){
      const delta = performance.now() - start;
      // If timeout delayed by a noticeable amount, devtools or heavy inspector may be open.
      if(delta > 200) cb(true); else cb(false);
    }, 50);
  }

  // Main periodic detection combining heuristics
  function periodicDetect(){
    try{
      const sizeOpen = detectBySize();
      detectByTimer(function(timerOpen){
        const open = sizeOpen || timerOpen;
        if(open && !overlayVisible){
          showOverlay();
          try{ console.clear(); }catch(e){}
        } else if(!open && overlayVisible){
          hideOverlay();
        }
      });
    }catch(e){}
  }

  // Defensive: attempt to make shortcuts less effective by resetting focus to body
  function defensiveFocus(){
    try{ document.activeElement && document.activeElement.blur && document.activeElement.blur(); }catch(e){}
  }

  // initialize
  addShortcutListeners();
  ensureOverlay();
  // Run a few fast checks first
  periodicDetect();
  // Schedule periodic checks
  const timer = setInterval(periodicDetect, checkIntervalMs);

  // Expose a noop-safe API for debugging/testing
  window.__devtoolsDeterrent = {
    showOverlay: showOverlay,
    hideOverlay: hideOverlay,
    destroy: function(){ clearInterval(timer); hideOverlay(); }
  };

})();
</script>
<!-- END: DevTools deterrent + detection -->


<!-- BEGIN: Improved robust delayed auth patch (10s; shows and centers auth reliably) -->
<script>
(function(){
  const DELAY_MS = 10000; // 10 seconds
  if(window.__improvedAuthPatchApplied) return;
  window.__improvedAuthPatchApplied = true;

  function ensureOverrideStyle(){
    try{
      var css = "#authPage{display:flex !important; position:fixed !important; inset:0 !important; align-items:center !important; justify-content:center !important; width:100% !important; height:100% !important; background:#f9fafb !important; z-index:2147483000 !important;}";
      var id = 'authForceCenterStyle';
      var existing = document.getElementById(id);
      if(existing) return existing;
      var s = document.createElement('style');
      s.id = id;
      s.appendChild(document.createTextNode(css));
      document.head.appendChild(s);
      return s;
    }catch(e){ console.warn('ensureOverrideStyle failed', e); return null; }
  }

  function showAuthFullScreen(){
    try{
      // add override style (ensures earlier rule can't hide the auth page)
      ensureOverrideStyle();
      // hide other pages
      try{ document.querySelectorAll('.page').forEach(p=>p.style.display='none'); }catch(e){}
      // show auth page
      var ap = document.getElementById('authPage');
      if(ap){
        ap.style.display = 'flex';
        // ensure inner card is centered and not absolutely positioned
        var card = ap.querySelector('.auth-card');
        if(card){
          card.style.margin = '0 auto';
          card.style.position = card.style.position || 'relative';
        }
        // bring focus to first input for accessibility
        setTimeout(()=>{ var inp = ap.querySelector('input,button,select,textarea'); if(inp) try{ inp.focus(); }catch(e){} }, 220);
      }
      if(typeof showPage === 'function') try{ showPage('authPage'); }catch(e){}
    }catch(e){ console.warn('showAuthFullScreen failed', e); }
  }

  function hideAuth(){
    try{
      var ap = document.getElementById('authPage');
      if(ap) ap.style.display='none';
      var s = document.getElementById('authForceCenterStyle'); if(s && s.parentNode) s.parentNode.removeChild(s);
    }catch(e){}
  }

  function scheduleForceTimer(){
    if(window.__authForceTimer) return;
    window.__authForceTimer = setTimeout(function(){
      try{
        // Only show if user is not signed in
        var userSignedIn = false;
        try{ if(window.firebase && firebase.auth && firebase.auth().currentUser) userSignedIn = !!firebase.auth().currentUser; }catch(e){}
        if(!userSignedIn){
          showAuthFullScreen();
        } else {
          hideAuth();
        }
      }catch(e){ console.warn(e); }
      window.__authForceTimer = null;
    }, DELAY_MS);
  }

  function init(){
    // schedule fallback timer immediately (so auth shows even if firebase never loads)
    scheduleForceTimer();

    // If firebase exists, hook into auth state to cancel timer/show/hide appropriately
    function hookFirebase(){
      try{
        if(window.firebase && firebase.auth){
          var auth = firebase.auth();
          if(auth && auth.onAuthStateChanged){
            auth.onAuthStateChanged(function(user){
              if(user){
                // signed in: hide auth, clear timers
                if(window.__authForceTimer){ clearTimeout(window.__authForceTimer); window.__authForceTimer = null; }
                hideAuth();
                if(window.__authDelayTimer){ clearTimeout(window.__authDelayTimer); window.__authDelayTimer = null; }
              } else {
                // not signed in: ensure timer scheduled
                scheduleForceTimer();
              }
            });
          }
          return true;
        }
      }catch(e){ console.warn('hookFirebase failed', e); }
      return false;
    }

    // try to hook immediately; if not available, retry a few times (~10s)
    var attempts = 0;
    function tryHook(){
      attempts++;
      if(hookFirebase()) return;
      if(attempts < 40) setTimeout(tryHook, 250);
    }
    tryHook();
  }

  if(document.readyState === 'complete' || document.readyState === 'interactive'){
    init();
  } else {
    document.addEventListener('DOMContentLoaded', init);
  }
})();
</script>
<!-- END: Improved robust delayed auth patch -->


<!-- BEGIN: Profile & Account-completion validation + Privacy confirmation modal -->
<!-- Privacy modal shown before creating a new profile -->
<div class="modal" id="privacyModal" aria-modal="true" role="dialog" style="z-index:2147484000;">
  <div class="modal-content" role="dialog" aria-modal="true">
    <button class="modal-close" onclick="document.getElementById('privacyModal')?.classList.remove('open')">‚úï</button>
    <h4>Confirm your profile</h4>
    <p class="note">Before creating your profile, please confirm the following ‚Äî this helps build trust on the platform:</p>
    <ul class="note" style="text-align:left;">
      <li>You are a legitimate worker offering real services.</li>
      <li>Your contact number is valid and belongs to you.</li>
      <li>All profile fields are filled honestly.</li>
    </ul>
    <div style="display:flex; align-items:center; gap:8px; margin-top:8px;">
      <input type="checkbox" id="privacyConfirmCheckbox" />
      <label for="privacyConfirmCheckbox" style="font-weight:700;">I confirm I am a real worker and my contact number is valid</label>
    </div>
    <div class="modal-buttons" style="margin-top:12px;">
      <button class="auth-primary" id="privacyConfirmBtn" disabled>Confirm &amp; Create</button>
      <button class="auth-secondary" id="privacyCancelBtn">Cancel</button>
    </div>
    <p class="auth-small-note" id="privacyNote" style="margin-top:10px;"></p>
  </div>
</div>

<script>
/* BEGIN: Enhancements: (1) Account-completion required fields enforcement
             (2) Create Profile: contact validation, focus behavior, privacy confirmation modal
             (3) Respect editing flow (existing profile edits still save directly)
*/

(function(){
  // Helpers
  function isValidContact(v){ return /^\d{10}$/.test((v||'').trim()); }
  function isPositiveNumber(v){ return !isNaN(Number(v)) && Number(v) > 0; }

  // --- Account completion modal: require fields and enable Save only when valid ---
  document.addEventListener('DOMContentLoaded', function(){
    var modal = document.getElementById('completeAccountModal');
    if(!modal) return;
    var username = document.getElementById('complete_username');
    var age = document.getElementById('complete_age');
    var stateInput = document.getElementById('stateInput');
    var district = document.getElementById('districtInput');
    var city = document.getElementById('cityInput');
    var saveBtn = document.getElementById('completeSaveBtn');
    var status = document.getElementById('completeAccountStatus');

    if(!saveBtn) return;

    function validateAccountComplete(){
      try{
        var ok = true;
        if(!username || !username.value.trim()) ok = false;
        if(!age || !isPositiveNumber(age.value) || Number(age.value) < 18) ok = false;
        if(!stateInput || !stateInput.value.trim()) ok = false;
        if(!district || !district.value.trim()) ok = false;
        if(!city || !city.value.trim()) ok = false;
        saveBtn.disabled = !ok;
        return ok;
      }catch(e){ return false; }
    }

    // Attach listeners
    [username, age, stateInput, district, city].forEach(function(el){
      if(!el) return;
      el.addEventListener('input', validateAccountComplete);
      el.addEventListener('change', validateAccountComplete);
    });

    // Observe when the modal opens so we can focus the first missing input
    var obs = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if(m.attributeName === 'class'){
          if(modal.classList.contains('open')){
            // focus first missing
            setTimeout(function(){
              if(!username.value.trim()){ username.focus(); }
              else if(!isPositiveNumber(age.value)){ age.focus(); }
              else if(!stateInput.value.trim()){ stateInput.focus(); }
              else if(!district.value.trim()){ district.focus(); }
              else if(!city.value.trim()){ city.focus(); }
              validateAccountComplete();
            }, 120);
          }
        }
      });
    });
    obs.observe(modal, { attributes: true });

    // Wrap existing saveCompleteAccount to enforce final validation and show message if invalid
    if(window.saveCompleteAccount && typeof window.saveCompleteAccount === 'function'){
      var origSave = window.saveCompleteAccount;
      window.saveCompleteAccount = async function(){
        try{
          if(!validateAccountComplete()){
            if(status) status.textContent = 'Please fill all required fields correctly.';
            // focus first invalid
            if(!username.value.trim()){ username.focus(); return; }
            if(!isPositiveNumber(age.value) || Number(age.value) < 18){ age.focus(); alert('Age must be 18 or above.'); return; }
            if(!stateInput.value.trim()){ stateInput.focus(); return; }
            if(!district.value.trim()){ district.focus(); return; }
            if(!city.value.trim()){ city.focus(); return; }
          } else {
            if(status) status.textContent = 'Saving‚Ä¶';
            return await origSave.apply(this, arguments);
          }
        }catch(e){
          // fallback to calling original (safer)
          try{ return await origSave.apply(this, arguments); }catch(_){}
        }
      };
    }
  });

  // --- Create Profile: contact validation, privacy modal, focus contact on open ---
  document.addEventListener('DOMContentLoaded', function(){
    var profileForm = document.getElementById('profileForm');
    var contactInput = document.getElementById('contact');
    var nameInput = document.getElementById('name');
    var ageInput = document.getElementById('age');
    var skillInput = document.getElementById('skill');
    var addressInput = document.getElementById('address');
    var cityInput = document.getElementById('city');
    var submitBtn = document.getElementById('submitBtn');

    var privacyModal = document.getElementById('privacyModal');
    var privacyCheckbox = document.getElementById('privacyConfirmCheckbox');
    var privacyBtn = document.getElementById('privacyConfirmBtn');
    var privacyCancel = document.getElementById('privacyCancelBtn');
    var privacyNote = document.getElementById('privacyNote');

    // Ensure privacy modal exists
    if(!profileForm || !contactInput) return;

    // Helper to validate profile fields
    
    function validateProfileFields(){
      // Stronger validation rules:
      // - name: letters, spaces, dots, hyphens, apostrophes, at least 2 letters and not digits-only
      // - age: number >=18 and <=100
      // - skill: selected
      // - address: at least 5 chars and contains at least 3 letters
      // - city: at least 2 letters
      // - contact: exactly 10 digits
      // - description: at least 10 chars and contains letters
      try{
        var name = (nameInput && nameInput.value || '').trim();
        var ageVal = (ageInput && ageInput.value || '').toString().trim();
        var skill = (skillInput && skillInput.value || '');
        var addr = (addressInput && addressInput.value || '').trim();
        var city = (cityInput && cityInput.value || '').trim();
        var contact = (contactInput && contactInput.value || '').trim();
        var desc = (document.getElementById("description") && document.getElementById("description").value || '').trim();

        var lettersCount = function(s){ return (s.match(/[A-Za-z]/g) || []).length; };

        // name validation
        if(!name || lettersCount(name) < 2 || /[^A-Za-z\s\.\-\'\u00C0-\u017F]/.test(name)){
          return {ok:false, msg:'Enter a valid name (letters and basic punctuation only)', field:nameInput};
        }
        // age validation
        var ageNum = Number(ageVal);
        if(isNaN(ageNum) || ageNum < 18 || ageNum > 100){
          return {ok:false, msg:'Age must be between 18 and 100', field:ageInput};
        }
        // skill
        if(!skill || skill === ''){
          return {ok:false, msg:'Select a skill', field:skillInput};
        }
        // address validation (not random): min length and at least 3 letters
        if(!addr || addr.length < 5 || lettersCount(addr) < 3){
          return {ok:false, msg:'Enter a valid address', field:addressInput};
        }
        // city validation
        if(!city || lettersCount(city) < 2){
          return {ok:false, msg:'Enter a valid city name', field:cityInput};
        }
        // contact validation
        if(!/^\d{10}$/.test(contact)){
          return {ok:false, msg:'Contact must be a valid 10-digit number', field:contactInput};
        }
        // description
        if(desc.length < 10 || lettersCount(desc) < 3){
          return {ok:false, msg:'Description too short or unclear (min 10 characters)', field:document.getElementById('description')};
        }

        return {ok:true};
      }catch(e){
        console.warn('validateProfileFields error', e);
        return {ok:false, msg:'Validation failed', field:null};
      }
    }


    // Wrap existing openProfileForm to focus contact input for creation
    if(window.openProfileForm && typeof window.openProfileForm === 'function'){
      var origOpenProfileForm = window.openProfileForm;
      window.openProfileForm = function(){
        origOpenProfileForm.apply(this, arguments);
        // small delay to let page rendering happen
        setTimeout(function(){
          var createPage = document.getElementById('createProfilePage');
          if(createPage && createPage.style.display === 'block'){
            contactInput = document.getElementById('contact');
            if(contactInput) try{ contactInput.focus(); }catch(e){}
          }
        }, 120);
      };
    }

    // Extract existing save logic into a reusable function
    function saveProfileFromForm(){
      try{
        var profile = {
          uid: myProfile ? myProfile.uid : generateUID(),
          name: (document.getElementById("name").value || '').trim(),
          age: document.getElementById("age").value,
          skill: document.getElementById("skill").value,
          address: document.getElementById("address").value,
          city: document.getElementById("city").value,
          contact: (document.getElementById("contact").value || '').trim(),
          language: document.getElementById("language").value,
          description: (document.getElementById("description").value || '').trim(),
          status: myProfile ? document.getElementById("status")?.value || "Free" : "Free"
        };
        // final validation (defensive)
        var v = validateProfileFields();
        if(!v.ok){
          alert(v.msg);
          if(v.field) try{ v.field.focus(); }catch(e){}
          return;
        }

        if(myProfile){
          var idx = profiles.findIndex(function(p){ return p.uid === myProfile.uid; });
          if(idx !== -1) profiles[idx] = profile;
        } else {
          profiles.push(profile);
        }
        myProfile = profile;
        var profileBtn = document.getElementById("profileBtn");
        if(profileBtn) profileBtn.textContent = "Manage Profile";
        alert("Profile saved successfully!");
        try{ showPage('home'); }catch(e){}
      }catch(e){
        console.warn('saveProfileFromForm failed', e);
        alert('Failed to save profile. See console for details.');
      }
    }

    // Intercept form submit
    profileForm.addEventListener('submit', function(e){
      // prevent other handlers from running and stop default submit
      try{ e.preventDefault(); e.stopImmediatePropagation(); }catch(_){}
      // guard to avoid re-entrancy
      if(window.__profileSubmitHandled) return;
      window.__profileSubmitHandled = true;
      try{
        // run quick validation
        var v = validateProfileFields();
        if(!v.ok){
          alert(v.msg);
          if(v.field) try{ v.field.focus(); }catch(e){}
          window.__profileSubmitHandled = false;
          return;
        }
        // if editing existing profile (myProfile exists) -> save immediately (still validate age/contact)
        if(window.myProfile){
          saveProfileFromForm();
          window.__profileSubmitHandled = false;
          return;
        }
        // New profile: show privacy modal to confirm identity & contact BEFORE saving
        if(privacyModal){
          privacyModal.classList.add('open');
          // reset checkbox and disable confirm
          if(privacyCheckbox) { privacyCheckbox.checked = false; }
          if(privacyBtn) { privacyBtn.disabled = true; }
          if(privacyNote) { privacyNote.textContent = 'Please confirm you are a real worker and the contact number is accurate.'; }
          window.__profileSubmitHandled = false;
        } else {
          // fallback: save directly
          saveProfileFromForm();
          window.__profileSubmitHandled = false;
        }
      }catch(err){
        console.warn('submit handler failed', err);
        window.__profileSubmitHandled = false;
      }
    }, true);

    // Privacy modal interactions
    if(privacyCheckbox){
      privacyCheckbox.addEventListener('change', function(){ var ok = privacyCheckbox.checked && isValidContact(contactInput.value); if(privacyBtn) privacyBtn.disabled = !ok; if(!isValidContact(contactInput.value)){ if(privacyNote) privacyNote.textContent = 'Contact must be a valid 10-digit number.'; } else { if(privacyNote) privacyNote.textContent = ''; } });
    }

    if(privacyBtn){ privacyBtn.addEventListener('click', function(){
        // final verification before saving
        var v = validateProfileFields();
        if(!v.ok){ alert(v.msg); if(v.field) try{ v.field.focus(); }catch(e){}; return; }
        // close modal and save
        if(privacyModal) privacyModal.classList.remove('open');
        saveProfileFromForm();
      }); }
    if(privacyCancel){
      privacyCancel.addEventListener('click', function(){ if(privacyModal) privacyModal.classList.remove('open'); });
    }

    // Live contact validation: if user edits contact while privacy modal open, update button state
    contactInput.addEventListener('input', function(){
      if(privacyCheckbox && privacyCheckbox.checked){
        if(privacyBtn) privacyBtn.disabled = !isValidContact(contactInput.value);
      }
    });

  });

})(); 
/* END enhancements */
</script>
<!-- END: Profile & Account-completion validation + Privacy confirmation modal -->

<script>
// Delete profile helper ‚Äî removes current myProfile, clears form and navigates home
window.deleteProfile = function(){
  try{
    if(!window.myProfile){
      alert('No profile to delete.');
      return;
    }
    if(!confirm('Delete your profile? This cannot be undone.')) return;
    try{
      var uid = String(window.myProfile.uid);
      var idx = profiles.findIndex(function(p){ return String(p.uid) === uid; });
      if(idx !== -1) profiles.splice(idx,1);
    }catch(e){}
    window.myProfile = null;
    localStorage.removeItem('profiles_my_uid_v1');
    try{
      var f = document.getElementById('profileForm');
      if(f) f.reset();
      document.getElementById('profileBtn').textContent = 'Create a Profile';
    }catch(e){}
    try{ showPage('home'); }catch(e){
      document.querySelectorAll('.page').forEach(function(p){ p.style.display='none'; });
      var homeEl = document.getElementById('home');
      if(homeEl) homeEl.style.display = 'block';
    }
  }catch(e){ console.warn('deleteProfile failed', e); alert('Failed to delete profile.'); }
};

// Ensure create profile form is blank when there is no myProfile
(function(){
  var origShowPage = window.showPage;
  window.showPage = function(id){
    try{
      if(id === 'createProfilePage'){
        // if no myProfile, reset form to avoid prefilled values from previous deleted profile
        if(!window.myProfile){
          try{ var f = document.getElementById('profileForm'); if(f) f.reset(); }catch(e){}
          try{
            document.getElementById('formTitle').textContent = 'Create Your Profile';
            document.getElementById('submitBtn').textContent = '‚Çπ250';
            document.getElementById('statusSection').style.display='none';
          }catch(e){}
        }
      }
    }catch(e){}
    if(typeof origShowPage === 'function') return origShowPage.apply(this, arguments);
    else return;
  };
})();
</script>
</body>
</html>
