<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Profiles App ‚Äî Updated (Hire + description + better notifications)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{
    --primary:#0077ff;
    --primary-2:#2aa0ff;
    --accent:#ff6a00;
    --danger:#ff3333;
    --bg:#f4f7fb;
    --card-bg:#ffffff;
    --muted:#6b7280;
    --glass: rgba(255,255,255,0.6);
  }

  html,body{height:100%; margin:0; padding:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); color:#111;}
  .page{ display:none; min-height:100vh; box-sizing:border-box; padding:28px; }

  #home {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    padding: 0;
  }
#savedProfilesPage h2 {
  text-align: center;
  margin-top: 0;
  margin-bottom: 16px;
}


  .menu-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    gap: 22px;
    align-items: center;
  }

  .menu-container button{
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    border: none;
    border-radius: 14px;
    padding: 14px 32px;
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    box-shadow: 0 10px 28px rgba(0, 0, 0, 0.12);
    transition: all 0.25s ease;
}
    min-width:260px;
    font-size:18px;
    padding:12px 32px;
    border-radius:12px;
    border:none;
    cursor:pointer;
    font-weight:700;
    letter-spacing:0.2px;
    background: linear-gradient(90deg,var(--primary),var(--primary-2));
    color:#fff;
    box-shadow: 0 10px 30px rgba(34,120,255,0.12);
    transition: transform .22s ease, box-shadow .22s;
  }
  .menu-container button:hover{ transform: translateY(-4px); box-shadow: 0 16px 40px rgba(34,120,255,0.16); }

  button { font-family: inherit; }

  .back-btn{
    position:fixed;
    bottom:20px;
    left:20px;
    background:var(--danger);
    color:#fff;
    padding:10px 20px;
    border-radius:10px;
    border:none;
    cursor:pointer;
    font-weight:bold;
    box-shadow:0 6px 16px rgba(0,0,0,0.12);
  }

  /* Categories page */
  #categoriesPage h2{
    text-align:center;
    margin-top:0;
    margin-bottom:16px;
  }
  .categories{
    display:flex;
    justify-content:center;
    gap:12px;
    margin-bottom:18px;
    flex-wrap:wrap;
  }
  .category{
    background:#fff;
    padding:10px 18px;
    border-radius:999px;
    box-shadow:0 6px 18px rgba(12,40,80,0.06);
    cursor:pointer;
    font-weight:600;
    transition: background .2s, transform .12s;
  }
  .category:hover{ transform: translateY(-4px); }

  .search-bar{ display:flex; justify-content:center; margin-bottom:20px; }
  .search-bar input{
    width:50%;
    max-width:520px;
    padding:12px 14px;
    border:1px solid #e6eefc;
    border-radius:12px;
    font-size:16px;
    box-shadow: 0 6px 20px rgba(18,40,80,0.04);
  }

  .profile-list{ display:flex; flex-direction:column; gap:12px; padding-bottom:80px; }
  .profile-box{
    background:linear-gradient(180deg,#ffffff, #fbfdff);
    color:#111;
    padding:18px;
    border-radius:14px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-size:18px;
    box-shadow: 0 8px 28px rgba(14,30,70,0.06);
  }
  .profile-box button {
    background: linear-gradient(90deg,#28a745,#66cc66);
    color:#fff;
    border:none;
    border-radius:12px;
    padding:8px 16px;
    font-size:14px;
    cursor:pointer;
    font-weight:700;
    box-shadow:0 6px 18px rgba(34,120,255,0.06);
    transition:transform .18s, box-shadow .18s;
  }
  .profile-box button:hover {
    transform:translateY(-3px);
    box-shadow:0 10px 26px rgba(34,120,255,0.08);
  }

  .save-btn {
    margin-left: 12px;
    cursor: pointer;
    font-size: 20px;
    user-select:none;
  }
  .saved { color: gold; }

  /* Create Profile form */
  #createProfilePage h2{ text-align:center; margin-bottom:14px; }
  form{
    display:flex;
    flex-direction:column;
    gap:12px;
    max-width:520px;
    margin:auto;
    background:#fff;
    padding:20px;
    border-radius:12px;
    box-shadow:0 6px 24px rgba(14,30,70,0.06);
  }
  input,select,textarea{
    padding:12px;
    font-size:16px;
    border-radius:8px;
    border:1px solid #e8eefb;
  }
  input:focus,select:focus,textarea:focus{ border-color:var(--primary); outline:none; box-shadow:0 8px 20px rgba(42,160,255,0.06); }
  .note{ font-size:13px; color:var(--muted); }

  form button[type="submit"] {
    background: linear-gradient(90deg,var(--accent),#ff3c82);
    font-size:18px;
    font-weight:800;
    border:none;
    border-radius:12px;
    color:#fff;
    padding:12px;
    cursor:pointer;
    box-shadow:0 10px 28px rgba(255,80,120,0.08);
    transition:transform .16s, box-shadow .16s;
  }
  form button[type="submit"]:hover {
    transform:scale(1.02);
    box-shadow:0 14px 38px rgba(255,80,120,0.12);
  }

  /* Redesigned open profile card */
  .open-profile{
    background: linear-gradient(180deg,#0f172a 0%, #071229 60%);
    color:#fff;
    padding:22px;
    max-width:820px;
    margin:28px auto;
    border-radius:18px;
    box-shadow: 0 18px 40px rgba(3,9,23,0.6);
    position:relative;
    text-align:left;
    overflow:hidden;
  }
  .open-profile .close-btn{
    position:absolute;
    top:14px; right:14px;
    background:transparent;
    color:#fff;
    border:none;
    padding:8px;
    border-radius:8px;
    cursor:pointer;
    font-size:18px;
    background: rgba(255,255,255,0.06);
  }
  .profile-header{
    display:flex;
    gap:18px;
    align-items:center;
  }
  .avatar{
    width:96px; height:96px; border-radius:18px;
    background: linear-gradient(135deg,#1e3a8a,#0ea5a6);
    display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:28px; color:#fff;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
  }
  .profile-head-info h3{ margin:0 0 6px 0; font-size:24px; letter-spacing:0.2px; }
  .profile-meta{ display:flex; gap:8px; align-items:center; }
  .skill-badge{
    background: rgba(255,255,255,0.06);
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
  }
  .status-badge{
    padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px;
    background: rgba(255,255,255,0.06);
  }
  .profile-body{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:14px;
    margin-top:18px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    padding:14px;
    border-radius:12px;
  }
  .profile-body strong{ color: #cfe8ff; display:block; margin-bottom:6px; font-weight:700; }
  .profile-body div{ color:#d6e9ff; padding-bottom:6px; }

  .profile-actions{
    margin-top:18px; display:flex; gap:12px; align-items:center;
  }
  .hire-btn{
    background: linear-gradient(90deg,#ff8a3d,#ff3c82);
    border:none; color:#fff; padding:12px 18px; font-weight:800; border-radius:12px; cursor:pointer;
    box-shadow:0 12px 30px rgba(255,60,130,0.14); font-size:16px;
  }
  .save-small{
    background:transparent; border:1px solid rgba(255,255,255,0.12); color:#fff; padding:10px 12px; border-radius:10px; cursor:pointer;
    font-weight:700;
  }

  .privacy-note{ margin-top:12px; font-size:13px; color:rgba(255,255,255,0.7); }

  /* Modal */
  .modal{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9999;
    background: linear-gradient(90deg, rgba(2,6,23,0.6), rgba(2,6,23,0.6));
    padding:20px;
  }
  .modal.open{ display:flex; }
  .modal-content{
    width:100%; max-width:520px; background: #fff; color:#111; border-radius:12px; padding:18px; position:relative;
    box-shadow:0 22px 60px rgba(2,6,23,0.3);
  }
  .modal-close{
    position:absolute; top:10px; right:10px; border:none; background:transparent; font-size:18px; cursor:pointer;
  }
  .modal-buttons{ display:flex; gap:12px; margin-top:10px; }
  .modal-buttons button{ flex:1; padding:12px; border-radius:10px; border:none; font-weight:700; cursor:pointer; }
  .modal-buttons button:first-child{ background: linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff; }
  .modal-buttons button:last-child{ background: #eef2ff; color:#111; }

  .modal-result{ margin-top:14px; padding:12px; border-radius:8px; background:#fbfdff; color:#0b1220; }
  .modal-result .note{ color:#6b7280; font-size:13px; margin-top:8px; }

  /* Notifications tab tweaks */
  #notificationsPage {
    display: flex;
    flex-direction: column;
    justify-content: flex-start; 
    align-items: center;          
    height: 100vh;
    padding-top: 40px;            
    text-align: center;
  }

  #notificationsPage .tabs {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  .tabs button {
    padding: 10px 16px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    background: #eee;
    font-weight: bold;
  }
  .tabs button.active {
    background: linear-gradient(90deg,#ff6a00,#ff3c82);
    color: white;
  }

  @media (max-width:700px){
    .profile-body{ grid-template-columns: 1fr; }
    .avatar{ width:80px; height:80px; border-radius:14px; }
    .open-profile{ padding:16px; border-radius:12px; margin:16px; }
  }

.contact-btn {
  flex:1;
  padding: 10px 16px;
  border-radius: 10px;
  border: none;
  font-weight: 700;
  cursor: pointer;
  font-size: 15px;
  transition: transform 0.2s, box-shadow 0.2s;
}
.copy-btn {
  background: linear-gradient(90deg,#0077ff,#2aa0ff);
  color: #fff;
}
.close-btn {
  background: linear-gradient(90deg,#ef4444,#f97316);
  color: #fff;
}
.contact-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.2);
}

</style>

<style>
  .icon-btn {
    background: linear-gradient(135deg, #0077ff, #2aa0ff);
    color: #fff;
    border: none;
    border-radius: 50%;
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .icon-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  }

  .dropdown {
    display: none;
    position: absolute;
    top: 44px;
    left: 0;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 8px 20px rgba(0,0,0,0.12);
    min-width: 160px;
    flex-direction: column;
    z-index: 200;
    overflow: hidden;
  }
  .dropdown div {
    padding: 12px 16px;
    cursor: pointer;
    font-weight: 600;
    transition: background 0.2s;
  }
  .dropdown div:hover {
    background: #f0f4ff;
    color: #0077ff;
  }
</style>


<style>
  .notif-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .notif-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.12);
  }
  .reply-btn {
    background: linear-gradient(90deg,#0077ff,#2aa0ff);
    color: #fff;
    margin-right: 6px;
  }
  .read-btn {
    background: linear-gradient(90deg,#22c55e,#4ade80);
    color: #fff;
  }
  .bell-container {
    position: relative;
    display: inline-block;
  }
  .bell-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    background: red;
    color: #fff;
    border-radius: 50%;
    padding: 2px 6px;
    font-size: 12px;
    font-weight: 700;
  }
</style>


<style>
/* Improved menu button styles (scoped to .menu-container to avoid affecting other buttons) */
.menu-container .menu-btn{
  min-width:260px;
  padding:14px 34px;
  border-radius:14px;
  border:none;
  cursor:pointer;
  font-weight:800;
  color:#fff;
  font-size:18px;
  box-shadow:0 12px 36px rgba(2,6,23,0.12);
  transition: transform .22s ease, box-shadow .22s;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:10px;
}
.menu-container .menu-btn.view-btn{
  background: linear-gradient(90deg,#06b6d4,#0ea5a6);
}
.menu-container .menu-btn.profile-btn{
  background: linear-gradient(90deg,#ff8a3d,#ff3c82);
}
.menu-container .menu-btn:hover{ transform: translateY(-6px); box-shadow: 0 18px 46px rgba(2,6,23,0.18); }
</style>

<!-- Added: Leaderboard + Ratings + UID styles -->
<style>
  /* Leaderboard styles */
  .leaderboard-tabs{display:flex;gap:10px;justify-content:center;margin-bottom:18px}
  .leaderboard-tabs button{padding:10px 16px;border-radius:10px;border:none;cursor:pointer;font-weight:700;background:#eee}
  .leaderboard-tabs button.active{background:linear-gradient(90deg,#0077ff,#2aa0ff);color:#fff}
  .leaderboard-list{display:flex;flex-direction:column;gap:12px;padding-bottom:40px}
  .leader-card{background:linear-gradient(180deg,#fff,#fbfdff);padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.06);display:flex;gap:12px;align-items:center}
  .leader-rank{font-size:32px;font-weight:900;width:64px;text-align:center;border-radius:8px;padding:6px}
  .leader-gold{background:linear-gradient(135deg,#facc15,#f59e0b);color:#111}
  .leader-silver{background:linear-gradient(135deg,#d1d5db,#9ca3af);color:#111}
  .leader-bronze{background:linear-gradient(135deg,#fbbf24,#b45309);color:#111}
  .leader-info strong{display:block;font-size:18px}
  .leader-info .uid{font-size:12px;color:var(--muted);margin-top:4px}
  .leader-info .meta{margin-top:8px;color:#374151;font-weight:700}
  /* Rating stars inside open profile */
  .profile-rating{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .rating-stars{display:inline-flex;gap:6px}
  .rating-stars span{cursor:pointer;font-size:20px;color:#e5e7eb}
  .rating-stars span.active{color:#fbbf24}
  .rating-result{margin-top:6px;font-weight:800;color:#0077ff}
  /* OTP box style */
  .otp-card{background:#ecfdf5;border:1px solid #bbf7d0;color:#065f46;padding:12px;border-radius:10px;font-weight:800;box-shadow:0 8px 30px rgba(2,6,23,0.04);margin-top:10px}
</style>
<!-- End injection -->
</head>

<body>

<div class="top-bar" style="position:fixed; top:12px; left:12px; right:12px; display:flex; justify-content:space-between; align-items:center; z-index:100;">
  <div id="menuWrap" style="position:relative;">
    <button class="icon-btn" onclick="toggleMenu()">‚ãÆ</button>
    <div id="menuDropdown" class="dropdown">
      <div onclick="showPage('savedProfilesPage')">Saved Profiles</div>
    </div>
  </div>
  <div id="bellWrap" class="bell-container"><button class="icon-btn" onclick="showPage('notificationsPage')">üîî</button></div>
</div>

<!-- Main menu -->
<div id="home" class="page">
  <div class="menu-container">
    <button class="menu-btn view-btn" onclick="showPage('categoriesPage')">View Profiles</button>
    <button id="profileBtn" class="menu-btn profile-btn" onclick="openProfileForm()">Create a Profile</button>
  </div>
</div>

<!-- Create Profile -->
<div id="createProfilePage" class="page">
  <h2 id="formTitle">Create Your Profile</h2>
  <form id="profileForm">
    <input type="text" id="name" placeholder="Your Name" required>
    <input type="number" id="age" placeholder="Your Age" required>
    <select id="skill" required>
      <option value="">-- Select Skill --</option>
      <option value="Plumber">Plumber</option>
      <option value="Mechanic">Mechanic</option>
      <option value="Electrician">Electrician</option>
      <option value="Painter">Painter</option>
      <option value="Tutor">Tutor</option>
    </select>
    <input type="text" id="address" placeholder="Your Address" required>
    <input type="text" id="contact" placeholder="Contact No." required>
    <label>Portfolio (optional):</label>
    <input type="file" id="portfolio">
    <p class="note">If not uploaded, you have to submit portfolio in 2 days.</p>
    <input type="text" id="language" placeholder="Languages Spoken">
    <textarea id="description" placeholder="Short description about you (will show under your name)" rows="3"></textarea>
    <div id="statusSection" style="display:none;">
      <label for="status">Profile Status:</label>
      <select id="status">
        <option value="Free" selected>Free</option>
        <option value="Busy">Busy</option>
      </select>
      <p class="note">Free means your profile is visible in the app. Busy will hide it, letting you rest.</p>
    </div>
    <button type="submit" id="submitBtn">‚Çπ250</button>
  </form>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<!-- View Profiles -->
<div id="categoriesPage" class="page">
  <h2>View Profiles</h2>
  <div class="categories" id="categoryFilter">
    <div class="category" onclick="filterSkill('All')">All</div>
    <div class="category" onclick="filterSkill('Plumber')">Plumber</div>
    <div class="category" onclick="filterSkill('Mechanic')">Mechanic</div>
    <div class="category" onclick="filterSkill('Electrician')">Electrician</div>
    <div class="category" onclick="filterSkill('Painter')">Painter</div>
    <div class="category" onclick="filterSkill('Tutor')">Tutor</div>
  </div>
  <div class="search-bar">
    <input type="text" id="searchInput" placeholder="Search by Name or UID" oninput="displayProfiles()">
  </div>
  <div id="profileList" class="profile-list"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<!-- Open Profile (redesigned) -->
<div id="openProfilePage" class="page">
  <div class="open-profile">
    <button class="close-btn" onclick="closeProfile()">‚úï</button>

    <div class="profile-header">
      <div class="avatar" id="profileAvatar">P</div>
      <div class="profile-head-info">
        <h3 id="profileName">Name</h3>
        <div id="profileDescription" style="margin-top:6px; color:#d6e9ff;"></div>
        <div class="profile-meta">
          <div id="profileSkill" class="skill-badge">Skill</div>
          <div id="profileStatus" class="status-badge">Status</div>
        </div>
      </div>
    </div>

    <div class="profile-body">
      <div>
        <strong>UID</strong>
        <div id="profileUID">‚Äî</div>
      </div>
      <div>
        <strong>Age</strong>
        <div id="profileAge">‚Äî</div>
      </div>
      <div>
        <strong>Address</strong>
        <div id="profileAddress">‚Äî</div>
      </div>
      <div>
        <strong>Languages Spoken</strong>
        <div id="profileLanguage">‚Äî</div>
      </div>
    </div>

    <div class="profile-actions">
      <button id="hireBtn" class="hire-btn" onclick="openHireModal()">Hire</button>
      <button id="saveBtn" class="save-small" onclick="toggleSaveFromOpen()">‚≠ê Save</button>
    </div>

    <p class="privacy-note">Contact is hidden by default. Click <strong>Hire ‚Üí Contact</strong> to view the number. </p>
  </div>
</div>

<!-- Hire modal -->
<div id="hireModal" class="modal" onclick="modalBackgroundClick(event)">
  <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="hireTitle">
    <button class="modal-close" onclick="closeHireModal()">‚úï</button>
    <h4 id="hireTitle">Hire Options</h4>
    <p class="note">Choose how you'd like to proceed with this profile.</p>
    <div class="modal-buttons">
      <button id="modalContactBtn" onclick="showContact()">Contact</button>
      <button id="modalMessageBtn" onclick="showMessage()">Message</button>
    </div>
    <div id="modalResult" class="modal-result" aria-live="polite"></div>
  </div>
</div>

<!-- Notifications -->
<div id="notificationsPage" class="page">
  <h2>Notifications</h2>
  <div class="tabs">
    <button onclick="switchTab('unread')" id="tab-unread" class="active">Unread</button>
    <button onclick="switchTab('read')" id="tab-read">Read</button>
    <button onclick="switchTab('hire')" id="tab-hire">Hire Requests</button>
  </div>
  <div id="notificationContent"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>


<!-- Chat Page -->
<div id="chatPage" class="page">
  <div style="display:flex; align-items:center; padding:12px; background:#0077ff; color:#fff; position:sticky; top:0; border-radius:0 0 12px 12px;">
    <button onclick="backFromChat()" style="background:none; border:none; color:#fff; font-size:18px; margin-right:12px; cursor:pointer;">‚Üê</button>
    <strong id="chatWithName">Chat</strong>
  </div>
  <div id="chatMessages" style="flex:1; overflow-y:auto; padding:16px; height:70vh; background:#f0f4ff; border-radius:12px; margin:12px 0;"></div>
  <div style="display:flex; gap:8px; padding:12px; background:#fff; border-radius:12px; box-shadow:0 -4px 10px rgba(0,0,0,0.08);">
    <input type="text" id="chatInput" placeholder="Type a message..." style="flex:1; padding:12px; border-radius:8px; border:1px solid #ddd; font-size:16px;">
    <button onclick="sendMessage()" style="background:linear-gradient(90deg,#0077ff,#2aa0ff); border:none; border-radius:8px; color:#fff; padding:0 18px; font-size:16px; cursor:pointer;">Send</button>
  </div>
</div>

<!-- Saved Profiles -->
<div id="savedProfilesPage" class="page">
  <h2>Saved Profiles</h2>
  <div class="categories" id="savedCategoryFilter">
    <div class="category" onclick="savedSkill='All';displaySaved()">All</div>
    <div class="category" onclick="savedSkill='Plumber';displaySaved()">Plumber</div>
    <div class="category" onclick="savedSkill='Mechanic';displaySaved()">Mechanic</div>
    <div class="category" onclick="savedSkill='Electrician';displaySaved()">Electrician</div>
    <div class="category" onclick="savedSkill='Painter';displaySaved()">Painter</div>
    <div class="category" onclick="savedSkill='Tutor';displaySaved()">Tutor</div>
  </div>
  <div class="search-bar">
    <input type="text" id="savedSearchInput" placeholder="Search in Saved" oninput="displaySaved()">
  </div>
  <div id="savedList" class="profile-list"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<script>
let profiles=[];
let savedProfiles=[];
let currentSkill='All';
let savedSkill='All';
let myProfile=null;
let currentOpenProfile=null;

function generateUID(){ return Date.now()+Math.floor(Math.random()*1000); }

function showPage(id){
  document.querySelectorAll('.page').forEach(p=>p.style.display='none');
  document.getElementById(id).style.display='block';

  if(id==='categoriesPage') displayProfiles();

  if(id==='savedProfilesPage') {
    displaySaved();
    // close 3-dots menu if open
    const dd = document.getElementById("menuDropdown");
    if(dd) {
      dd.style.display = "none";
      dd.style.removeProperty("display");
    }
  }

  if(id==='notificationsPage') {
    // restore the last active notifications tab (keeps user's previous context)
    switchTab(lastNotificationTab || 'unread');
  }
}


function filterSkill(skill){ currentSkill=skill; displayProfiles(); }

function openProfileForm(){
  showPage('createProfilePage');
  if(myProfile){
    document.getElementById('formTitle').textContent="Manage Your Profile";
    document.getElementById('submitBtn').textContent="Save";
    document.getElementById('statusSection').style.display="block";
    document.getElementById('name').value=myProfile.name;
    document.getElementById('age').value=myProfile.age;
    document.getElementById('skill').value=myProfile.skill;
    document.getElementById('address').value=myProfile.address;
    document.getElementById('contact').value=myProfile.contact;
    document.getElementById('language').value=myProfile.language;
    document.getElementById('description').value = myProfile.description || '';
    document.getElementById('status').value=myProfile.status;
  } else {
    document.getElementById('formTitle').textContent="Create Your Profile";
    document.getElementById('submitBtn').textContent="‚Çπ250";
    document.getElementById('statusSection').style.display="none";
    document.getElementById('profileForm').reset();
  }
}

document.getElementById("profileForm").addEventListener("submit",function(e){
  e.preventDefault();
  const profile={
    uid: myProfile ? myProfile.uid : generateUID(),
    name:document.getElementById("name").value.trim(),
    age:document.getElementById("age").value,
    skill:document.getElementById("skill").value,
    address:document.getElementById("address").value,
    contact:document.getElementById("contact").value.trim(),
    language:document.getElementById("language").value,
    description: document.getElementById("description").value.trim(),
    status: myProfile ? document.getElementById("status").value : "Free"
  };
  if(myProfile){
    const idx=profiles.findIndex(p=>p.uid===myProfile.uid);
    if(idx!==-1) profiles[idx]=profile;
  } else {
    profiles.push(profile);
  }
  myProfile=profile;
  document.getElementById("profileBtn").textContent="Manage Profile";
  alert("Profile saved successfully!");
  showPage('home');
});

function saveProfile(p){
  const index = savedProfiles.findIndex(sp=>sp.uid===p.uid);
  if(index===-1){
    savedProfiles.push(p);
    alert("Profile saved!");
  } else {
    savedProfiles.splice(index,1);
    alert("Removed from saved!");
  }
  displayProfiles();
  if(document.getElementById("savedProfilesPage").style.display==='block'){
    displaySaved();
  }
}

function displayProfiles(){
  const container=document.getElementById("profileList");
  container.innerHTML='';
  const search=document.getElementById("searchInput")?document.getElementById("searchInput").value.toLowerCase():"";
  profiles.filter(p=>{
    const statusMatch=p.status==="Free";
    const skillMatch=currentSkill==='All'||p.skill===currentSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return statusMatch&&skillMatch&&searchMatch;
  }).forEach(p=>{
    const box=document.createElement('div'); box.className='profile-box';
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê'; 
    if(savedProfiles.some(sp=>sp.uid===p.uid)) saveBtn.classList.add("saved");
    saveBtn.className='save-btn';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    container.appendChild(box);
  });
}

function openProfile(p){
  showPage('openProfilePage');
  currentOpenProfile = p;
  document.getElementById('profileName').textContent=p.name;
  document.getElementById('profileDescription').textContent = p.description || '';
  document.getElementById('profileUID').textContent=p.uid;
  document.getElementById('profileAge').textContent=p.age;
  document.getElementById('profileSkill').textContent=p.skill;
  document.getElementById('profileAddress').textContent=p.address;
  document.getElementById('profileLanguage').textContent=p.language;
  document.getElementById('profileStatus').textContent = p.status ? p.status : 'Free';

  // avatar initials
  const initials = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
  const avatar = document.getElementById('profileAvatar');
  avatar.textContent = initials;

  // update save button label/state
  updateSaveButtonState();
}

function closeProfile(){ showPage('categoriesPage'); currentOpenProfile=null; }

function toggleMenu(){
  const dd=document.getElementById("menuDropdown");
  dd.style.display = dd.style.display==="flex"?"none":"flex";
}

function displaySaved(){
  const c=document.getElementById("savedList");
  c.innerHTML="";
  const search=document.getElementById("savedSearchInput")?document.getElementById("savedSearchInput").value.toLowerCase():"";
  savedProfiles.filter(p=>{
    const skillMatch=savedSkill==='All'||p.skill===savedSkill;
    const searchMatch=p.name.toLowerCase().includes(search)||p.uid.toString().includes(search);
    return skillMatch&&searchMatch;
  }).forEach(p=>{
    const box=document.createElement('div'); box.className="profile-box";
    const left=document.createElement('div'); left.style.display='flex'; left.style.gap='12px'; left.style.alignItems='center';
    const tag=document.createElement('div'); tag.style.width='44px'; tag.style.height='44px'; tag.style.borderRadius='10px'; tag.style.background='linear-gradient(135deg,#1e3a8a,#0ea5a6)'; tag.style.display='flex'; tag.style.alignItems='center'; tag.style.justifyContent='center'; tag.style.color='#fff'; tag.style.fontWeight='800'; tag.textContent = p.name.split(' ').map(s=>s[0]||'').slice(0,2).join('').toUpperCase();
    const nameContainer=document.createElement('div'); nameContainer.style.display='flex'; nameContainer.style.flexDirection='column';
    const nameSpan=document.createElement('span'); nameSpan.textContent=p.name; nameSpan.style.fontWeight='700';
    const descSpan=document.createElement('div'); descSpan.style.fontSize='13px'; descSpan.style.color='#6b7280'; descSpan.textContent = p.description ? previewText(p.description,50) : '';
    nameContainer.appendChild(nameSpan); nameContainer.appendChild(descSpan);
    left.appendChild(tag); left.appendChild(nameContainer);

    const actions=document.createElement('div'); actions.className='profile-actions';
    const openBtn=document.createElement('button'); openBtn.textContent='Open'; openBtn.onclick=()=>openProfile(p);
    const saveBtn=document.createElement('span'); saveBtn.innerHTML='‚≠ê'; saveBtn.className='save-btn saved';
    saveBtn.onclick=()=>saveProfile(p);
    actions.appendChild(openBtn); actions.appendChild(saveBtn);
    box.appendChild(left); box.appendChild(actions);
    c.appendChild(box);
  });
}

/* HIRE modal logic */
function openHireModal(){
  if(!currentOpenProfile){ alert('No profile selected.'); return; }
  const modal=document.getElementById('hireModal');
  modal.classList.add('open');
  document.getElementById('modalResult').innerHTML = '';
}

function closeHireModal(){
  const modal=document.getElementById('hireModal');
  modal.classList.remove('open');
  document.getElementById('modalResult').innerHTML = '';
}

function modalBackgroundClick(e){
  if(e.target && e.target.id === 'hireModal') closeHireModal();
}

function showContact(){
  if(!currentOpenProfile) return;
  const modalResult = document.getElementById('modalResult');
  // show contact with gentle privacy warning
  modalResult.innerHTML = `
    <div><strong>Contact No.:</strong> <span id="visibleContact">${escapeHtml(currentOpenProfile.contact)}</span></div>
    <div class="note">Click 'Hire ‚Üí Contact' to view the number.</div>
    <div style="margin-top:10px; display:flex; gap:8px;">
      <button class="contact-btn copy-btn" onclick="copyToClipboard('${escapeJs(currentOpenProfile.contact)}')">üìã Copy</button>
      <button class="contact-btn close-btn" onclick="closeHireModal()">‚úñ Close</button>
    </div>
  `;
}

function showMessage(){
  const modalResult = document.getElementById('modalResult');
  modalResult.innerHTML = `<div><strong>Message</strong><div class="note">Coming soon ‚Äî in-app messaging will be available in a future update.</div></div>`;
}

/* Copy helper (uses Clipboard API when available) */
function copyToClipboard(text){
  if(navigator.clipboard && navigator.clipboard.writeText){
    navigator.clipboard.writeText(text).then(()=> {
      alert('Contact copied to clipboard.');
    }, ()=> {
      fallbackCopy(text);
    });
  } else {
    fallbackCopy(text);
  }
}
function fallbackCopy(text){
  const ta = document.createElement('textarea');
  ta.value=text; document.body.appendChild(ta);
  ta.select();
  try { document.execCommand('copy'); alert('Contact copied to clipboard.'); } catch(e){ alert('Copy failed ‚Äî please copy manually: '+text); }
  ta.remove();
}

/* Save toggle from open profile */
function toggleSaveFromOpen(){
  if(!currentOpenProfile) return;
  saveProfile(currentOpenProfile);
  updateSaveButtonState();
}

function updateSaveButtonState(){
  const btn=document.getElementById('saveBtn');
  if(!currentOpenProfile){ btn.textContent='‚≠ê Save'; return; }
  if(savedProfiles.some(sp=>sp.uid===currentOpenProfile.uid)){
    btn.textContent='‚≠ê Saved';
    btn.style.background='linear-gradient(90deg,#fde68a,#f97316)';
    btn.style.color='#111';
  } else {
    btn.textContent='‚≠ê Save';
    btn.style.background='transparent';
    btn.style.color='#fff';
  }
}

/* small helper to escape content inserted into HTML */
function escapeHtml(str){
  if(!str) return '';
  return String(str).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]; });
}
/* escape for JS single-quoted string insertion */
function escapeJs(str){
  if(!str) return '';
  return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'");
}



/* ===== Chat + Messaging System (fixed + improvements) ===== */
// Persistent storage keys
const STORAGE_KEYS = {
  MESSAGES: 'profiles_messages_v1',
  UNREAD: 'profiles_unread_notifications_v1',
  READ: 'profiles_read_notifications_v1'
};

// Data structures
let messages = {}; // { uid: [ {from:'me'|'them', text, time, seen:boolean}, ... ] }
let unreadNotifications = []; // [{uid,name,lastMessage,time}, ...]
let readNotifications = [];
let currentChatUID = null;
let lastNotificationTab = 'unread'; // remember last notifications tab so we can return to it
let notificationTabBeforeChat = null; // stores which tab the user was on BEFORE opening chat

// Load from localStorage
function loadMessagingState() {
  try {
    const rawMsgs = localStorage.getItem(STORAGE_KEYS.MESSAGES);
    messages = rawMsgs ? JSON.parse(rawMsgs) : {};
  } catch(e) { messages = {}; }
  try {
    const rawUnread = localStorage.getItem(STORAGE_KEYS.UNREAD);
    unreadNotifications = rawUnread ? JSON.parse(rawUnread) : [];
  } catch(e){ unreadNotifications = []; }
  try {
    const rawRead = localStorage.getItem(STORAGE_KEYS.READ);
    readNotifications = rawRead ? JSON.parse(rawRead) : [];
  } catch(e){ readNotifications = []; }
  updateNotificationBadge();
}

// Save to localStorage
function saveMessagingState() {
  try { localStorage.setItem(STORAGE_KEYS.MESSAGES, JSON.stringify(messages)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.UNREAD, JSON.stringify(unreadNotifications)); } catch(e){}
  try { localStorage.setItem(STORAGE_KEYS.READ, JSON.stringify(readNotifications)); } catch(e){}
  updateNotificationBadge();
}

// Utility to truncate preview
function previewText(t, len=80){
  if(!t) return '';
  return t.length>len ? t.slice(0,len-1)+'‚Ä¶' : t;
}

// Update bell badge (red circle)
function updateNotificationBadge() {
  const bellWrap = document.getElementById("bellWrap");
  if (!bellWrap) return;
  let count = unreadNotifications.length;
  let badge = bellWrap.querySelector(".bell-badge");
  if (count > 0) {
    if (!badge) {
      badge = document.createElement("span");
      badge.className = "bell-badge";
      bellWrap.appendChild(badge);
    }
    badge.textContent = count;
  } else {
    if (badge) badge.remove();
  }
}

let lastOpenedProfile = null; // store the profile you came from

// Open chat with a profile object {uid,name}
function openChat(profile) {
  if (!profile) return;

  // remember which profile you were viewing
  lastOpenedProfile = profile;

  // remember the notifications tab the user was on before opening chat
  notificationTabBeforeChat = lastNotificationTab || 'unread';
  currentChatUID = profile.uid;
  // load conversation messages from Firestore and attach realtime listener
  try{ if(typeof db !== 'undefined' && typeof myUID !== 'undefined' && myUID){ listenToChatMessages(myUID, profile.uid); loadChatMessagesOnce(myUID, profile.uid); } }catch(e){}

  const nameEl = document.getElementById("chatWithName");
  if (nameEl) nameEl.textContent = profile.name || "Chat";

  // Hide top icons while chatting
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "none";
  if (bellWrap) bellWrap.style.display = "none";

  showPage("chatPage");
  renderChat();
}

// Back from chat
function backFromChat() {
  // restore top icons
  const menuWrap = document.getElementById("menuWrap");
  const bellWrap = document.getElementById("bellWrap");
  if (menuWrap) menuWrap.style.display = "inline-block";
  if (bellWrap) bellWrap.style.display = "inline-block";

  // If a profile was open before chat ‚Üí go back there
  if (lastOpenedProfile) {
    openProfile(lastOpenedProfile); 
  } else {
    // fallback ‚Üí go to notifications (like your old logic)
    showPage('notificationsPage');
    switchTab(lastNotificationTab || 'unread');
  }
}

// Render chat messages for currentChatUID
function renderChat() {
  const container = document.getElementById("chatMessages");
  if (!container) return;
  container.innerHTML = "";
  if (!currentChatUID) {
    container.textContent = "No conversation selected.";
    return;
  }
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].forEach(m => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.marginBottom = "8px";
    row.style.alignItems = "flex-end";
    // bubble
    const bubble = document.createElement("div");
    bubble.textContent = m.text;
    bubble.style.maxWidth = "70%";
    bubble.style.padding = "10px 14px";
    bubble.style.borderRadius = "14px";
    bubble.style.wordBreak = "break-word";
    bubble.style.boxShadow = "0 6px 18px rgba(2,6,23,0.06)";
    // time small
    const timeSpan = document.createElement("div");
    timeSpan.textContent = m.time || "";
    timeSpan.style.fontSize = "11px";
    timeSpan.style.marginTop = "6px";
    timeSpan.style.opacity = "0.8";
    timeSpan.style.fontWeight = "600";
    if (m.from === "me") {
      row.style.justifyContent = "flex-end";
      bubble.style.background = "linear-gradient(90deg,#0077ff,#2aa0ff)";
      bubble.style.color = "#fff";
      // seen indicator
      const wrapper = document.createElement("div");
      wrapper.style.textAlign = "right";
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.display = "flex";
      meta.style.justifyContent = "flex-end";
      meta.style.gap = "8px";
      meta.style.alignItems = "center";
      const seenSpan = document.createElement("span");
      seenSpan.style.fontSize = "12px";
      seenSpan.style.opacity = m.seen ? "1" : "0.35";
      seenSpan.style.color = m.seen ? "#34d399" : "#e2e8f0"; // green when seen
      seenSpan.textContent = m.seen ? "‚úì‚úì Seen" : "‚úì Sent";
      meta.appendChild(timeSpan);
      meta.appendChild(seenSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    } else {
      row.style.justifyContent = "flex-start";
      bubble.style.background = "#e5e7eb";
      bubble.style.color = "#111";
      const wrapper = document.createElement("div");
      wrapper.appendChild(bubble);
      const meta = document.createElement("div");
      meta.style.marginTop = "6px";
      meta.appendChild(timeSpan);
      wrapper.appendChild(meta);
      row.appendChild(wrapper);
    }
    container.appendChild(row);
  });
  // scroll to bottom
  container.scrollTop = container.scrollHeight;
}

// Send a message from "me" to the currently opened profile
function sendMessage() {
  const input = document.getElementById("chatInput");
  if (!input) return;
  const text = input.value.trim();
  if (!text || !currentChatUID) return;
  const time = (new Date()).toLocaleString();
  const msg = {from: "me", text, time, seen: false};
  if (!messages[currentChatUID]) messages[currentChatUID] = [];
  messages[currentChatUID].push(msg);
  // Update / create unread notification for this profile (it represents the message waiting to be read)
  const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
  const existing = unreadNotifications.find(n => n.uid === currentChatUID);
  if (existing) {
    existing.lastMessage = text;
    existing.time = time;
  } else {
    unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
  }
  saveMessagingState();
  input.value = "";
  renderChat();
  // don't force switch to 'unread' ‚Äî keep user's current context (requested change)
}

// Helper to get profile name by UID from profiles array
function getProfileNameByUID(uid) {
  try {
    const p = profiles.find(x => x.uid === uid);
    return p ? p.name : null;
  } catch(e){ return null; }
}

// Mark a notification as read (move to readNotifications) and mark messages as seen
function markAsReadByUID(uid) {
  const idx = unreadNotifications.findIndex(n => n.uid === uid);
  if (idx === -1) return;
  const n = unreadNotifications.splice(idx,1)[0];
  readNotifications.unshift(n);
  // mark 'me' messages as seen for that conversation
  if (messages[uid]) {
    messages[uid].forEach(m => { if (m.from === "me") m.seen = true; });
  }
  saveMessagingState();
  // after marking read, show the Read tab (so user can use Delete / Reply)
  switchTab('read');
}

// Delete a notification from the read list
function deleteReadNotification(uid){
  const i = readNotifications.findIndex(x => x.uid === uid);
  if(i === -1) return;
  if(!confirm('Delete this read notification?')) return;
  readNotifications.splice(i,1);
  saveMessagingState();
  switchTab('read');
}

// Render notifications for current tab (unread/read)
function switchTab(tab){
  // remember last selected tab so we can return to it after opening chat
  lastNotificationTab = tab;
  document.querySelectorAll(".tabs button").forEach(btn=>btn.classList.remove("active"));
  const tabBtn = document.getElementById("tab-"+tab);
  if (tabBtn) tabBtn.classList.add("active");
  const content=document.getElementById("notificationContent");
  if (!content) return;
  content.innerHTML="";
  if(tab==="unread"){
    if(unreadNotifications.length===0){ content.textContent="No unread notifications."; updateNotificationBadge(); return; }
    unreadNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.08)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const readBtn = document.createElement("button"); readBtn.className = "notif-btn read-btn"; readBtn.textContent = "Mark as Read";
      readBtn.onclick = function(){ markAsReadByUID(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(readBtn);
      box.appendChild(actions);
      content.appendChild(box);
    });
  } else if(tab==="read"){
    if(readNotifications.length===0){ content.textContent="No read notifications."; return; }
    readNotifications.forEach(n=>{
      const box = document.createElement("div");
      box.style.background="#fff";
      box.style.margin="8px";
      box.style.padding="12px";
      box.style.borderRadius="10px";
      box.style.boxShadow="0 4px 12px rgba(0,0,0,0.06)";
      const title = document.createElement("div"); title.style.fontWeight="800"; title.textContent = n.name;
      const preview = document.createElement("div"); preview.style.marginTop = "6px"; preview.style.color="#374151"; preview.textContent = previewText(n.lastMessage,100);
      const time = document.createElement("div"); time.style.fontSize="12px"; time.style.color="#6b7280"; time.textContent = n.time;
      box.appendChild(title); box.appendChild(preview); box.appendChild(time);

      // add Reply + Delete buttons for read items (new: user requested)
      const actions = document.createElement("div"); actions.style.marginTop = "8px";
      const replyBtn = document.createElement("button"); replyBtn.className = "notif-btn reply-btn"; replyBtn.textContent = "Reply";
      replyBtn.onclick = function(){ openChat({uid: n.uid, name: n.name}); };
      const delBtn = document.createElement("button"); delBtn.className = "notif-btn"; delBtn.style.background = "linear-gradient(90deg,#ef4444,#f97316)"; delBtn.style.color = "#fff"; delBtn.textContent = "Delete";
      delBtn.onclick = function(){ deleteReadNotification(n.uid); };
      actions.appendChild(replyBtn); actions.appendChild(delBtn);
      box.appendChild(actions);

      content.appendChild(box);
    });
  } else if(tab==="hire") {
    content.textContent = "No hire notifications.";
  } else {
    content.textContent="No "+tab+" notifications.";
  }
  updateNotificationBadge();
}

// Overwrite showMessage to open chat from Hire modal
function showMessage(){
  if(!currentOpenProfile) return;
  closeHireModal();
  openChat(currentOpenProfile);
}

// Initialize on load
loadMessagingState();
/* ===== End Chat System ===== */
/* Start on home */
showPage('home');

</script>

<!-- BEGIN: Added script ‚Äî Simulate Profile-Owner Replies & Improved Notification Routing -->
<script>
/* Enhancements: profile-owner reply simulation and improved notification routing */

/* persist/remember a "myUID" for the current browser user (set when profile is saved) */
let myUID = null;
try {
  const s = localStorage.getItem('profiles_my_uid_v1');
  if (s) myUID = isNaN(s) ? s : Number(s);
} catch(e){ myUID = null; }

/* ensure we capture the profile save action and store myUID after the existing profile form runs */
(function(){
  const form = document.getElementById('profileForm');
  if (!form) return;
  form.addEventListener('submit', function(){
    // after the original submit handler runs it sets myProfile ‚Äî wait a bit and capture it
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          myUID = myProfile.uid;
          localStorage.setItem('profiles_my_uid_v1', String(myUID));
        }
      } catch(e){}
    }, 60);
  });
})();

/* override sendMessage so messages include fromUid/toUid and notifications go to the recipient */
(function(){
  const originalSend = window.sendMessage;
  window.sendMessage = function(){
    const input = document.getElementById("chatInput");
    if (!input) return;
    const text = input.value.trim();
    if (!text || !currentChatUID) return;
    const time = (new Date()).toLocaleString();
    if (!messages[currentChatUID]) messages[currentChatUID] = [];
    const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
    const msg = {from: "me", text: text, time: time, seen: false, fromUid: fromUid, toUid: currentChatUID};
    messages[currentChatUID].push(msg);

    // Update / create unread notification FOR THE RECIPIENT (simulate that the recipient has an unread)
    const profileName = getProfileNameByUID(currentChatUID) || "Unknown";
    const existing = unreadNotifications.find(n => n.uid === currentChatUID);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      unreadNotifications.push({uid: currentChatUID, name: profileName, lastMessage: text, time});
    }
    saveMessagingState();
    input.value = "";
    renderChat();
  };
})();

/* Function to simulate a reply originating from the profile owner (this will add a message 'from them' and create
   a simulated unread notification FOR THE SENDER ‚Äî stored in localStorage under 'profiles_unread_for_others_v1') */
function simulateProfileOwnerReply(uid, name) {
  const text = prompt('Type reply from profile owner to send to ' + (name || uid) + ':');
  if (!text) return;
  const time = (new Date()).toLocaleString();
  if (!messages[uid]) messages[uid] = [];
  const ownerUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'owner';
  const msg = {from: "them", text: text, time: time, seen: false, fromUid: ownerUid, toUid: uid};
  messages[uid].push(msg);

  // create/update the simulated unread for the sender (stored separately so it represents "the other user's unread")
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    const existing = otherUnread.find(n => n.uid === uid);
    if (existing) {
      existing.lastMessage = text;
      existing.time = time;
    } else {
      otherUnread.push({uid: uid, name: name || getProfileNameByUID(uid) || 'Unknown', lastMessage: text, time});
    }
    localStorage.setItem(key, JSON.stringify(otherUnread));
  } catch(e){ console.warn('simulateProfileOwnerReply storage failed', e); }

  saveMessagingState();
  alert('Reply sent as profile owner. Simulated unread for the sender created (localStorage key: profiles_unread_for_others_v1).');
}

/* Decorate the Notifications UI after it renders so each Unread box has a "Reply as Owner" button (which uses the function above).
   We do this by wrapping the existing switchTab function so the original behavior is preserved. */
(function(){
  const origSwitch = window.switchTab;
  window.switchTab = function(tab){
    origSwitch(tab);
    if (tab !== 'unread') return;
    // small delay to ensure DOM for notifications is built
    setTimeout(()=>{
      const content = document.getElementById('notificationContent');
      if (!content) return;
      // find all top-level notification boxes (heuristic: immediate child divs)
      const boxes = Array.from(content.children).filter(ch => ch.nodeType === 1);
      boxes.forEach(box => {
        // avoid adding the button twice
        if (box.querySelector('.owner-reply-btn')) return;
        // find the title text (first child div)
        const titleDiv = box.querySelector('div');
        const titleText = titleDiv ? titleDiv.textContent.trim() : '';
        // create button
        const ownerBtn = document.createElement('button');
        ownerBtn.className = 'notif-btn owner-reply-btn';
        ownerBtn.style.background = 'linear-gradient(90deg,#8b5cf6,#a78bfa)';
        ownerBtn.style.color = '#fff';
        ownerBtn.style.marginLeft = '6px';
        ownerBtn.textContent = 'Reply as Owner';
        ownerBtn.title = 'Simulate a reply from the profile owner ‚Äî will create an unread notification for the sender (simulated).';
        ownerBtn.onclick = function(){
          // Find the corresponding unreadNotifications entry by matching name or uid
          const cand = unreadNotifications.find(n => (n.name === titleText) || String(n.uid) === titleText);
          const uid = cand ? cand.uid : null;
          const name = cand ? cand.name : titleText;
          if (!uid) {
            alert('Could not determine UID for this notification. Try opening the chat and reply normally.');
            return;
          }
          simulateProfileOwnerReply(uid, name);
        };
        // append into the actions container if found (heuristic: last child)
        const actions = box.querySelector('div:nth-child(4)') || box;
        actions.appendChild(ownerBtn);
      });
    }, 60);
  };
})();

/* Optional helper: show the simulated "other users' unread" (useful for debugging/testing)
   This does not modify the original UI but can be called from the console:
   window.showSimulatedOtherUnread();
*/
function showSimulatedOtherUnread(){
  try {
    const key = 'profiles_unread_for_others_v1';
    const raw = localStorage.getItem(key);
    const otherUnread = raw ? JSON.parse(raw) : [];
    if (!otherUnread.length) { alert('No simulated unread entries for other users.'); return; }
    let out = 'Simulated unread entries for OTHER users:\\n\\n';
    otherUnread.forEach(n => { out += `${n.name} (uid: ${n.uid}) ‚Äî ${n.lastMessage} ‚Äî ${n.time}\\n`; });
    alert(out);
  } catch(e){ alert('Unable to read simulated unread storage.'); }
}

/* end added script */
</script>
<!-- END: Added script -->


<!-- BEGIN: Assistant-added: Hire Complete + OTP verification + Hire count -->
<script>
(function(){

const OTP_STORAGE_KEY = 'profiles_pending_otp_v1';
const PROFILES_PERSIST_KEY = 'profiles_data_v1';

// load profiles from storage if present (merge with in-memory 'profiles' variable)
try {
  const raw = localStorage.getItem(PROFILES_PERSIST_KEY);
  if (raw) {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      // merge without overwriting existing in-memory profiles (keep latest by uid)
      parsed.forEach(storedP => {
        const idx = profiles.findIndex(p => String(p.uid) === String(storedP.uid));
        if (idx === -1) profiles.push(storedP);
        else profiles[idx] = Object.assign({}, profiles[idx], storedP);
      });
    }
  }
} catch(e){ console.warn('Failed to load persisted profiles:', e); }

function saveProfilesToStorage() {
  try { localStorage.setItem(PROFILES_PERSIST_KEY, JSON.stringify(profiles)); } catch(e){ console.warn(e); }
}

// ensure hireCount exists for all profiles
(function ensureHireCounts(){
  let changed = false;
  profiles.forEach(p => { if (typeof p.hireCount === 'undefined') { p.hireCount = 0; changed = true; } });
  if (changed) saveProfilesToStorage();
})();

// after profile form submit (original script writes myProfile), make sure myProfile has hireCount and persist
const profileForm = document.getElementById('profileForm');
if (profileForm) {
  profileForm.addEventListener('submit', function(){
    setTimeout(()=>{
      try {
        if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) {
          if (typeof myProfile.hireCount === 'undefined') myProfile.hireCount = 0;
          const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
          if (idx !== -1) profiles[idx] = myProfile;
          else profiles.push(myProfile);
          saveProfilesToStorage();
          localStorage.setItem('profiles_my_uid_v1', String(myProfile.uid));
          myUID = myProfile.uid;
        }
      } catch(e){ console.warn(e); }
    }, 80);
  });
}

// override openProfile to display hires count (decorate existing function)
if (window.openProfile) {
  const origOpenProfile = window.openProfile;
  window.openProfile = function(p){
    try { origOpenProfile(p); } catch(e){ console.warn('orig openProfile failed', e); }
    // ensure profile object has hireCount
    const stored = profiles.find(x => String(x.uid) === String(p.uid)) || p;
    if (typeof stored.hireCount === 'undefined') stored.hireCount = 0;
    // create or update hires element
    let el = document.getElementById('profileHireCount');
    const container = document.querySelector('.profile-header .profile-head-info');
    if (!container) return;
    if (!el) {
      el = document.createElement('div');
      el.id = 'profileHireCount';
      el.style.marginTop = '8px';
      el.style.fontWeight = '800';
      el.style.color = '#ffd6e0';
      container.appendChild(el);
    }
    el.textContent = 'Hires: ' + (stored.hireCount || 0);
  };
}

// Add "Hire Complete" button to chat header (next to back button)
(function addChatHireButton(){
  const header = document.querySelector('#chatPage > div');
  if (!header) return;
  // avoid duplicates
  if (header.querySelector('.hire-complete-chat-btn')) return;
  const hireBtn = document.createElement('button');
  hireBtn.textContent = 'Hire Complete';
  hireBtn.className = 'hire-complete-chat-btn';
  hireBtn.style.marginLeft = '8px';
  hireBtn.style.padding = '8px 12px';
  hireBtn.style.borderRadius = '8px';
  hireBtn.style.border = 'none';
  hireBtn.style.cursor = 'pointer';
  hireBtn.style.fontWeight = '800';
  hireBtn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
  hireBtn.style.color = '#fff';
  hireBtn.onclick = function(){
    if (!currentChatUID) { alert('Open a chat first.'); return; }
    const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
    const toUid = currentChatUID;
    const toName = document.getElementById('chatWithName')?.textContent || '';
    sendHireOTP(fromUid, toUid, toName);
  };
  header.appendChild(hireBtn);
})();

// Decorate notifications unread boxes with "Hire Complete" button
(function wrapSwitchTabForHire(){
  if (!window.switchTab) return;
  const orig = window.switchTab;
  window.switchTab = function(tab){
    orig(tab);
    if (tab !== 'unread') return;
    setTimeout(()=>{
      const content = document.getElementById('notificationContent');
      if (!content) return;
      const boxes = Array.from(content.children).filter(ch => ch.nodeType === 1);
      boxes.forEach(box => {
        if (box.querySelector('.hire-complete-notif-btn')) return;
        // attempt to detect uid from the unreadNotifications array by matching title
        const titleDiv = box.querySelector('div');
        const titleText = titleDiv ? titleDiv.textContent.trim() : '';
        const cand = unreadNotifications.find(n => (n.name === titleText) || String(n.uid) === titleText);
        const uid = cand ? cand.uid : null;
        if (!uid) return;
        const actions = box.querySelector('div:nth-child(4)') || box;
        const btn = document.createElement('button');
        btn.className = 'hire-complete-notif-btn notif-btn';
        btn.style.background = 'linear-gradient(90deg,#ef4444,#f97316)';
        btn.style.color = '#fff';
        btn.style.marginLeft = '6px';
        btn.textContent = 'Hire Complete';
        btn.onclick = function(){
          const fromUid = (typeof myUID !== 'undefined' && myUID !== null) ? myUID : 'me';
          sendHireOTP(fromUid, uid, cand.name);
        };
        actions.appendChild(btn);
      });
    }, 60);
  };
})();

// sendHireOTP: create pending OTP record in localStorage and notify
function sendHireOTP(fromUid, toUid, toName) {
  try {
    const otp = String(Math.floor(100000 + Math.random()*900000));
    const time = (new Date()).toISOString();
    const rec = { otp: otp, fromUid: String(fromUid), toUid: String(toUid), time: time, toName: toName || '' };
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    arr.push(rec);
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));
    // dispatch a same-tab event (so the recipient tab in same window will also show prompt)
    window.dispatchEvent(new CustomEvent('profiles-otp-sent', {detail: rec}));
    // For testing/development we show OTP to the sender ‚Äî remove in production
    // show non-blocking OTP box instead of alert
        try{ document.getElementById('otpSentBox')?.remove(); }catch(e){}
        const otpBox = document.createElement('div');
        otpBox.id = 'otpSentBox';
        otpBox.className = 'otp-card';
        otpBox.style.position = 'fixed';
        otpBox.style.right = '20px';
        otpBox.style.bottom = '20px';
        otpBox.style.zIndex = 100000;
        otpBox.innerHTML = `
          <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;">
            <div>
              <div style="font-weight:800">OTP sent to ${escapeHtml(toName || toUid)}</div>
              <div style="margin-top:6px;font-weight:900;font-family:monospace;">Code (testing): ${otp}</div>
            </div>
            <div>
              <button onclick="document.getElementById('otpSentBox')?.remove()" style="padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:800;background:linear-gradient(90deg,#ef4444,#f97316);color:#fff;">Close</button>
            </div>
          </div>`;
        document.body.appendChild(otpBox);
  } catch(e){ console.warn('sendHireOTP failed', e); alert('Failed to send OTP'); }
}

// showPendingOTPModalForMe: if there's a pending OTP for myUID, prompt to verify
function showPendingOTPModalForMe() {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  let arr = [];
  try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
  const pending = arr.find(r => String(r.toUid) === String(myuid));
  if (!pending) return;
  // avoid duplicate modal
  if (document.getElementById('otpVerifyModal')) return;
  // build modal
  const modal = document.createElement('div');
  modal.id = 'otpVerifyModal';
  modal.className = 'modal open';
  modal.style.zIndex = 99998;
  modal.innerHTML = `
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="otpTitle">
      <button class="modal-close" onclick="document.getElementById('otpVerifyModal')?.remove()">‚úï</button>
      <h4 id="otpTitle">Verify Hire OTP</h4>
      <p class="note">Someone marked a hire complete for your profile. Enter the 6-digit OTP sent to you to confirm.</p>
      <div style="margin-top:8px;">
        <input id="otpInputField" placeholder="Enter 6-digit OTP" style="width:100%; padding:10px; font-size:16px; border-radius:8px; border:1px solid #e8eefb;">
      </div>
      <div style="margin-top:10px; display:flex; gap:8px;">
        <button id="otpVerifyBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:linear-gradient(90deg,#06b6d4,#0ea5a6); color:#fff;">Verify</button>
        <button id="otpCancelBtn" style="flex:1; padding:10px; border-radius:8px; border:none; font-weight:700; background:#eef2ff; color:#111;">Cancel</button>
      </div>
      <div id="otpNote" class="note"></div>
    </div>
  `;
  document.body.appendChild(modal);
  document.getElementById('otpCancelBtn').onclick = function(){ modal.remove(); };
  document.getElementById('otpVerifyBtn').onclick = function(){ verifyOTPForMe(document.getElementById('otpInputField').value.trim()); };
}

// verifyOTPForMe: check localStorage pending and validate; if OK increment hire count and remove pending otp
function verifyOTPForMe(value) {
  const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
  if (!myuid) return;
  try {
    let arr = [];
    try { const raw = localStorage.getItem(OTP_STORAGE_KEY); arr = raw ? JSON.parse(raw) : []; } catch(e){ arr = []; }
    const idx = arr.findIndex(r => String(r.toUid) === String(myuid) && String(r.otp) === String(value));
    if (idx === -1) {
      const note = document.getElementById('otpNote');
      if (note) note.textContent = 'Incorrect OTP. Please try again.';
      return;
    }
    const rec = arr.splice(idx,1)[0];
    localStorage.setItem(OTP_STORAGE_KEY, JSON.stringify(arr));
    // increment hireCount on associated profile (the owner)
    const pidx = profiles.findIndex(p => String(p.uid) === String(myuid));
    if (pidx !== -1) {
      profiles[pidx].hireCount = (profiles[pidx].hireCount || 0) + 1;
    } else {
      profiles.push({ uid: myuid, name: rec.toName || 'Profile', hireCount: 1 });
    }
    saveProfilesToStorage();
    // update UI if open profile is the same user
    const el = document.getElementById('profileHireCount');
    if (el) {
      const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
      el.textContent = 'Hires: ' + cnt;
    }
    // feedback
    alert('OTP verified. Hire marked complete ‚Äî hire count incremented.');
    // remove modal
    document.getElementById('otpVerifyModal')?.remove();
    // push a small read notification for record
    readNotifications.unshift({ uid: myuid, name: getProfileNameByUID(myuid) || 'Profile', lastMessage: 'Hire completed (verified)', time: new Date().toLocaleString() });
    saveMessagingState();
    switchTab('read');
  } catch(e){ console.warn(e); }
}

// react to storage events (other tabs)
window.addEventListener('storage', function(e){
  if (e.key === OTP_STORAGE_KEY) setTimeout(()=> showPendingOTPModalForMe(), 60);
});

// react to same-tab custom event
window.addEventListener('profiles-otp-sent', function(ev){ setTimeout(()=> showPendingOTPModalForMe(), 60); });

// run on load (in case OTP was stored while tab was inactive)
setTimeout(()=> showPendingOTPModalForMe(), 120);

})(); // end wrapper
</script>
<!-- END: Assistant-added: Hire Complete + OTP verification + Hire count -->


<!-- BEGIN: Leaderboard, Ratings & UID Integration -->
<div id="leaderboardPage" class="page" style="display:none; padding-top:28px;">
  <h2 style="text-align:center; margin-top:0;">Leaderboards</h2>
  <div class="leaderboard-tabs" role="tablist" aria-label="Leaderboards">
    <button id="lb-tab-hired" class="active" onclick="displayLeaderboard('hired')">Top 10 Most Hired</button>
    <button id="lb-tab-alltime" onclick="displayLeaderboard('alltime')">Top 10 All Time</button>
    <button id="lb-tab-rated" onclick="displayLeaderboard('rated')">Top 10 Most Rated</button>
  </div>
  <div id="leaderboardList" class="leaderboard-list" aria-live="polite"></div>
  <button class="back-btn" onclick="showPage('home')">Back</button>
</div>

<script>
/* Leaderboard + Ratings + UID integration script (appended) */
(function(){
  // safety: ensure global profiles exists
  if(typeof profiles === 'undefined') window.profiles = window.profiles || [];
  // helper: ensure fields
  function ensureFields(){
    profiles.forEach(p=>{
      if(typeof p.hireCount === 'undefined') p.hireCount = 0;
      if(typeof p.allTimeHires === 'undefined') p.allTimeHires = p.hireCount || 0;
      if(typeof p.ratingsSum === 'undefined') p.ratingsSum = 0;
      if(typeof p.ratingsCount === 'undefined') p.ratingsCount = 0;
    });
  }
  // compute rating %
  function ratingPctOf(p){ return p.ratingsCount ? Math.round((p.ratingsSum / (p.ratingsCount * 5)) * 100) : 0; }

  // create menu item in 3-dots dropdown
  try{
    const dd = document.getElementById('menuDropdown');
    if(dd && !document.getElementById('menuDropdownLeaderboard')){
      const el = document.createElement('div');
      el.id = 'menuDropdownLeaderboard';
      el.textContent = 'Leaderboard';
      el.style.cursor = 'pointer';
      el.onclick = function(){ showPage('leaderboardPage'); displayLeaderboard('hired'); };
      dd.appendChild(el);
    }
  }catch(e){ console.warn('menuDropdown append failed',e); }

  // display leaderboard
  window.displayLeaderboard = function(type){
    ensureFields();
    // tab active classes
    document.querySelectorAll('.leaderboard-tabs button').forEach(b=>b.classList.remove('active'));
    if(type==='hired') document.getElementById('lb-tab-hired').classList.add('active');
    if(type==='alltime') document.getElementById('lb-tab-alltime').classList.add('active');
    if(type==='rated') document.getElementById('lb-tab-rated').classList.add('active');

    const list = document.getElementById('leaderboardList');
    list.innerHTML = '';
    // compute rating pct for sorting
    const arr = profiles.map(p=>{
      return Object.assign({}, p, { ratingPct: ratingPctOf(p) });
    });
    if(type === 'hired'){
      arr.sort((a,b)=> (b.hireCount - a.hireCount) || (b.ratingPct - a.ratingPct) );
    } else if(type === 'alltime'){
      // All-time uses allTimeHires (cumulative) then rating%
      arr.sort((a,b)=> (b.allTimeHires - a.allTimeHires) || (b.ratingPct - a.ratingPct) );
    } else {
      // rated
      arr.sort((a,b)=> (b.ratingPct - a.ratingPct) || (b.hireCount - a.hireCount) );
    }
    const top = arr.slice(0,10);

    // compute rank numbers but keep same rank for ties (primary + secondary equal)
    let lastPrimary = null, lastSecondary = null, lastRank = 0;
    top.forEach((p, i)=>{
      const primary = (type==='alltime') ? (p.allTimeHires||0) : (type==='rated' ? p.ratingPct : (p.hireCount||0));
      const secondary = p.ratingPct || 0;
      let rank = i+1;
      if(i>0 && primary===lastPrimary && secondary===lastSecondary) rank = lastRank;
      lastPrimary = primary; lastSecondary = secondary; lastRank = rank;
      const card = document.createElement('div'); card.className = 'leader-card';
      // rank box
      const rankBox = document.createElement('div'); rankBox.className = 'leader-rank';
      if(rank===1) rankBox.classList.add('leader-gold');
      else if(rank===2) rankBox.classList.add('leader-silver');
      else if(rank===3) rankBox.classList.add('leader-bronze');
      rankBox.textContent = rank;
      // info block
      const info = document.createElement('div'); info.className = 'leader-info';
      const nameHtml = document.createElement('div');
      const strong = document.createElement('strong'); strong.textContent = p.name || ('UID ' + (p.uid || '‚Äî'));
      nameHtml.appendChild(strong);
      const uid = document.createElement('div'); uid.className='uid'; uid.textContent = 'UID: ' + (p.uid || '‚Äî');
      nameHtml.appendChild(uid);
      const meta = document.createElement('div'); meta.className='meta';
      // choose fields shown per leaderboard type
      if(type==='hired'){
        meta.textContent = 'Hires: ' + (p.hireCount||0);
      } else if(type==='alltime'){
        meta.textContent = 'All-Time Hires: ' + (p.allTimeHires||0) + ' ¬∑ Rating: ' + (p.ratingPct||0) + '%';
      } else {
        meta.textContent = 'Rating: ' + (p.ratingPct||0) + '%';
      }
      info.appendChild(nameHtml);
      info.appendChild(meta);

      // append without open button (leaderboard should not show Open)
      card.appendChild(rankBox);
      card.appendChild(info);
      list.appendChild(card);
    });
    // ensure we are on leaderboard page
    showPage('leaderboardPage');
  };

  // Override openProfile to inject rating UI (preserve original behavior)
  if(window.openProfile){
    const origOpen = window.openProfile;
    window.openProfile = function(p){
      try{ origOpen(p); } catch(e){ console.warn('orig openProfile error', e); }
      try{
        ensureFields();
        const container = document.querySelector('.profile-header .profile-head-info');
        if(!container) return;
        // remove previous rating container if exists
        const prev = document.getElementById('profileRatingContainer');
        if(prev) prev.remove();

        const rc = document.createElement('div'); rc.id='profileRatingContainer'; rc.className='profile-rating';
        // star row (select-only, no auto submit)
        const starRow = document.createElement('div'); starRow.className='rating-stars';
        const selected = {value:0};
        for(let i=1;i<=5;i++){
          const s = document.createElement('span');
          s.innerHTML = '‚òÖ';
          s.dataset.value = i;
          s.style.userSelect = 'none';
          s.onclick = function(){
            // highlight up to this star
            selected.value = Number(this.dataset.value);
            const stars = starRow.querySelectorAll('span');
            stars.forEach(st => {
              if(Number(st.dataset.value) <= selected.value) st.classList.add('active');
              else st.classList.remove('active');
            });
            // enable submit
            submitBtn.disabled = false;
          };
          starRow.appendChild(s);
        }
        rc.appendChild(starRow);

        // submit button (disabled until selection)
        const submitBtn = document.createElement('button');
        submitBtn.textContent = 'Submit Rating';
        submitBtn.style.marginTop = '8px';
        submitBtn.style.padding = '8px 12px';
        submitBtn.style.borderRadius = '8px';
        submitBtn.style.border = 'none';
        submitBtn.style.cursor = 'pointer';
        submitBtn.style.fontWeight = '800';
        submitBtn.style.background = 'linear-gradient(90deg,#06b6d4,#0ea5a6)';
        submitBtn.style.color = '#fff';
        submitBtn.disabled = true;
        rc.appendChild(submitBtn);

        // rating bar container (hidden until after submit or if already voted)
        const barWrap = document.createElement('div');
        barWrap.style.marginTop = '10px';
        barWrap.style.display = 'block';
        const barOuter = document.createElement('div');
        barOuter.style.width = '100%';
        barOuter.style.height = '14px';
        barOuter.style.background = '#e6eefc';
        barOuter.style.borderRadius = '10px';
        barOuter.style.overflow = 'hidden';
        const barInner = document.createElement('div');
        barInner.style.height = '100%';
        barInner.style.width = '0%';
        barInner.style.transition = 'width 450ms ease';
        barInner.style.background = 'linear-gradient(90deg,#fbbf24,#f97316)';
        barOuter.appendChild(barInner);
        const pctText = document.createElement('div');
        pctText.style.marginTop = '8px';
        pctText.style.fontWeight = '800';
        pctText.style.color = '#0077ff';
        barWrap.appendChild(barOuter);
        barWrap.appendChild(pctText);
        rc.appendChild(barWrap);

        container.appendChild(rc);

        // helper to render rating bar based on profile
        function renderRatingResult(profileObj, hideControls){
          const idx = profiles.findIndex(x=>String(x.uid)===String(profileObj.uid));
          const pct = idx===-1 ? 0 : Math.round(((profiles[idx].ratingsSum || 0) / ((profiles[idx].ratingsCount||0) * 5)) * 100) || 0;
          // show or hide the selection controls depending on whether the user already voted
          if (hideControls) {
            starRow.style.display = 'none';
            submitBtn.style.display = 'none';
          } else {
            starRow.style.display = '';
            submitBtn.style.display = '';
          }
          // rating bar always visible
          barWrap.style.display = 'block';
          // animate bar
          setTimeout(()=>{ barInner.style.width = pct + '%'; }, 50);
          pctText.textContent = 'Ratings: ' + pct + '%';
        }

        // handle submit click
        submitBtn.onclick = function(){
          const score = Number(selected.value || 0);
          if(!score || !p || typeof p.uid === 'undefined'){ alert('Select stars to submit.'); return; }
          // find or create profile entry
          const idx = profiles.findIndex(x=>String(x.uid)===String(p.uid));
          if(idx===-1){
            const newP = { uid: p.uid, name: p.name || ('UID '+p.uid), hireCount: p.hireCount||0, allTimeHires: p.allTimeHires||0, ratingsSum: score, ratingsCount: 1 };
            profiles.push(newP);
          } else {
            profiles[idx].ratingsSum = (profiles[idx].ratingsSum || 0) + score;
            profiles[idx].ratingsCount = (profiles[idx].ratingsCount || 0) + 1;
          }
          // persist profiles
          try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
          // mark voted locally to prevent re-vote
          const votedKey = 'profiles_votes_v1';
          let voted = [];
          try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
          voted.push(String(p.uid)); localStorage.setItem(votedKey, JSON.stringify(voted));
          // show result bar
          renderRatingResult(p, true);
          // refresh leaderboards if visible
          try{ if(document.getElementById('leaderboardPage') && document.getElementById('leaderboardPage').style.display!=='none') displayLeaderboard(document.querySelector('.leaderboard-tabs button.active')?.id?.includes('hired') ? 'hired' : (document.querySelector('.leaderboard-tabs button.active')?.id?.includes('alltime') ? 'alltime' : 'rated')); }catch(e){}
        };

        // If already voted -> show bar immediately
        const votedKey = 'profiles_votes_v1';
        let voted = [];
        try{ voted = JSON.parse(localStorage.getItem(votedKey) || '[]'); }catch(e){ voted = []; }
        renderRatingResult(p, voted.includes(String(p.uid)));}catch(e){ console.warn('rating widget error', e); }
    };
  }  // Wrap verifyOTPForMe to also increment allTimeHires (keeps original behavior)
  if(window.verifyOTPForMe){
    const origVerify = window.verifyOTPForMe;
    window.verifyOTPForMe = function(val){
      try{ origVerify(val); } catch(e){ console.warn('orig verifyOTP failed',e); }
      try{
        const myuid = (typeof myUID !== 'undefined' && myUID !== null) ? String(myUID) : null;
        if(!myuid) return;
        ensureFields();
        const idx = profiles.findIndex(p=> String(p.uid) === String(myuid));
        if(idx !== -1){
          profiles[idx].allTimeHires = (profiles[idx].allTimeHires || 0) + 1;
        } else {
          // if profile not present, create minimal entry
          profiles.push({ uid: myuid, name: ('UID '+myuid), hireCount: 0, allTimeHires: 1, ratingsSum:0, ratingsCount:0 });
        }
        // persist
        try{ if(typeof saveProfilesToStorage === 'function') saveProfilesToStorage(); else localStorage.setItem('profiles_data_v1', JSON.stringify(profiles)); }catch(e){}
        // update open profile UI if it's the same profile
        try{
          const el = document.getElementById('profileHireCount');
          if(el){
            const cnt = (profiles.find(p => String(p.uid) === String(myuid)) || {}).hireCount || 0;
            el.textContent = 'Hires: ' + cnt;
          }
        }catch(e){}
      }catch(e){ console.warn('post-verify wrapper error', e); }
    };
  }

  // Expose a helper to force refresh leaderboards externally
  window.refreshLeaderboards = function(){ if(document.getElementById('leaderboardPage') && document.getElementById('leaderboardPage').style.display!=='none'){ const active = document.querySelector('.leaderboard-tabs button.active'); if(active) { if(active.id.includes('hired')) displayLeaderboard('hired'); else if(active.id.includes('alltime')) displayLeaderboard('alltime'); else displayLeaderboard('rated'); } } };

  // run an initial ensure
  ensureFields();
})();
</script>
<!-- END: Leaderboard, Ratings & UID Integration -->


<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>
// Firebase config (from user)
const firebaseConfig = {
  apiKey: "AIzaSyAByLACmttf6BY6r0hEmZKYontfVqnDNpM",
  authDomain: "mndpschoolrspura.firebaseapp.com",
  projectId: "mndpschoolrspura",
  storageBucket: "mndpschoolrspura.firebasestorage.app",
  messagingSenderId: "810534224714",
  appId: "1:810534224714:web:a3055b4a6b3bca507337b3",
  measurementId: "G-2610K130EN"
};

// Init Firebase
const appFB = firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

// --- Assistant-injected chat sync helpers: load existing messages and add realtime listeners ---
const chatListeners = {};
async function loadChatMessagesOnce(myUid, otherUid){
  try{
    if(!myUid || !otherUid || !db) return;
    const chatId = chatIdFor(myUid, otherUid);
    if(!chatId) return;
    const msgs = [];
    const snap = await db.collection('chats').doc(chatId).collection('messages').orderBy('time').get();
    snap.forEach(doc=>{
      const d = doc.data();
      const fromIsMe = String(d.fromUid) === String(myUid);
      msgs.push({
        from: fromIsMe ? 'me' : 'them',
        text: d.text || d.lastMessage || '',
        time: d.time ? (new Date(d.time)).toLocaleString() : (d.timeString || ''),
        fromUid: d.fromUid,
        toUid: d.toUid,
        seen: !!d.seen
      });
    });
    // store using the other user's id as key (so UI code that uses messages[otherUid] works)
    messages[String(otherUid)] = msgs;
    saveMessagingState();
    if (String(currentChatUID) === String(otherUid)) try{ renderChat(); }catch(e){}
  }catch(e){ console.warn('loadChatMessagesOnce failed', e); }
}

function listenToChatMessages(myUid, otherUid){
  try{
    if(!myUid || !otherUid || !db) return;
    const chatId = chatIdFor(myUid, otherUid);
    if(!chatId) return;
    if(chatListeners[chatId]) return; // already listening
    const ref = db.collection('chats').doc(chatId).collection('messages').orderBy('time');
    chatListeners[chatId] = ref.onSnapshot(snapshot=>{
      const msgs = [];
      snapshot.forEach(doc=>{
        const d = doc.data();
        const fromIsMe = String(d.fromUid) === String(myUid);
        msgs.push({
          from: fromIsMe ? 'me' : 'them',
          text: d.text || d.lastMessage || '',
          time: d.time ? (new Date(d.time)).toLocaleString() : (d.timeString || ''),
          fromUid: d.fromUid,
          toUid: d.toUid,
          seen: !!d.seen
        });
      });
      messages[String(otherUid)] = msgs;
      saveMessagingState();
      if (String(currentChatUID) === String(otherUid)) try{ renderChat(); }catch(e){}
      try{ updateNotificationBadge(); }catch(e){}
    }, err => { console.warn('chat onSnapshot err', err); });
  }catch(e){ console.warn('listenToChatMessages failed', e); }
}
// --- end injection ---

// Status box (black box)
const statusBox = document.createElement('div');
statusBox.id = "firebaseStatusBox";
statusBox.style.position = "fixed";
statusBox.style.bottom = "10px";
statusBox.style.left = "10px";
statusBox.style.padding = "8px 12px";
statusBox.style.background = "#000";
statusBox.style.color = "#0f0";
statusBox.style.fontSize = "12px";
statusBox.style.fontFamily = "monospace";
statusBox.style.borderRadius = "6px";
statusBox.style.zIndex = 99999;
statusBox.textContent = "Firebase: Initializing...";
document.addEventListener("DOMContentLoaded", ()=>document.body.appendChild(statusBox));

function setFBStatus(msg, color="#0f0") {
  const box = document.getElementById("firebaseStatusBox");
  if(box) { box.textContent = "Firebase: " + msg; box.style.color = color; }



// --- BEGIN: Ensure Manage Profile loads the user's profile for editing ---
async function loadMyProfileIfExists() {
  try {
    const storedMy = localStorage.getItem('profiles_my_uid_v1');
    if (!storedMy) return null;
    myUID = String(storedMy);
    // First try users/{myUID} doc to get linked profileUid
    try {
      const userDoc = await db.collection('users').doc(String(myUID)).get();
      if (userDoc.exists) {
        const data = userDoc.data();
        const profileUid = data && data.profileUid ? String(data.profileUid) : null;
        if (profileUid) {
          const profDoc = await db.collection('profiles').doc(String(profileUid)).get();
          if (profDoc.exists) {
            myProfile = profDoc.data();
          }
        }
      }
    } catch(e){ console.warn('loadMyProfile: users lookup failed', e); }
    // Fallback: try find profile in loaded profiles array by myUID
    if (!myProfile) {
      const found = profiles.find(p => String(p.uid) === String(myUID));
      if (found) myProfile = found;
    }
    // If we found a profile, update UI/text
    if (myProfile) {
      const btn = document.getElementById('profileBtn');
      if (btn) btn.textContent = 'Manage Profile';
      // ensure profile is present in profiles array
      const idx = profiles.findIndex(p => String(p.uid) === String(myProfile.uid));
      if (idx === -1) profiles.push(myProfile); else profiles[idx] = myProfile;
      setFBStatus('My profile loaded');
      return myProfile;
    }
    return null;
  } catch(err){
    console.warn('loadMyProfileIfExists error', err);
    setFBStatus('MyProfile load err','red');
    return null;
  }
}

// Replace profileBtn click to guarantee we attempt to load myProfile before opening the form
(function patchProfileBtnClick(){
  const btn = document.getElementById('profileBtn');
  if (!btn) return;
  // remove inline onclick if present and add safer async handler
  try { btn.removeAttribute('onclick'); } catch(e){}
  btn.addEventListener('click', async function(evt){
    // if myProfile not yet loaded, try to load it
    if (typeof myProfile === 'undefined' || myProfile === null) {
      await loadMyProfileIfExists();
    }
    // open the form (openProfileForm will detect myProfile and prefill)
    try { openProfileForm(); } catch(e){ console.warn('openProfileForm error', e); }
  });
})();
// --- END manage profile patch ---


}

// Basic profile save/load (will be augmented later)
async function saveProfileToFirebase(profile) {
  try {
    await db.collection("profiles").doc(String(profile.uid)).set(profile);
    setFBStatus("Profile saved ("+profile.uid+")");
  } catch(e) {
    console.error("Firebase save error", e);
    setFBStatus("Save error: "+e.message, "red");
  }
}

// Load all profiles from Firestore
async function loadProfilesFromFirebase() {
  try {
    const snapshot = await db.collection("profiles").get();
    profiles = [];
    snapshot.forEach(doc => { profiles.push(doc.data()); });
    setFBStatus("Profiles loaded: "+profiles.length);
    displayProfiles();
  } catch(e) {
    console.error("Firebase load error", e);
    setFBStatus("Load error: "+e.message, "red");
  }
}

// Hook profile save event to Firestore (existing form will call saveProfileToFirebase after submit)
(function(){
  const form = document.getElementById('profileForm');
  if(form){
    form.addEventListener('submit', function(){
      setTimeout(()=>{ if(myProfile) saveProfileToFirebase(myProfile); }, 150);
    });
  }
})();

document.addEventListener("DOMContentLoaded", ()=>{
  loadProfilesFromFirebase();
});
</script>


<script>
(function(){
  const db = firebase.firestore();
  const FieldValue = firebase.firestore.FieldValue;

  function chatIdFor(a,b){
    if(a===undefined||b===undefined) return null;
    const sa = String(a), sb = String(b);
    return 'chat_' + (sa < sb ? sa + '_' + sb : sb + '_' + sa);
  }

  async function writeMessageToFirestore(msgObj){
    try{
      const chatId = chatIdFor(msgObj.fromUid, msgObj.toUid);
      if(!chatId) return;
      const chatRef = db.collection('chats').doc(chatId);
      await chatRef.set({ participants: [String(msgObj.fromUid), String(msgObj.toUid)], lastMessage: msgObj.text, lastTime: new Date().toISOString() }, { merge: true });
      await chatRef.collection('messages').add(Object.assign({}, msgObj, { time: new Date().toISOString() }));
      setFBStatus('Message saved');
    }catch(e){ console.warn('writeMessageToFirestore failed', e); setFBStatus('Msg save err','red'); }
  }

  // Wrap existing sendMessage to also persist to Firestore and update recipient notifications
  const origSend = window.sendMessage || function(){};
  window.sendMessage = function(){
    try{ origSend(); }catch(e){ console.warn('origSend failed', e); }
    try{
      if(!currentChatUID) return;
      const arr = messages[currentChatUID] || [];
      const last = arr[arr.length - 1];
      if(last && last.fromUid){
        writeMessageToFirestore(last);
        // create a notification for recipient in users/{toUid}/notifications
        if(last.toUid){
          const notif = { fromUid: String(last.fromUid), name: getProfileNameByUID(last.fromUid) || 'Sender', lastMessage: last.text, time: new Date().toISOString(), read: false };
          db.collection('users').doc(String(last.toUid)).collection('notifications').add(notif).then(()=> setFBStatus('Notif saved')).catch(e=> setFBStatus('Notif save err','red'));
        }
      }
    }catch(e){ console.warn('sendMessage wrapper failed', e); }
  };

  // Wrap existing saveProfile to also update user's savedProfiles on Firestore
  if(window.saveProfile){
    const origSaveProfile = window.saveProfile;
    window.saveProfile = function(p){
      try{ origSaveProfile(p); }catch(e){ console.warn('origSaveProfile failed', e); }
      try{
        if(typeof myUID !== 'undefined' && myUID !== null){
          const userRef = db.collection('users').doc(String(myUID));
          const isSaved = savedProfiles.some(sp => String(sp.uid) === String(p.uid));
          if(isSaved){
            userRef.set({ savedProfiles: firebase.firestore.FieldValue.arrayUnion(String(p.uid)) }, { merge: true });
            setFBStatus('Saved profile synced');
          } else {
            // remove by arrayRemove
            userRef.update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(String(p.uid)) }).then(()=> setFBStatus('Unsaved synced')).catch(()=>{});
          }
        }
      }catch(e){ console.warn('saveProfile-firestore sync failed', e); }
    };
  }

  // Load user-specific document (saved profiles + notifications) and mirror to local app state
  async function loadUserData(uid){
    if(!uid) return;
    try{
      const userDoc = await db.collection('users').doc(String(uid)).get();
      if(userDoc.exists){
        const data = userDoc.data();
        // sync savedProfiles
        if(Array.isArray(data.savedProfiles)){
          savedProfiles = [];
          data.savedProfiles.forEach(pid => {
            const p = profiles.find(x => String(x.uid) === String(pid));
            if(p) savedProfiles.push(p);
          });
          displaySaved();
          updateSaveButtonState();
        }
      }
      // load notifications subcollection for the user
      const notifSnap = await db.collection('users').doc(String(uid)).collection('notifications').get();
      unreadNotifications = [];
      readNotifications = [];
      notifSnap.forEach(doc=>{
        const d = doc.data();
        const obj = { uid: d.fromUid || doc.id, name: d.name || 'Unknown', lastMessage: d.lastMessage || '', time: d.time || '', _docId: doc.id, read: !!d.read };
        if(d.read) readNotifications.push(obj); else unreadNotifications.push(obj);
      });
      saveMessagingState();
      // optionally, load chats where participants contain uid (only metadata to start)
      const chatsSnap = await db.collection('chats').where('participants','array-contains',String(uid)).get();

      // preload messages and attach listeners for chats involving this user (so other devices will sync)
      try{
        chatsSnap.forEach(doc=>{
          try{
            const participants = doc.data().participants || [];
            const other = participants.find(p => String(p) !== String(uid));
            if(other){
              try{ listenToChatMessages(uid, other); }catch(e){}
              try{ loadChatMessagesOnce(uid, other); }catch(e){}
            }
          }catch(e){}
        });
      }catch(e){}

      setFBStatus('User data loaded');
    }catch(e){ console.warn('loadUserData failed', e); setFBStatus('User load err','red'); }
  }

  // On startup, set Manage/Create button depending on stored myUID and Firestore data
  document.addEventListener('DOMContentLoaded', async function(){
    try{
      const storedMy = localStorage.getItem('profiles_my_uid_v1');
      if(storedMy){
        myUID = storedMy;
        const btn = document.getElementById('profileBtn');
        if(btn) btn.textContent = 'Manage Profile';
        await loadUserData(myUID);
        setFBStatus('Ready (user '+String(myUID)+')');
      } else {
        setFBStatus('Ready (no user)');
      }
    }catch(e){ console.warn(e); }
  });

  // Extend saveProfileToFirebase to also create/merge a users/{myUID} doc for saved state & link profile
  if(window.saveProfileToFirebase){
    const origSaveFB = window.saveProfileToFirebase;
    window.saveProfileToFirebase = async function(profile){
      try{ await origSaveFB(profile); }catch(e){ console.warn('origSaveFB failed', e); }
      try{
        // set myUID to profile.uid if not set
        if(typeof myUID === 'undefined' || myUID === null) myUID = String(profile.uid);
        localStorage.setItem('profiles_my_uid_v1', String(myUID));
        const userRef = db.collection('users').doc(String(myUID));
        await userRef.set({ profileUid: String(profile.uid) }, { merge: true });
        // ensure profile doc has hireCount & rating fields set
        const profRef = db.collection('profiles').doc(String(profile.uid));
        await profRef.set({ hireCount: Number(profile.hireCount || 0), ratingsSum: Number(profile.ratingsSum || 0), ratingsCount: Number(profile.ratingsCount || 0) }, { merge: true });
        const btn = document.getElementById('profileBtn'); if(btn) btn.textContent = 'Manage Profile';
        await loadUserData(myUID);
        setFBStatus('Profile & user linked');
      }catch(e){ console.warn('post-saveProfileToFirebase failed', e); setFBStatus('Post-save err','red'); }
    };
  }

  // Rating UI injection into openProfile
  function ensureRatingUI(){
    const container = document.querySelector('.open-profile .profile-actions');
    if(!container) return;
    if(document.getElementById('ratingStars')) return;
    const wrap = document.createElement('div');
    wrap.className = 'profile-rating';
    wrap.style.marginLeft = '12px';
    wrap.innerHTML = '<div style="font-weight:800;color:#fff">Rate this profile</div><div class="rating-stars" id="ratingStars"></div><div class="rating-result" id="ratingResult"></div>';
    container.appendChild(wrap);
    const stars = document.getElementById('ratingStars');
    for(let i=1;i<=5;i++){
      const sp = document.createElement('span');
      sp.textContent = '‚òÖ';
      sp.dataset.value = i;
      sp.onclick = function(){
        const val = Number(this.dataset.value);
        submitRating(currentOpenProfile.uid, val);
      };
      stars.appendChild(sp);
    }
  }
  if(window.openProfile){
    const origOpen = window.openProfile;
    window.openProfile = function(p){
      try{ origOpen(p); }catch(e){ console.warn('origOpenProfile failed', e); }
      ensureRatingUI();
      const rr = document.getElementById('ratingResult');
      const avg = (p.ratingsCount && p.ratingsCount>0) ? (p.ratingsSum / p.ratingsCount).toFixed(1) : 'No ratings';
      if(rr) rr.textContent = avg==='No ratings' ? avg : 'Average: '+avg+' ('+(p.ratingsCount||0)+' votes)';
    };
  }

  async function submitRating(uid, rating){
    if(!uid) return;
    try{
      const profRef = db.collection('profiles').doc(String(uid));
      await db.runTransaction(async (tx) => {
        const doc = await tx.get(profRef);
        if(!doc.exists){
          tx.set(profRef, { ratingsSum: rating, ratingsCount: 1 }, { merge: true });
        } else {
          const data = doc.data();
          const sum = (data.ratingsSum || 0) + rating;
          const cnt = (data.ratingsCount || 0) + 1;
          tx.update(profRef, { ratingsSum: sum, ratingsCount: cnt });
        }
      });
      setFBStatus('Rating saved');
      // update local copy and UI
      const idx = profiles.findIndex(x=>String(x.uid)===String(uid));
      if(idx!==-1){
        profiles[idx].ratingsSum = (profiles[idx].ratingsSum||0) + rating;
        profiles[idx].ratingsCount = (profiles[idx].ratingsCount||0) + 1;
      }
      displayProfiles();
      if(currentOpenProfile && String(currentOpenProfile.uid) === String(uid)){
        openProfile(profiles.find(x=>String(x.uid)===String(uid)));
      }
    }catch(e){ console.warn('submitRating failed', e); setFBStatus('Rating err','red'); }
  }

  // increment hireCount on profile when OTP verification succeeds
  async function confirmHireAndIncrement(toUid){
    try{
      const profRef = db.collection('profiles').doc(String(toUid));
      await profRef.update({ hireCount: firebase.firestore.FieldValue.increment(1) });
      setFBStatus('Hire incremented');
      // update local
      const idx = profiles.findIndex(x=>String(x.uid)===String(toUid));
      if(idx!==-1){ profiles[idx].hireCount = (profiles[idx].hireCount||0) + 1; }
      if(currentOpenProfile && String(currentOpenProfile.uid)===String(toUid)){
        openProfile(profiles.find(x=>String(x.uid)===String(toUid)));
      }
    }catch(e){ console.warn('confirmHireAndIncrement failed', e); setFBStatus('Hire inc err','red'); }
  }

  // Wrap sendHireOTP to also write OTP to Firestore
  if(window.sendHireOTP){
    const origSendHire = window.sendHireOTP;
    window.sendHireOTP = function(fromUid, toUid, toName){
      try{ origSendHire(fromUid, toUid, toName); }catch(e){ console.warn('origSendHire failed', e); }
      try{
        const rec = { otp: String(Math.floor(100000 + Math.random()*900000)), fromUid: String(fromUid), toUid: String(toUid), time: new Date().toISOString(), used: false };
        db.collection('hireOtps').add(rec).then(()=> setFBStatus('OTP stored in Firestore'));
      }catch(e){ console.warn('sendHireOTP firestore write failed', e); setFBStatus('OTP save err','red'); }
    };
  }

  // Expose verifyHireOTP to validate OTPs stored in Firestore and increment hire counter
  window.verifyHireOTP = async function(otpCode){
    try{
      const q = await db.collection('hireOtps').where('otp','==',String(otpCode)).where('used','==',false).get();
      if(q.empty){ alert('Invalid or used OTP'); return; }
      const doc = q.docs[0];
      const data = doc.data();
      await db.collection('hireOtps').doc(doc.id).update({ used: true, usedAt: new Date().toISOString() });
      await confirmHireAndIncrement(data.toUid);
      alert('OTP verified ‚Äî hire counted.');
    }catch(e){ console.warn('verifyHireOTP failed', e); alert('OTP verification failed'); }
  };

  // Leaderboard computed client-side and displayed in .leaderboard-list
  window.refreshLeaderboard = function(){
    try{
      const arr = profiles.map(p=>{
        const avg = p.ratingsCount && p.ratingsCount>0 ? (p.ratingsSum / p.ratingsCount) : 0;
        const score = avg*10 + (p.hireCount||0)*5;
        return Object.assign({}, p, { score });
      });
      arr.sort((a,b)=>b.score - a.score);
      const lbArea = document.querySelector('.leaderboard-list');
      if(lbArea){
        lbArea.innerHTML = '';
        arr.forEach((p,i)=>{
          const card = document.createElement('div'); card.className='leader-card';
          const rank = document.createElement('div'); rank.className='leader-rank'; rank.textContent = (i+1);
          if(i===0) rank.classList.add('leader-gold');
          else if(i===1) rank.classList.add('leader-silver');
          else if(i===2) rank.classList.add('leader-bronze');
          const info = document.createElement('div'); info.className='leader-info';
          info.innerHTML = `<strong>${p.name}</strong><div class="uid">UID: ${p.uid}</div><div class="meta">Score: ${Math.round(p.score)}</div>`;
          card.appendChild(rank); card.appendChild(info);
          lbArea.appendChild(card);
        });
      }
    }catch(e){ console.warn('refreshLeaderboard failed', e); }
  };

  // Hook into existing loadProfilesFromFirebase to refresh leaderboard afterwards
  if(window.loadProfilesFromFirebase){
    const origLoad = window.loadProfilesFromFirebase;
    window.loadProfilesFromFirebase = async function(){
      try{ await origLoad(); }catch(e){ console.warn('origLoadProfiles failed', e); }
      try{ window.refreshLeaderboard(); }catch(e){}
    };
  }

  // Mark notification as read and reflect to Firestore (if doc id stored)
  const origMarkAsRead = window.markAsReadByUID || function(){};
  window.markAsReadByUID = function(uid){
    try{ origMarkAsRead(uid); }catch(e){ console.warn('origMarkAsRead failed', e); }
    try{
      // find the local unreadNotifications entry and update Firestore doc if we have _docId
      const idx = unreadNotifications.findIndex(n => String(n.uid) === String(uid));
      if(idx !== -1){
        const n = unreadNotifications[idx];
        if(n._docId && myUID){
          db.collection('users').doc(String(myUID)).collection('notifications').doc(n._docId).update({ read: true }).then(()=> setFBStatus('Notif marked read')).catch(()=>{});
        }
      }
    }catch(e){ console.warn('markAsRead Firestore update failed', e); }
  };

  // Small connectivity check
  db.collection('profiles').limit(1).get().then(()=> setFBStatus('Connected')).catch(e=> setFBStatus('Conn error','red'));

})(); // closure
</script>


<script>
// --- BEGIN: Delete profile button + status sync ---
(function(){
  // Create delete button and insert after the submit button in profile form
  function createDeleteButtonIfMissing(){
    const form = document.getElementById('profileForm');
    if(!form) return;
    if(document.getElementById('deleteProfileBtn')) return;
    const del = document.createElement('button');
    del.type = 'button';
    del.id = 'deleteProfileBtn';
    del.textContent = 'Delete Profile';
    // style similar to back-btn but smaller and placed near submit
    del.style.marginTop = '6px';
    del.style.background = '#ff3333';
    del.style.color = '#fff';
    del.style.border = 'none';
    del.style.padding = '10px 14px';
    del.style.borderRadius = '10px';
    del.style.cursor = 'pointer';
    del.style.fontWeight = '800';
    del.onclick = function(){ confirmAndDelete(); };
    // insert at end of form
    form.appendChild(del);
    updateDeleteBtnVisibility();
  }

  function updateDeleteBtnVisibility(){
    const del = document.getElementById('deleteProfileBtn');
    if(!del) return;
    if(typeof myProfile !== 'undefined' && myProfile && myProfile.uid){
      del.style.display = 'inline-block';
    } else {
      del.style.display = 'none';
    }
  }

  async function confirmAndDelete(){
    if(!myProfile || !myProfile.uid){
      alert('No profile to delete.');
      return;
    }
    if(!confirm('Delete your profile permanently? This cannot be undone.')) return;
    await deleteMyProfile();
  }

  async function deleteMyProfile(){
    try{
      const uid = String(myProfile.uid);
      // delete profile doc
      await db.collection('profiles').doc(uid).delete();
      // remove reference from users/{myUID}
      if(typeof myUID !== 'undefined' && myUID){
        try {
          await db.collection('users').doc(String(myUID)).set({ profileUid: firebase.firestore.FieldValue.delete() }, { merge: true });
          // remove from savedProfiles array if present
          await db.collection('users').doc(String(myUID)).update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(String(uid)) }).catch(()=>{});
        } catch(e){ console.warn('failed to update user doc on delete', e); }
      }
      // local cleanup
      profiles = profiles.filter(p => String(p.uid) !== uid);
      savedProfiles = savedProfiles.filter(p => String(p.uid) !== uid);
      localStorage.removeItem('profiles_my_uid_v1');
      myProfile = null;
      myUID = null;
      const btn = document.getElementById('profileBtn'); if(btn) btn.textContent = 'Create a Profile';
      displayProfiles(); displaySaved();
      updateDeleteBtnVisibility();
      setFBStatus('Profile deleted');
      alert('Profile deleted successfully.');
    }catch(e){
      console.error('deleteMyProfile error', e);
      setFBStatus('Delete err','red');
      alert('Delete failed: ' + (e && e.message ? e.message : String(e)));
    }
  }

  // Ensure delete button is created on DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    createDeleteButtonIfMissing();
    // create observer to update visibility when myProfile changes (naive approach: poll)
    setInterval(updateDeleteBtnVisibility, 800);
  });

  // Make sure saveProfileToFirebase writes profile.status (patch existing function)
  if(window.saveProfileToFirebase){
    const orig = window.saveProfileToFirebase;
    window.saveProfileToFirebase = async function(profile){
      try{
        // ensure status field present
        if(typeof profile.status === 'undefined' && document.getElementById('status')){
          profile.status = document.getElementById('status').value || 'Free';
        }
        // call original (which writes profile doc)
        await orig(profile);
        // additionally, ensure profile doc merge includes status explicitly
        try{
          await db.collection('profiles').doc(String(profile.uid)).set({ status: profile.status }, { merge: true });
          setFBStatus('Status synced');
        }catch(e){ console.warn('status set failed', e); }
      }catch(e){ console.warn('patched saveProfileToFirebase failed', e); }
    };
  }
})(); 
// --- END: Delete profile button + status sync ---
</script>


<script>
// === Improved Delete button handler and Wipe All Profiles (safe dev tool) ===
(function(){
  // helper to safely get myProfile or try to load it
  async function ensureMyProfileLoaded() {
    try {
      if (typeof myProfile !== 'undefined' && myProfile && myProfile.uid) return myProfile;
      if (typeof loadMyProfileIfExists === 'function') {
        const p = await loadMyProfileIfExists();
        if (p) return p;
      }
      // fallback: try localStorage or profiles array
      const stored = localStorage.getItem('profiles_my_uid_v1');
      if (stored) {
        const found = profiles.find(x => String(x.uid) === String(stored));
        if (found) { myProfile = found; return myProfile; }
        try {
          const prof = await db.collection('profiles').doc(String(stored)).get();
          if (prof.exists) { myProfile = prof.data(); return myProfile; }
        } catch(e){ console.warn('ensureMyProfileLoaded db fetch failed', e); }
      }
      return null;
    } catch(e){ console.warn('ensureMyProfileLoaded failed', e); return null; }
  }

  // Main delete handler wired to the Delete button
  async function handleDeleteClick(e) {
    try {
      const btn = document.getElementById('deleteProfileBtn');
      if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; }
      const p = await ensureMyProfileLoaded();
      if (!p || !p.uid) {
        alert('No profile found to delete.');
        if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
        return;
      }
      const confirmText = prompt('Type DELETE to permanently remove your profile (this cannot be undone):');
      if (String(confirmText).toUpperCase() !== 'DELETE') {
        alert('Delete cancelled.');
        if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
        return;
      }
      // perform deletion
      const uid = String(p.uid);
      try {
        await db.collection('profiles').doc(uid).delete();
      } catch(e) { console.warn('Firestore profile delete failed', e); }
      // remove references from users collection (if myUID exists)
      try {
        const userId = (typeof myUID !== 'undefined' && myUID) ? String(myUID) : null;
        if (userId) {
          await db.collection('users').doc(userId).update({ profileUid: firebase.firestore.FieldValue.delete() }).catch(()=>{});
          await db.collection('users').doc(userId).update({ savedProfiles: firebase.firestore.FieldValue.arrayRemove(uid) }).catch(()=>{});
        }
      } catch(e){ console.warn('cleanup user doc failed', e); }
      // local cleanup
      profiles = profiles.filter(x => String(x.uid) !== uid);
      savedProfiles = savedProfiles.filter(x => String(x.uid) !== uid);
      // remove any simulated unread etc
      try { localStorage.removeItem('profiles_my_uid_v1'); } catch(e){}
      myProfile = null; myUID = null;
      // update UI
      displayProfiles(); displaySaved();
      updateSaveButtonState();
      setFBStatus('Profile deleted');
      alert('Profile deleted successfully.');
    } catch(err) {
      console.error('handleDeleteClick error', err);
      setFBStatus('Delete err','red');
      alert('Delete failed: ' + (err && err.message ? err.message : String(err)));
    } finally {
      const btn = document.getElementById('deleteProfileBtn');
      if (btn) { btn.disabled = false; btn.style.opacity = '1'; }
    }
  }

  // Wipe all profiles (dangerous) - requires typing DELETE ALL
  async function wipeAllProfiles() {
    try {
      const confirmText = prompt('Type DELETE ALL to remove ALL profiles from Firestore and clear local data (irreversible):');
      if (String(confirmText).toUpperCase() !== 'DELETE ALL') {
        alert('Wipe cancelled.');
        return;
      }
      setFBStatus('Wiping all profiles...','yellow');
      // fetch profiles docs
      const snap = await db.collection('profiles').get();
      const docs = snap.docs || [];
      for (let i = 0; i < docs.length; i++) {
        try { await db.collection('profiles').doc(docs[i].id).delete(); } catch(e){ console.warn('delete profile doc failed', docs[i].id, e); }
      }
      // Optionally clear users' profileUid fields (best-effort)
      const usersSnap = await db.collection('users').get();
      for (let u = 0; u < usersSnap.docs.length; u++) {
        const uid = usersSnap.docs[u].id;
        try { await db.collection('users').doc(uid).update({ profileUid: firebase.firestore.FieldValue.delete(), savedProfiles: [] }); } catch(e){ /* ignore */ }
      }
      // Clear local state
      profiles = []; savedProfiles = []; myProfile = null; myUID = null;
      try { localStorage.removeItem('profiles_my_uid_v1'); } catch(e){}
      displayProfiles(); displaySaved(); updateSaveButtonState();
      setFBStatus('All profiles wiped');
      alert('All profiles removed from Firestore and local app.');
    } catch(e) {
      console.error('wipeAllProfiles failed', e);
      setFBStatus('Wipe err','red');
      alert('Wipe failed: ' + (e && e.message ? e.message : String(e)));
    }
  }

  // Attach handlers and add menu item for wipe
  document.addEventListener('DOMContentLoaded', function(){
    // wire delete button (if exists) to our handler; otherwise create it
    let del = document.getElementById('deleteProfileBtn');
    if (!del) {
      const form = document.getElementById('profileForm');
      if (form) {
        del = document.createElement('button');
        del.type = 'button';
        del.id = 'deleteProfileBtn';
        del.textContent = 'Delete Profile';
        del.style.marginTop = '6px';
        del.style.background = '#ff3333';
        del.style.color = '#fff';
        del.style.border = 'none';
        del.style.padding = '10px 14px';
        del.style.borderRadius = '10px';
        del.style.cursor = 'pointer';
        del.style.fontWeight = '800';
        form.appendChild(del);
      }
    }
    if (del) {
      del.removeEventListener('click', handleDeleteClick);
      del.addEventListener('click', handleDeleteClick);
      // visibility update
      const show = (typeof myProfile !== 'undefined' && myProfile && myProfile.uid);
      del.style.display = show ? 'inline-block' : 'none';
    }

    // add "Wipe All Profiles" to dropdown menu for dev use
    const menu = document.getElementById('menuDropdown');
    if (menu && !menu.querySelector('.wipe-all-item')) {
      const item = document.createElement('div');
      item.className = 'wipe-all-item';
      item.textContent = 'Wipe All Profiles (dev)';
      item.style.color = '#ff3333';
      item.onclick = function(){ wipeAllProfiles(); };
      menu.appendChild(item);
    }
  });

  // Also expose wipe function globally for console testing
  window.wipeAllProfiles = wipeAllProfiles;
})(); 
</script>

</body>
</html>
