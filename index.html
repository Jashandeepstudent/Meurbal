function renderBrowseStories(selectedCategory = 'All', opts = { includeDemo: true, demoCount: 50, mergeWithSaved: true }) {
  const rng = rngForStoryRender();
  try {
    const storiesListDiv = document.getElementById('storiesBrowseList');
    const cards = document.getElementById('storiesCards');
    if (!cards) return;

    // Ensure main container is vertical and full-width
    cards.style.display = 'block';
    cards.style.width = '100%';
    cards.style.flexWrap = 'wrap';

    const publicStories = (storiesData || []).filter(s => s.status === 'Public');
    let filteredStories = selectedCategory !== 'All'
      ? publicStories.filter(s => (s.genre || '').toLowerCase() === selectedCategory.toLowerCase())
      : publicStories;

    const demoStories = opts.includeDemo ? generateDemoStories(opts.demoCount || 50, rng) : [];
    let allStories = opts.mergeWithSaved ? demoStories.concat(filteredStories) : demoStories;

    if (allStories.length === 0) {
      storiesListDiv.style.display = 'none';
      return;
    } else {
      storiesListDiv.style.display = 'block';
    }

    // Save horizontal scroll positions for each genre
    const oldScrollX = {};
    cards.querySelectorAll('div[data-genre]').forEach(sec => {
      const g = sec.dataset.genre;
      const sc = sec.querySelector('.scroll-wrap');
      if (sc) oldScrollX[g] = sc.scrollLeft;
    });

    const genresOrder = ["Action", "Romance", "Comedy", "Fantasy", "Horror", "Tragic", "Other"];
    const grouped = {};
    allStories.forEach(s => {
      const g = s.genre ? s.genre.trim() : "Other";
      if (!grouped[g]) grouped[g] = [];
      grouped[g].push(s);
    });

    const allScored = scoredStories(allStories, rng);
    const scoredMap = new Map();
    allScored.forEach(s => scoredMap.set(s.id ?? s.title, s));

    const imagesToWait = [];

    genresOrder.forEach(genre => {
      const list = grouped[genre];
      if (!list || list.length === 0) return;

      // --- reuse existing section if possible ---
      let section = cards.querySelector(`div[data-genre="${genre}"]`);
      if (!section) {
        section = document.createElement('div');
        section.dataset.genre = genre;
        section.style.display = 'block';
        section.style.marginBottom = '32px';
        cards.appendChild(section);

        const heading = document.createElement('h3');
        heading.textContent = genre;
        heading.style.margin = '6px 12px';
        heading.style.textAlign = 'left';
        section.appendChild(heading);
      }

      // --- reuse or create scrollWrap ---
      let scrollWrap = section.querySelector('.scroll-wrap');
      if (!scrollWrap) {
        scrollWrap = document.createElement('div');
        scrollWrap.className = 'scroll-wrap';
        scrollWrap.style.display = 'flex';
        scrollWrap.style.overflowX = 'auto';
        scrollWrap.style.gap = '12px';
        scrollWrap.style.padding = '12px';
        scrollWrap.style.scrollBehavior = 'smooth';
        scrollWrap.style.scrollbarWidth = 'thin';
        scrollWrap.style.flexWrap = 'nowrap';
        section.appendChild(scrollWrap);
      }
      // Clear only the cards inside
      scrollWrap.innerHTML = '';

      const scoredList = list.map(s => scoredMap.get(s.id ?? s.title) || Object.assign({}, s, { __score: rng() * 0.2 }));
      const sorted = scoredList.slice().sort((a, b) => b.__score - a.__score);

      const displayCount = Math.min(sorted.length, Math.max(STORY_ALGO_CONFIG.cardsPerViewport, Math.ceil(sorted.length)));
      const explorationCount = Math.ceil(displayCount * STORY_ALGO_CONFIG.explorationFraction);
      const topCandidates = sorted.slice(0, Math.max(0, displayCount - explorationCount));
      const remaining = sorted.slice(displayCount - explorationCount);
      const explorationPool = remaining.concat(sorted.slice(displayCount));
      const explorationPicked = pickStoryExploration(explorationPool, explorationCount, rng);

      const finalList = [];
      const maxLen = Math.max(topCandidates.length, explorationPicked.length);
      for (let i = 0; i < maxLen; i++) {
        if (i < topCandidates.length) finalList.push(topCandidates[i]);
        if (i < explorationPicked.length) finalList.push(explorationPicked[i]);
      }
      if (finalList.length === 0) finalList.push(...sorted.slice(0, displayCount));
      shuffleArray(finalList, rng);

      // --- build cards ---
      finalList.forEach(s => {
        const card = document.createElement('div');
        card.className = 'story-card';
        card.dataset.title = s.title || '';
        card.style.minWidth = '260px';
        card.style.flex = '0 0 auto';
        card.style.borderRadius = '14px';
        card.style.padding = '14px';
        card.style.boxShadow = '0 6px 16px rgba(0,0,0,0.1)';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.justifyContent = 'space-between';
        card.style.cursor = 'pointer';
        card.style.transition = 'transform 0.2s';
        card.addEventListener('mouseenter', () => card.style.transform = 'scale(1.03)');
        card.addEventListener('mouseleave', () => card.style.transform = 'scale(1)');

        if (s.cover) {
          const img = new Image();
          img.src = s.cover;
          imagesToWait.push(new Promise(resolve => { if (img.complete) return resolve(); img.onload = img.onerror = () => resolve(); }));
          card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4),rgba(0,0,0,0.4)),url(${s.cover})`;
          card.style.backgroundSize = 'cover';
          card.style.backgroundPosition = 'center';
          card.style.color = '#fff';
        } else {
          let color;
          switch ((s.genre || '').toLowerCase()) {
            case 'action': color = '#ff4b4b'; break;
            case 'romance': color = '#ff6fa8'; break;
            case 'comedy': color = '#ffd54f'; break;
            case 'tragic': color = '#4fc3f7'; break;
            case 'horror': color = '#000'; break;
            case 'fantasy': color = '#a78bfa'; break;
            default: color = '#888'; break;
          }
          card.style.background = color;
          card.style.color = color === '#000' ? '#fff' : '#000';
        }

        const titleEl = document.createElement('h4');
        titleEl.textContent = s.title || 'Untitled';
        titleEl.style.margin = '0 0 6px';
        titleEl.style.fontSize = '17px';
        titleEl.style.fontWeight = '700';
        titleEl.style.textShadow = s.cover ? '1px 1px 3px rgba(0,0,0,0.6)' : '';

        const genreEl = document.createElement('p');
        genreEl.textContent = s.genre || 'Unknown';
        genreEl.style.margin = '0 0 6px';
        genreEl.style.fontSize = '13px';
        genreEl.style.fontWeight = '600';
        genreEl.style.opacity = '0.9';
        genreEl.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

        const desc = document.createElement('p');
        desc.textContent = s.description || '';
        desc.style.margin = '4px 0 8px';
        desc.style.fontSize = '14px';
        desc.style.lineHeight = '1.4';
        desc.style.overflow = 'hidden';
        desc.style.display = '-webkit-box';
        desc.style.webkitLineClamp = '3';
        desc.style.webkitBoxOrient = 'vertical';
        desc.style.textShadow = s.cover ? '1px 1px 2px rgba(0,0,0,0.4)' : '';

        const bottomRow = document.createElement('div');
        bottomRow.style.display = 'flex';
        bottomRow.style.justifyContent = 'space-between';
        bottomRow.style.alignItems = 'center';
        bottomRow.style.marginTop = 'auto';

        const reads = document.createElement('div');
        reads.textContent = 'ðŸ‘ï¸ ' + (s.reads || 0);
        reads.style.fontSize = '13px';
        reads.style.fontWeight = '600';

        const readBtn = document.createElement('button');
        readBtn.className = 'btn btn-primary';
        readBtn.textContent = 'Read';
        readBtn.addEventListener('click', e => {
          e.stopPropagation();
          openPreviewFullScreen(s);
        });

        bottomRow.appendChild(reads);
        bottomRow.appendChild(readBtn);

        card.appendChild(titleEl);
        card.appendChild(genreEl);
        card.appendChild(desc);
        card.appendChild(bottomRow);

        scrollWrap.appendChild(card);
      });

      // Restore horizontal scroll
      if (oldScrollX[genre] !== undefined) {
        const prevBehavior = scrollWrap.style.scrollBehavior;
        scrollWrap.style.scrollBehavior = 'auto';
        scrollWrap.scrollLeft = oldScrollX[genre];
        scrollWrap.style.scrollBehavior = prevBehavior || 'smooth';
      }
    });

    // --- no vertical scroll restoration --- 

  } catch (err) {
    console.warn(err);
  }
}

// Run demo
renderBrowseStories('All');
